#!/bin/bash

# aletheia: a media player with pitch controls and voice feedback
#
# Copyright 2021-2023 Brad Hermanson <apeitheo@gmail.com>
#
# Aletheia is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License, version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details,
# available at https://www.gnu.org/licenses/
#
# Support: https://www.patreon.com/aletheia_project

PROGRAMNAME="aletheia"
SCRIPTNAME="`echo -ne \"$0\" | rev | cut -d'/' -f1 | rev`"
VERSION="0.9.6"

if [ "$1" == "--version" ]; then
	echo -e "$VERSION"
	exit 0
elif [ "$1" == "--help" ]; then
	buf="`printf '%*s' ${#PROGRAMNAME}`"
	echo -e "Usage: $PROGRAMNAME [option] [<file/directory>|keyword]"
	echo
	echo -e "        $buf--file <file>"
	echo -e "        $buf--directory <directory>"
	echo -e "        $buf--playlist <file>"
	echo
	echo -e "        $buf--music [keyword]"
	echo -e "        $buf--sound [keyword]"
	echo -e "        $buf--video [keyword]"
	echo
	echo -e "        $buf--server"
	echo -e "        $buf--version"
	echo
	echo -e "See \`man $PROGRAMNAME\` for more help."
	exit 0
fi

tput civis
stty -echo
stty -ixon
clear

ALETHEIA="$HOME/.aletheia"
MUSICDIR="$HOME/Music/"
SCRIPTPATH="`realpath $0`"
WEB_CLIENT=${WEB_CLIENT:-0}
CENTER_BAR_POSITION=0

HELPBUFFER=()
VOICEHELPBUFFER=()
TMPBUFFER=()
TWO_COLUMN=false
VOICE_TWO_COLUMN=false
SCALE_SPEED=0.2
DEFAULT_SCALE_SPEED=$SCALE_SPEED
DIMENSIONS_RESET=false
QBUFARRAY=()
QUEUE_RENDERED=false
#BPM=
OUTPUT=""
#KEEP_LOOP=false
SELECT_REPEAT_FILE=false
LOOP_ON=false
SAVED_POSITION=""
CURRENT_POSITION=""

TOP_BAR_MENU="\033(0lqqqqqqqk\033(B"
BOTTOM_BAR_MENU="\033(0mqqqqqqqj\033(B"
BAR="\033(0x\033(B"
TBAR="\033(0w\033(B"
BOTTOM_TBAR="\033(0v\033(B"
PANEL_HORIZONTAL_DIVIDER="\033(0`printf '%*s' $(tput cols) | tr ' ' 'q'`\033(B"
BLACK_BACKGROUND=${BLACK_BACKGROUND:-true}
NOCOLOR='\033[0m'
BLACK='\033[1;30m'
GRAY='\033[0;30m'
if [ "$BLACK_BACKGROUND" == true ]; then
	WHITE='\033[1;37m'
	LIGHTWHITE='\033[0;37m'
	WHITE_BLACK='\033[1;37;1;40m'
else
	WHITE='\033[1;30m'
	LIGHTWHITE='\033[0;30m'
	WHITE_BLACK='\033[1;30;1;40m'
fi

if [ "$PANELS_ENABLED" == "" ]; then
	PANELS_ENABLED=false
fi
if [ "$COLORS_ENABLED" == false ]; then
	GREEN_BLACK='\033[1;37;1;40m'
	BLUE_BLACK='\033[1;37;1;40m'
	RED_BLACK='\033[1;37;1;40m'
	CYAN_BLACK='\033[1;37;1;40m'
	YELLOW_BLACK='\033[1;37;1:40m'
	RED='\033[1;37m'
	LIGHTRED='\033[0;37m'
	GREEN='\033[1;37m'
	BLUE='\033[1;37m'
	YELLOW='\033[1;37m'
	LIGHTBLUE='\033[1;37m'
	PURPLE='\033[1;37m'
	CYAN='\033[1;37m'
else
	RED='\033[1;31m'
	LIGHTRED='\033[0;31m'
	GREEN='\033[1;32m'
	BLUE='\033[1;34m'
	YELLOW='\033[1;33m'
	LIGHTBLUE='\033[1;34m'
	PURPLE='\033[1;35m'
	CYAN='\033[1;36m'
	LIGHTCYAN='\033[0;36m'
	LIGHTRED='\033[0;31m'
	if [ "$PANELS_ENABLED" == true ]; then
		GREEN_BLACK='\033[1;32;1;40m'
		BLUE_BLACK='\033[1;34;1;40m'
		RED_BLACK='\033[1;31;1;40m'
		CYAN_BLACK='\033[1;36;1;40m'
		WHITE_BLACK='\033[1;37;1;40m'
		YELLOW_BLACK='\033[1;33;1:40m'
		LIGHTRED_BLACK='\033[0;31m;1;40m'
	else
		GREEN_BLACK='\033[1;32m'
		BLUE_BLACK='\033[1;34m'
		RED_BLACK='\033[1;31m'
		CYAN_BLACK='\033[1;36m'
		WHITE_BLACK='\033[1;37m'
		YELLOW_BLACK='\033[1;33m'
		LIGHTRED='\033[0;31m'
	fi
fi

ONLY_DISPLAY_SONG=false

RETURN_QUIT="1"
RETURN_BACK="2"
RETURN_RESTART="3"
RETURN_JUMP="4"
RETURN_LOOP_ARTIST="5"
RETURN_LOOP_ARTIST_BACK="6"
RETURN_TRACK_RANDOM="7"
RETURN_TRACK_RANDOM_BACK="8"
RETURN_ONLY_LOCKED_BACK="9"

DEFAULT_INTERVAL="0"
DEFAULT_EDO="60"
DEFAULT_VOLUME="50"
DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
EQUALIZER="$DEFAULT_EQUALIZER"
LOCKED_EDO=$DEFAULT_EDO
VOLUME=""
LOCKED_OFF=false
ONLY_PITCH=false

LOCKING_POS=0
EDO_LIMIT="1000000"
INTERVAL_LIMIT=`calc "$DEFAULT_EDO * 2.6"`
INTERVAL_UPPER_LIMIT=`calc "$DEFAULT_EDO * 2.0"`
SAVED_INTERVAL=""
SAVED_EDO=""

SEARCH=false
KEYWORD=""
FILENAME=""

SLEEPING=false
SUSPEND=false

LOOP=false          #1
LOOP_ARTIST=false   #2
TRACK_RANDOM=false  #3
ONLY_LOCKED=false   #4
REPEAT_ONLY=false
LOOPS_ONLY=false
SHUFFLED=false
REPEAT_ONLY_INDEX=""

JUMP=0
POSITION=0
TOTAL_QUEUE=0
LOOP_ARTIST_NAME=""
RIGHT_BANNER_WIDTH=0
LEFT_BANNER_WIDTH=0
CORNER_DIVIDER=":"

VIDEO=false
VIDEO_FLAGGED=false
FULLSCREEN=true
ALWAYS_ON_TOP=true

ARTIST=""
SONG=""
pick=""
no_queue_flag=false
loading=true
play_pid=""

MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"

#MIXER_OUTPUT="`amixer sset Master unmute - | grep \"Front\" | grep \"\[\"`"
#MASTER_VOLUME_LEFT="`echo \"$MIXER_OUTPUT\" | grep Left | cut -d'[' -f2 | cut -d']' -f1`"
#MASTER_VOLUME_RIGHT="`echo \"$MIXER_OUTPUT\" | grep Right | cut -d'[' -f2 | cut -d']' -f1`"

QBUFFER=""
DOWNLOAD_POSITION=""

VOICE_ENABLED=false
VOICE_SPEED=160
VOICE_PITCH=0
VOICE_VOLUME=0.3
VOICE_GENDER="en-us+m1"

ONLY_VOICE_TITLES=false

#PADDING="$BLUE`echo -ne \"\033(0\"`x`echo -ne \"\033(B\"` "
#RIGHTPADDING="$BLUE`echo -ne \" \033(0\"`x`echo -ne \"\033(B\"`"
DEFAULTPADDING=" "
PADDING=${PADDING:-$DEFAULTPADDING}
RIGHTPADDING=${RIGHTPADDING:-$DEFAULTPADDING}
if [ "$RIGHT_PADDING" != "" ]; then
	RIGHT_PADDING=${RIGHT_PADDING:-${#DEFAULTPADDING}}
	for i in `seq 1 $RIGHT_PADDING`; do
		RIGHTPADDING="$RIGHTPADDING "
	done
fi

LINES=`tput lines`
COLS=`tput cols`
PANE_WIDTH="$(($COLS - 1 - 1))"

POSITION_WIDTH=0

compute() {
	gtts-cli " $1" -o "/tmp/_$2-tmp.mp3" >/dev/null 2>/dev/null
	sox "/tmp/_$2-tmp.mp3" "$ALETHEIA/voices/$2-${VOICE_PITCH}int.mp3" speed `calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-` >/dev/null 2>/dev/null
	rm -f "/tmp/_$2-tmp.mp3"
	if [ "`echo -e \"$VOICE_VOLUME > 0.3\" | bc`" == "1" ]; then
		VOICE_VOLUME=0.3
	fi
	play -v "$VOICE_VOLUME" "$ALETHEIA/voices/$2-${VOICE_PITCH}int.mp3" >/dev/null 2>/dev/null
}

#espeak_say_natural() {
#	espeak_say "$1" "$2" "$3"
#}

espeak_say_natural() {
	if [ "$VOICE_ENABLED" == true ] || [ "$2" == true ] || [ "$4" == true ]; then
		if [ "$ONLY_VOICE_TITLES" == false ] && [ "$VOICE_ENABLED" == false ] && [ "$4" != true ]; then
			return
		fi
		if [ ! -e "$ALETHEIA/voices/" ]; then
			mkdir "$ALETHEIA/voices"
		fi
		if [ "$5" != true ]; then
			killall gtts-cli >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
		else
			pid=$play_pid
			ps -p $play_pid >/dev/null
			if [ "$?" == "1" ]; then
				while [ "$?" == "1" ]; do
					sleep 0.6
					ps -p $pid >/dev/null
				done
			fi
		fi
		#if [ "$3" == "1" ]; then
			#echo -e "$1" | gtts-cli -t mp3 - >/dev/null 2>/dev/null
		#else
		lin="`echo -ne \"$1\" | wc -l`"
		if [ "$lin" -gt 1 ]; then
			clip="`echo -ne \"$1\" | head -1` - $lin"
		else
			if [ "`echo -ne \"$1\" | cut -c 1`" == " " ]; then
				clip="`echo -ne \"$1\" | cut -c 2-`"
			else
				clip="$1"
			fi
			if [ "`echo -ne \"$1\" | cut -c 1`" == "\-" ]; then
				clip="\\$clip"
			fi
		fi
			if [ -e "$ALETHEIA/voices/$clip-${VOICE_PITCH}int.mp3" ]; then
				if [ "`echo -ne \"$clip\" | rev | cut -c 1`" == "?" ]; then
					clip="`echo -ne \"$clip\" | rev | cut -c 2- | rev`\\?"
				fi
				if [ "`echo -e \"$VOICE_VOLUME > 1.0\" | bc`" == "1" ]; then
					VOICE_VOLUME=0.3
				fi
				if [ "$2" == false ] || [ "$2" == "" ]; then
					#wait $play_pid
					play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip-${VOICE_PITCH}int.mp3" >/dev/null 2>/dev/null &
					play_pid="$!"
				else
					#wait $play_pid
					play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip-${VOICE_PITCH}int.mp3" >/dev/null 2>/dev/null
				fi
			else
				if [ "$lin" -gt 1 ]; then
					if [ "$2" == false ] || [ "$2" == "" ]; then
						compute "$1" "$clip" >/dev/null 2>/dev/null &
					else
						compute "$1" "$clip" >/dev/null 2>/dev/null
					fi
				else
					if [ "$2" == false ] || [ "$2" == "" ]; then
						compute "$clip" "$clip" >/dev/null 2>/dev/null &
					else
						compute "$clip" "$clip" >/dev/null 2>/dev/null
					fi
				fi
			fi
		#fi
	fi
}

vanish() {
	feedback_enabled=$VOICE_ENABLED
	inputnew=""
	display=""
	escape_pressed=false
	char_count=0
	line_count=1
	word_count=0
	width=$(($COLS-((${#char_count}+2+${#word_count}+${#line_count})*2)-(${#PADDING}*2)-24))
	#if [ "$width" -gt "$(($COLS-((${#char_count}-2-${#word_count}-${#line_count}-2)*2)))" ]; then
	#	echo -ne "$RED OK"
	#	width="$(($COLS-((${#char_count}-2-${#word_count}-${#line_count}-2)*2)))"
	#fi
	#if [ "$width" -gt "$(($COLS-(${#char_count}-2-${#word_count}-${#line_count}-2)/2))" ]; then
	#	width="$(($COLS-(${#char_count}-2-${#word_count}-${#line_count}-2)/2))"
	#fi
	tput cup $LINES
	#echo -ne "$PADDING"
	tput el
	tput cup $LINES
	echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE --"
	LEFTBANNER_WIDTH="$((6+6))"
	tput cup $LINES $(($COLS/2))
	echo -ne "${BLUE}_"
	tput sc
	visible=true
	char=""
	draw_indicator() {
		tput cup $LINES $(($COLS-${#char_count}-2-${#word_count}-${#line_count}-${#PADDING}))
		echo -ne "$BLUE${char_count}$WHITE:$BLUE${word_count}$WHITE:$BLUE${line_count}$RIGHTPADDING"
	}
	draw_indicator
	tput rc
	until [ "$char" != "" ]; do
		read -rsn1 -t 1 char
		tput cub1
		if [ "$visible" == true ]; then
			echo -ne "${BLUE} "
		else
			echo -ne "${BLUE}_"
		fi
	done
	tmpflag=true
	quit=false
	while true; do
		#tput cup $LINES
		#tput el
		#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
		tput cup $LINES
		echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE -- "
		LEFTBANNER_WIDTH="$((6+6))"
		draw_indicator
		#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
		#if [ "$cursor_visible" == true ]; then
		#	cursor_visible=false
		#	tput cup $LINES $(($COLS/2))
		#	echo -ne " "
		#else
		#	cursor_visible=true
		#	tput cup $LINES $(($COLS/2))
		#	echo -ne "${BLUE}_"
		#fi
		if [ "$tmpflag" == false ]; then
			#if [ "$char" == "" ]; then
			read -rsn1 char
		else
			tmpflag=false
		fi
		# Exit loop on Escape : q key combination
		preword=false
		#if [ true == false ]; then
		if [[ $char == $'\e' ]]; then
			#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
			#tput cup $LINES
			#echo -ne "$PADDING$WHITE   ${BLUE}      $WHITE   "
			tput cup $LINES
			old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
			LEFTBANNER_WIDTH="$((3+6))"

			if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
				printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
			fi
			tput cup $LINES
			espeak_say_natural "command mode"
			#echo -ne "${PADDING}$WHITE-- ${BLUE}CMD$WHITE --"
			#if [ "$VOICE_ENABLED" == true ]; then
			#	espeak-ng "Command?" &
			#fi
			#tput cup $LINES 1
			#echo -ne "\033[36m-- \033[34m~ \033[36m--"
			#tput el
			#echo -ne "     "
			#escape_pressed=true
			while true; do
				read -rsn1 newchar
				if [ "$newchar" == "q" ]; then
					#if [ "$VOICE_ENABLED" == true ]; then
					#	espeak-ng "Quit" &
					#fi
					#clear
					#stty echo
					#tput cnorm
					#exit 0
					if [ "$1" != true ]; then
						draw_pitch
						draw_position
					else
						echo
					fi
					quit=true
					break
				elif [ "$newchar" == "h" ]; then
					if [ "$width" -gt "$((($COLS*5)/8))" ]; then
						continue
						#			width="$(($COLS-1))"
						#		elif [ "$width" == "$COLS" ]; then
						#			width="$(($COLS-1))"
					fi
					width="$(($width+2))"
					newdisplay="`echo -ne \"$display\" | tail -c $width`"
					if [ "${char_count}" -le "$(($width))" ]; then
						#tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))))
						tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
					else
						#tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
						tput cup $LINES $((($COLS/2)-($width/2)))
					fi

					#tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
					#printf "%s" "\033[36m$newdisplay" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[32m\2\o033[36m\3/g'
					echo -ne "$WHITE${newdisplay}${BLUE}_"
					tput el
					draw_indicator
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#	echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
				elif [ "$newchar" == "l" ]; then
					width="$(($width-2))"
					if [ "$width" -lt "0" ]; then
					    width=0
					fi
					newdisplay="`echo -ne \"$display\" | tail -c $width`"
					if [ "${char_count}" -le "$(($width))" ]; then
					    tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
					else
					    tput cup $LINES $((($COLS/2)-($width/2)))
					fi
					#tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
					tput cub1
					echo -ne " "
					#printf "%s" "$newdisplay" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[32m\2\o033[36m\3/g'
					echo -ne "$WHITE${newdisplay}${BLUE}_"
					tput el
					draw_indicator
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					#tput el
				elif [ "$newchar" == "p" ]; then
					toggle_pause true
				elif [ "$newchar" == "w" ]; then
					#if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "saved"
					#fi
					#echo -ne "$inputnew" >journal-"`date`"
					inputnew=$(fold -w 80 -s <<< "$inputnew")
					echo -ne "\n\n`date`\n\n$inputnew\n" >>"$HOME/Documents/journal"
					tput cup $LINES
					#echo -ne "\033[36m-- \033[34mWRITTEN \033[36m--"
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="$((5+6))"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
					fi
					tput cup $LINES
					echo -ne "$PADDING$WHITE-- ${BLUE}SAVED$WHITE --"
					#tput el
					sleep 1.6
					#tput cup $LINES
					#echo -ne "\033[36m-- \033[34m~ \033[36m--"
					#echo -ne "$PADDING$WHITE- ${BLUE}ESC$WHITE - "
					#echo -ne "$PADDING$WHITE   ${BLUE}      $WHITE   "
					#tput el
					#printf '%*s' 9
				elif [ "$newchar" == "n" ]; then
					#if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "new entry"
					#fi
					inputnew=""
					display=""
					char_count=0
					#tput cup $(($LINES/2))
					#tput el
					tput cup $LINES
					tput el
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					draw_indicator
					break
					#elif [ "$newchar" == "o" ]; then
					#	    #if [ "$VOICE_ENABLED" == true ]; then
					#		    espeak_say_natural "editing journal"
					#	    #fi
					#	    vim $HOME/Documents/txt +$
					#	    stty -echo
					#	    tput civis
					#	    #if [ "$VOICE_ENABLED" == true ]; then
					#		    espeak_say_natural "insert mode"
					#	    #fi
					#	    tput cup $LINES 1
					#	    echo -ne "\033[36m-\033[34mINS\033[36m-"
					#	    tput el
					#	tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#	echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					#	    break
				elif [ "$newchar" == "d" ]; then
					if [ "$VOICE_ENABLED" == true ]; then
					    espeak_say_natural "off"
					    VOICE_ENABLED=false
					    feedback_enabled=false
					else
					    VOICE_ENABLED=true
					    espeak_say_natural "on"
					    feedback_enabled=true
					fi

					#if [ "$VOICE_ENABLED" == true ]; then
					#	    VOICE_ENABLED=false
					#	    espeak-ng "Off" &
					#    else
					#	    VOICE_ENABLED=true
					#	    espeak-ng "On" &
					#    fi
				elif [ "$newchar" == "v" ]; then
					fold -w $COLS -s <<< "$inputnew" | less
					#echo -ne "$inputnew" | less
					#if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "insert mode"
					#fi
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="$((6+6))"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
					fi
					tput cup $LINES
					echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE -- "
					tput el
					draw_indicator
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					break
				elif [ "$newchar" == "i" ]; then
					draw_indicator
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					#if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "insert mode"
					#fi
					#tput cup $LINES 1
					#echo -ne "\033[36m-\033[34mINS\033[36m-"
					#tput el
					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
					break
				fi
			done
			if [ "$quit" == true ]; then
				break
			fi
			#while [ "$newchar" != "q" ] || [ "$newchar" != "i" ]; do
			#	if [ "$newchar" == "q" ]; then
			#		break
			#	elif [ "$newchar" == "i" ]; then
			#		escape_pressed=false
			#		break
			#	else
			#		continue
			#	fi
			#	read -rsn1 newchar
			#done
		elif [ "$char" == $'' ]; then
			if [ "$char_count" -gt "0" ]; then
				newchar="`echo -ne \"$inputnew\" | rev | cut -c 1`"
				if [ "$newchar" == " " ]; then
					if [ "$inword" == true ]; then
						inword=false
						word_count=$(($word_count-1))
						draw_indicator
						#else
					fi
					preword=true
					#fi
				elif [ "$newchar" != " " ]; then
					inword=true
				elif [ "$preword" == true ]; then
					inword=true
					preword=false
			fi
			inputnew="`echo -ne \"$inputnew\" | rev | cut -c2- | rev`"
			display="`echo -ne \"$display\" | rev | cut -c2- | rev`"
			char_count=$(($char_count-1))
			draw_indicator
			#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
			#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
			if [ "$word" != "" ]; then
				word="`echo -ne \"$word\" | rev | cut -c2- | rev`"
			fi
			#newdisplay="`echo -ne \"$display\" | tail -c $width`"
			#tput sc
			if [ "${char_count}" -lt "$(($width))" ]; then
				#tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))-1))
				tput cup $LINES $((($COLS/2)-$((${char_count}/2))-1))
				#else
				#	    tput cup $(($LINES/2)) $((($COLS/2)-($width/2)-1))
				echo -ne " "
			fi
			#    printf "%s" " ${newdisplay}_" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[37m\2\o033[36m\3/g'
			#    tput el
			#    tput rc
			#else
			#	if [ "$VOICE_ENABLED" == true ]; then
			#		espeak-ng "Beginning" &
			#		sleep 1
			#	fi
			fi
		elif [ "$char" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			espeak-ng " $inputnew" &
		elif [ "$char" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
		else
			#elif [[ $char == ':' && $escape_pressed == true ]]; then
			#    escape_pressed=false
			#    display=""
			#    continue
			#elif [[ $char == 'q' && $escape_pressed == true ]]; then
			#    break
			#else
			#    escape_pressed=false
			#fi
			char_count=$(($char_count+1))
			if [ "$char" == "" ]; then
				preword=false
				inputnew="${inputnew} "
				display="${display} "
				#if [ "$VOICE_ENABLED" == true ]; then
				if [ "$feedback_enabled" == true ]; then
					espeak-ng "$word" &
					#espeak_say_natural "$word" false false false true &
				fi
				if [ "$inspace" == false ]; then
					word_count=$(($word_count+1))
				fi
				inspace=true
				#fi
				word=""
			else
				preword=false
				inputnew="${inputnew}${char}"
				display="${display}${char}"
				if [ "$inspace" == true ]; then
				    inspace=false
				    inword=true
				fi
				if [ "$char" == "." ] || [ "$char" == "?" ] || [ "$char" == "," ] || [ "$char" == "!" ]; then
				    #if [ "$VOICE_ENABLED" == true ]; then
				    if [ "$feedback_enabled" == true ]; then
					    espeak-ng "$word" &
					    #espeak_say_natural "$word" false false false true &
				    fi
				    word_count=$(($word_count+1))
				    inword=false
				    #fi
				    word=""
				else
				    word="$word$char"
				fi
			fi
		fi
		#tput el
		#display="${display: -80}"
		newdisplay="`echo -ne \"$display\" | tail -c $width`"
		tput sc
		if [ "${char_count}" -le "$(($width))" ]; then
		#tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))))
		tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
		else
		#tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
		tput cup $LINES $((($COLS/2)-($width/2)))
		fi
		#printf "%s" "${newdisplay}_" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[37m\2\o033[36m\3/g'
		echo -ne "$WHITE${newdisplay}${BLUE}_ \b"
		#tput el
		#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
		#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
		draw_indicator
		tput rc
	done
}

if [ "$1" == "--vanish" ]; then
	vanish true
	clear
	tput cnorm
	stty echo
	exit 0
fi

REPEAT_HELP="Loop Controls
5  Start Position
7  End Position
&  Save New Loop
6  Switch Loops
%  Remove Loop
^x  Update Loop
S  Start -0.01
F  Start +0.01
s  Start -0.05
f  Start +0.05
H  End -0.01
L  End +0.01
h  End -0.05
l  End +0.05
,  Gap -1
.  Gap +1
e  End/Start Seam 
^H  Seek to Start"

VOICE_HELP="Voice Controls
d  Spoken Feedback
Volume Settings
8  Volume Down
9  Volume Up
Pitch Settings
J  Down
K  Up"

QUEUE_HELP="Queue Controls
d  Speak Controls
D  Remove Song
<  Move Song Up
>  Move Song Down
s  Keyword Search"


SCALE_HELP="Scale Controls
j  Lower Pitch (Fast)
k  Raise Pitch (Fast)
J  Lower Pitch (Slow)
K  Raise Pitch (Slow)
c  Reverse Direction
o  Slow Down Scale
g  Speed Up Scale
y  $DEFAULT_EDO-EDO
v  Toggle Pitch"

HELP="Basic Controls
i  Menu
?  Key Controls
j  Page Down
k  Page Up
;  Queue
p  Pause
n  Next Song
b  Previous Song
m  Man Page
q  Quit
Voice Feedback
d  Toggle Voice
T  Only Voice Titles
#  Save Settings
I  Speak Status
,  Speak Title
Volume Controls
*  1% Down
(  1% Up
8  3% Down
9  3% Up
!  PCM 1% Down
@  PCM 1% Up
1  PCM 5% Down
2  PCM 5% Up
c  Mute
3  Fade Up/Down
Interval Controls
j  Pitch Down
k  Pitch Up
x  Lock/Unlock
g  Half EDO
o  Double EDO
.  Set INT
/  Set EDO
w  Reset to Locked
H  Least Precise
L  Fully Precise
J  EDO Down
K  EDO Up
y  $DEFAULT_EDO-EDO
4  Reset INT/EDO
^u  Toggle Locked
Pitch Jump Controls
_  Octave Down
+  Octave Up 
M  Inverse INT
Y  Zero INT
Pitch Fade Controls
X  Speed/Reset
t  Zero INT
u  INT Up/Down
U  EDO Up/Down
-  Octave Down
=  Octave Up
m  Inverse INT
G  Oscillate
Balance Controls
{  1% Left Up
}  1% Right Up
[  1% Left Down
]  1% Right Down
0  Reset Fade
)  Reset
Track Controls
h  Seek Backward
l  Seek Forward
b  Queue Backward
n  Queue Forward
p  Pause
\\  Restart 
r  Rename
D  Delete
P  Progress Bar
Queue Controls
;  Queue
O  Edit (VIM)
R  Shuffle
A  Sort
\"  Last of Artist
'  First of Artist
N  Next Artist
B  Previous Artist
Z  Export As
e  Loop Toggle
$  Only Locked
^r  Random Mode
Loop Toggle Controls
E  Loop Song
V  Loop Artist
Search Controls
S  New Search
s  Jump To
^f  Add Songs
Loop Controls
5  Start Position
7  End Position
6  Enter Loop 
^  Switch Loops
&  Lock Loop
%  Unlock Loop
^e  Play Only Loops
^h  Seek to Start
Video Controls
<  Enable Video
>  Fullscreen Video
^t  Always on Top
Download Controls
W  Add Downloads
^w  Jump Downloads
^n  Add and Jump
Advanced Controls
a  Equalizer
^p  Toggle Panels
^o  Invert Color
^y  Color On/Off
^a  Randomize Color
z  Redraw Screen
~  Sleep mode
|  About"

HELP_LENGTH="`echo -e \"$HELP\"| wc -l`"
VOICE_HELP_LENGTH="`echo -e \"$VOICE_HELP\"| wc -l`"
SCALE_HELP_LENGTH="`echo -e \"$SCALE_HELP\"| wc -l`"
REPEAT_HELP_LENGTH="`echo -e \"$REPEAT_HELP\"| wc -l`"
QUEUE_HELP_LENGTH="`echo -e \"$QUEUE_HELP\"| wc -l`"

espeak_say() {
	if [ "$voice_enabled" == true ] || [ "$2" == true ]; then
		#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
		killall espeak-ng >/dev/null 2>/dev/null
		#killall play >/dev/null 2>/dev/null
		#killall gtts-cli >/dev/null 2>/dev/null
		if [ "$3" == true ] && [ "$1" != " " ]; then
			espeak-ng -s$voice_speed -v$voice_gender -a$voice_volume -p$voice_pitch " $1" >/dev/null 2>/dev/null
			#gtts-cli " $1" | play -t mp3 - >/dev/null 2>/dev/null
		elif [ "$1" != " " ]; then
			espeak-ng -s$voice_speed -v$voice_gender -a$voice_volume -p$voice_pitch " $1" >/dev/null 2>/dev/null &
			#gtts-cli " $1" | play -t mp3 - >/dev/null 2>/dev/null &
		fi
	fi
}

draw_banner() {
	if [ "$3" != true ]; then
		LEFT_BANNER_WIDTH="$((${#i}+6))"
	else
		RIGHT_BANNER_WIDTH="$((${#i}+6))"
	fi
	if [ "$2" == false ] || [ "$2" == "" ]; then
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length="$POSITION_WIDTH"
		warning=false
	else
		COLOR1="$WHITE_BLACK"
		COLOR2="$RED_BLACK"
		length=12
		warning=true
	fi
	
	if [ "$3" == false ] || [ "$3" == "" ]; then
		tput cup $LINES
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1 $COLOR1--$COLOR2 "
		tput sc
		if [ "$RIGHT_BANNER_WIDTH" != "0" ]; then
			if [ "$4" == true ]; then
				length="$RIGHT_BANNER_WIDTH"
			fi
		fi
		if [ "$((${#1} + 6 + $RIGHT_BANNER_WIDTH + (${#PADDING}*2)))" -lt "$COLS" ]; then
			printf '%*s' $(($COLS - ${#1} - 7 - (${#PADDING}*2) - $length))
			#printf '%*s' $(($COLS - (${#PADDING}*2) - ${#1} - 6 - $length))
		fi
	else
		tput cup $LINES $(($PANE_WIDTH - ${#1} - 6))
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1 $COLOR1--$COLOR1 "
		RIGHT_BANNER_WIDTH=$((${#1}+6))
	fi

	if [ "$warning" == true ]; then
		echo -ne "$COLOR1${COLOR2}y${COLOR1}: ${WHITE_BLACK}yes $COLOR1${COLOR2}n${COLOR1}: ${WHITE_BLACK}no$RIGHTPADDING"
	fi

	if [ "$4" != true ]; then
		if [ "$3" != true ]; then
			tput rc
		fi
	fi
}

set_loop() {
	if [ "$LOOP" == false ] || [ "$1" == true ]; then
		espeak_say_natural "loop song"
		LOOP=true
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
		draw_banner "LOOP SONG"
	else
		espeak_say_natural "loop off"
		LOOP=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	fi
	#stty -echo
	sleep 0.25
	#stty echo
	draw_pitch
	draw_position
}

set_loop_artist() {
	if [ "$LOOP_ARTIST" == false ] || [ "$1" == true ]; then
		LOOP=false
		LOOP_ARTIST=true
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		LOOP_ARTIST_NAME="`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1 | tr '[:upper:]' '[:lower:]'`"
		LOOP_ARTIST_NAME2="`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		espeak_say_natural "loop artist"
		draw_banner "LOOP ARTIST"
	#	ORIG_QBUF="$QBUFFER"

	#	QBUFFER="`echo -ne \"$ORIG_QBUF\" | grep \"$LOOP_ARTIST_NAME2 - \" | grep \"mp3$\"`"
	#	if [ "$QBUFFER" != "" ]; then
	#		QBUFFER="$QBUFFER\n`echo -ne \"$ORIG_QBUF\" | grep \"$LOOP_ARTIST_NAME2 - \" | grep \"flac$\"`"
	#	else
	#		QBUFFER="`echo -ne \"$ORIG_QBUF\" | grep \"$LOOP_ARTIST_NAME2 - \" | grep \"flac$\"`"
	#	fi
	#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
	#	POSITION="`echo -ne \"$QBUFFER\" | grep -n "$TITLE" | cut -d':' -f1`"
	#	reset_buffer
	#	redraw_buffer
	else
		espeak_say_natural "loop off"
		LOOP=false
		LOOP_ARTIST=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	#	QBUFFER="$ORIG_QBUF"
	#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
	#	POSITION="`echo -ne \"$QBUFFER\" | grep -n "$TITLE" | cut -d':' -f1`"
	#	reset_buffer
	#	redraw_buffer
	fi
	#stty -echo
	sleep 0.25
	#stty echo
	draw_pitch
	draw_position
}

set_random() {
	if [ "$TRACK_RANDOM" == false ] || [ "$1" == true ]; then
		espeak_say_natural "random mode"
		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=true
		ONLY_LOCKED=false
		draw_banner "RANDOM MODE"
	#	QBUFFER="$ORIG_QBUF"
	#	POSITION="`echo -ne \"$QBUFFER\" | grep -n "$TITLE" | cut -d':' -f1`"
	#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
		reset_buffer
		redraw_buffer
	else
		espeak_say_natural "random mode off"
		TRACK_RANDOM=false
		draw_banner "RANDOM OFF"
	fi
	#stty -echo
	sleep 0.25
	#stty echo
	draw_pitch
	draw_position
}

set_only_locked() {
	if [ "$ONLY_LOCKED" == false ] || [ "$1" == true ]; then
		if [ "$3" != true ]; then
			espeak_say_natural "only locked"
		fi

		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		ONLY_LOCKED=true
		#QBUFFER="`echo -ne \"$QBUFFER\" | sed -n \"/$TITLE*\.locked$/p\"`"
		#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/.locked$//g\"`"
		#QBUFFER="`echo \"$QBUFFER\" | sed -n \"/\*\.locked\$/p\"`"
		if [ "$4" != true ]; then
			#orig_QBUFFER="$QBUFFER"
			#orig_TOTAL_QUEUE="$TOTAL_QUEUE"
			if [ "$pick" == "" ]; then
				#old_queue_array=${queue_array[@]}
				old_queue_array=("${queue_array[@]}")
				unset queue_array
				IFS=$'\n'
				index=0
				for i in `find "$MUSICDIR" -iname "*.locked" | shuf`; do
					queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
					index=$(($index+1))
				done
				unset IFS
				#QBUFFER="`find \"$MUSICDIR\" -iname \"*.locked\" | shuf`"
				#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
				if [ "$index" == "0" ]; then
					#queue_array=${old_queue_array[@]}
					queue_array=("${old_queue_array[@]}")
					# FIXME
					return
				else
					#unset old_queue_array
					#TOTAL_QUEUE=$(($index-1))
					TOTAL_QUEUE=$index
				fi
					
			else
				#QBUFFER="`cat \"$ALETHEIA/playlists/$pick\"`"
				#new_QBUF=""
				unset queue_array
				c=$'\n'
				IFS=$'\n'
				index=0
				#for i in $QBUFFER; do
				for i in `printf '%s\n' "${queue_array[@]}"`; do
					#queue_array[$index]="$i"
					if [ -e "$i.locked" ]; then
						#if [ "$new_QBUF" == "" ]; then
						#	new_QBUF="$i"
						#else
						#	new_QBUF="$new_QBUF\n$i"
						#fi
						new_queue_array[$index]="$i"
						index=$(($index+1))
					fi
				done
				unset IFS
				queue_array=("${new_queue_array[@]}")
				#TOTAL_QUEUE="`echo -e \"$new_QBUF\" | wc -l`"
				TOTAL_QUEUE=$(($index-1))
				#QBUFFER="$new_QBUF"
			fi
			if [ -e "$FILENAME.locked" ]; then
				#QBUFFER="$FILENAME\n`echo \"$QBUFFER\" | sed \"s/\.locked\$//g\" | grep -v \"$FILENAME\"`"
				#QBUFFER="$FILENAME\n`echo -ne \"$QBUFFER\" | grep -v \"$FILENAME\"`"
				#o_list="$FILENAME$c"
				new_list=""
				minusone=0
				IFS=$'\n'
				o_list="$FILENAME$IFS"
				for i in `seq 1 $TOTAL_QUEUE`; do
					#$(printf "%s\n" "${queue_array[$i]}" | shuf)"
					if [ "$i" != "$POSITION" ]; then
						new_list="$new_list${queue_array[$(($i-1-$minusone))]}$IFS"
					else
						minusone=1
					fi
				done
				new_list="`echo -ne \"$new_list\" | grep -v \"$FILENAME\" | shuf`"
				o_list="$o_list$new_list"
				index=0
				for i in `echo -ne "$o_list"`; do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				#tmp=$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME" | head -1 | cut -d':' -f1)
				unset IFS
				#POSITION="$tmp"
				POSITION=1
				#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
				#if [ "$tmp" != "" ]; then
				#	#tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
				#	POSITION="$tmp"
				#else
					POSITION=1
				#fi
				ret=false
				flagp=true
			else
				#QBUFFER="`echo \"$QBUFFER\" | sed \"s/\.locked\$//g\"`"
				JUMP=1
				ret=true
				flagp=false
			fi

			#TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
			if [ "$flagp" == false ]; then
				POSITION=0
				#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
				tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1 | head -1`"
				if [ "$tmp" != "" ]; then
					POSITION="$tmp"
				fi
			fi
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			draw_banner "ONLY LOCKED"
			reset_buffer
			redraw_buffer
			if [ "$ret" == true ]; then
				return 200
			fi
		else
			return 200
		fi
	elif [ "$2" == true ]; then
		if [ "$selected_locks" == true ]; then
			break
		fi
		espeak_say_natural "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		#	QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
		#	SHUFFLED=true
		#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
		#else
			queue_array=("${old_queue_array[@]}")
			TOTAL_QUEUE=${#queue_array[@]}
			#QBUFFER="$orig_QBUFFER"
			#TOTAL_QUEUE="$orig_TOTAL_QUEUE"
		#fi
		#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		#if [ "$tmp" == "" ]; then
		#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
		#fi
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	elif [ "$3" == true ]; then
		if [ "$selected_locks" == true ]; then
			break
		fi
		#espeak_say_natural "only locked off"
		ONLY_LOCKED=false
		#draw_banner "RESET"
		#if [ "$selected_locks" == true ]; then
		#	selected_locks=false
		#	QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
		#	SHUFFLED=true
		#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
		#else
			queue_array=("${old_queue_array[@]}")
			TOTAL_QUEUE=${#queue_array[@]}
			#QBUFFER="$orig_QBUFFER"
			#TOTAL_QUEUE="$orig_TOTAL_QUEUE"
		#fi
		#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		#if [ "$tmp" == "" ]; then
		#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
		#fi
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	else
		if [ "$selected_locks" == true ]; then
			break
		fi
		espeak_say_natural "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		#if [ "$selected_locks" == true ]; then
		#	selected_locks=false
		#	QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
		#	SHUFFLED=true
		#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
		#else
			queue_array=("${old_queue_array[@]}")
			TOTAL_QUEUE=${#queue_array[@]}
			#QBUFFER="$orig_QBUFFER"
			#TOTAL_QUEUE="$orig_TOTAL_QUEUE"
		#fi
		#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		#if [ "$tmp" == "" ]; then
		#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
		#fi
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	fi
	#stty -echo
	sleep 0.25
	#stty echo
	draw_pitch
	draw_position
}

track_toggle() {
	#if [ "$LOOP" == false ] && [ "$LOOP_ARTIST" == false ] && [ "$TRACK_RANDOM" == false ] && [ "$ONLY_LOCKED" == false ]; then
	if [ "$LOOP" == false ] && [ "$LOOP_ARTIST" == false ]; then
		set_loop true
	#elif [ "$LOOP_ARTIST" == false ] && [ "$TRACK_RANDOM" == false ] && [ "$ONLY_LOCKED" == false ]; then
	elif [ "$LOOP_ARTIST" == false ]; then
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		set_loop_artist true
	#elif [ "$TRACK_RANDOM" == false ] && [ "$ONLY_LOCKED" == false ]; then
	#	set_random true
	#elif [ "$ONLY_LOCKED" == false ]; then
	#	set_only_locked true false true true
	#	if [ "$?" == 200 ]; then
	#		espeak_say_natural "quit song?"
	#		draw_banner "QUIT SONG" true
	#		#orig_QBUFFER="$QBUFFER"
	#		QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
	#		POSITION=1
	#		reset_buffer
	#		redraw_buffer
	#		read -rsn1 c
	#		if [ "$c" == "y" ] || [ "$c" == "Y" ]; then
	#			set_only_locked false false true
	#			POSITION=1
	#			SHUFFLED=true
	#			TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
	#			reset_buffer
	#			redraw_screen
	#			return 200
	#		else
	#			QBUFFER="$orig_QBUFFER"
	#			set_only_locked false true
	#			QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
	#			POSITION="`echo -ne \"$QBUFFER\" | grep -n "$FILENAME" | cut -d':' -f1`"
	#			SHUFFLED=true
	#			TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
	#			reset_buffer
	#			redraw_screen
	#			return
	#		fi
	#	fi
	#elif [ "$ONLY_LOCKED" == true ]; then
	else
		espeak_say_natural "reset"
		LOOP=false
		LOOP_ARTIST=false
	#	TRACK_RANDOM=false
	#	ONLY_LOCKED=false
		draw_banner "RESET"
	#	QBUFFER="$ORIG_QBUF"
	#	POSITION="`echo -ne \"$QBUFFER\" | grep -n "$TITLE" | cut -d':' -f1`"
	#	reset_buffer
	#	redraw_buffer
		#stty -echo
		#sleep 0.25
		read -n1 -t 0.25 c
		if [ "$c" == "e" ]; then
			track_toggle
			if [ "$?" == "200" ]; then
				return 200
			fi
			return
		fi
		#stty echo
		draw_pitch
		draw_position
	fi
}

about() {
	draw_banner "ABOUT"
	empty_pane
	lines_divided=$(($LINES/2))
	cols_divided=$(($COLS/2))
	tput cup $lines_divided $(( ($COLS/2) - 7))
	echo -ne "${WHITE}GPL ${BLUE}3 ${WHITE}2021${GREEN}-${WHITE}2023"

	if [ "$VOICE_ENABLED" == true ]; then
		#if [ "$PAUSE" == false ]; then
		#	echo -e "pause" >"$ALETHEIA/pipe$$" &
		#fi

		#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
		killall espeak-ng >/dev/null 2>/dev/null
		#killall play >/dev/null 2>/dev/null
		#killall gtts-cli >/dev/null 2>/dev/null
		#espeak-ng -s$VOICE_SPEED -v$VOICE_GENDER -a$VOICE_VOLUME -p$VOICE_PITCH --punct "Aletheia version $VERSION" &
		espeak_say_natural "Aletheia, version $VERSION" &
		#echo -ne "Aletheia version $VERSION" | sed -e "s/\./ point /g" | gtts-cli - | play -t mp3 - >/dev/null 2>/dev/null &
	fi
	tput cup $(($lines_divided+2)) $(( $cols_divided - 2))
	echo -ne "`echo -ne \"$WHITE$VERSION\" | cut -d'.' -f1`"
	echo -ne "$BLUE.$WHITE"
	echo -ne "`echo -ne \"$VERSION\" | cut -d'.' -f2`"
	echo -ne "$BLUE.$WHITE"
	echo -ne "`echo -ne \"$VERSION\" | cut -d'.' -f3`"
	tput cup $(($lines_divided-2)) $(( $cols_divided - 4))
	x=1
	flaggy=false
	while [ "$x" -le "7" ]; do
		case $x in
		'1')
			echo -ne " ${WHITE}ἀ"
			;;
		'7')
			#tput cuf 5
			echo -ne "$WHITEα$NOCOLOR"
			;;
		'2')
			#tput cub 6
			echo -ne "${BLUE}λ"
			;;
		'6')
			#tput cuf 3
			echo -ne "$BLUEι"
			;;
		'3')
			#tput cub 4
			echo -ne "$WHITEή"
			;;
		'5')
			#tput cuf 1
			echo -ne "$WHITEε"
			;;
		'4')
			#tput cub 2
			echo -ne "$BLUEθ"
			;;
		esac
		
		x=$(($x+1))
		random_number=$(shuf -i 0-3500 -n 1)

		random_number=$(echo "scale=10; $random_number / 3500 * 0.35 + 0.25" | bc)
		read -rsn1 -t $random_number c
		if [ "$c" != "" ]; then
			#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			#killall play >/dev/null 2>/dev/null
			#killall gtts-cli >/dev/null 2>/dev/null
			flaggy=true
			break
		fi
	done

	if [ "$flaggy" == false ]; then
		read -n1 throwaway
	fi

	espeak_say_natural "closed"
}

set_scale_speed() {
	local reset=false
	tmp=""
	if [ "$SCALE_SPEED" != "$DEFAULT_SCALE_SPEED" ]; then
		#set_scale_speed reset
		reset=true
		draw_banner "RESET"
		stty -echo
		sleep 0.25
		stty echo
		draw_pitch
		draw_position		
		tmp="$DEFAULT_SCALE_SPEED"
	else
		espeak_say_natural "scale speed"
		draw_banner "SPEED"
	fi

	if [ "$tmp" == "" ]; then
		tmp="`read_line`"
	fi

	if [ "`isnum \"$tmp\"`" != "0" ]; then
		SCALE_SPEED=$tmp
	else
		draw_pitch
		espeak_say_natural "closed"
		return
	fi

	if [ "$reset" == true ]; then
		espeak_say_natural "speed reset"
	#else
	#	espeak_say_natural "$SCALE_SPEED"
	fi
	draw_pitch
}

less_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
	fi
	while [ "$EDO" -gt "$LOCKED_EDO" ]; do
		INTERVAL="$(($INTERVAL/2))"
		EDO="$(($EDO/2))"
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		draw_pitch
		sleep 0.01
	done
	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
	draw_pitch
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	espeak_say_natural "less precise"
}

more_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		MUTE=false
		echo "mute" >$ALETHEIA/pipe$$ &
	fi
	while [ "$EDO" -lt "$EDO_LIMIT" ]; do
		if [ "$INTERVAL" -lt "$EDO_LIMIT" ]; then
			INTERVAL="$(($INTERVAL*2))"
			EDO="$(($EDO*2))"
			echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
			draw_pitch
			sleep 0.01
		else
			break
		fi
	done
	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
	draw_pitch
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	espeak_say_natural "precise"
}

zero_interval_jump() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		draw_pitch
	fi
	if [ "$INTERVAL" != "0" ]; then
		SAVED_INTERVAL="$INTERVAL"
		SAVED_EDO="$EDO"
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$SAVED_EDO"
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		#espeak_say_natural " $INTERVAL of $EDO"
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			INTERVAL="$SAVED_INTERVAL"
			EDO="$SAVED_EDO"
			echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
			#espeak_say_natural " $INTERVAL of $EDO"
		else
			#continue
			return
		fi
	fi
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	draw_pitch
}

draw_loop() {
	tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-${#PADDING}))
	echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space$RIGHTPADDING"
}

repeat() {
	echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
	echo "get_time_length" >"$ALETHEIA/pipe$$" &
	sleep 0.2
	TOTAL_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
	if [ "`isnum \"$TOTAL_TIME\"`" == "0" ] || [ "`echo -e \"$TOTAL_TIME < 0.1\" | bc`" == "1" ]; then
		TOTAL_TIME=0.1
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	if [ "$REPEAT_ONLY" == false ]; then
		espeak_say_natural "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
	fi
	if [ "$END_TIME" == "" ]; then
		if [ "$REPEATS" != "" ]; then
			repeats=$REPEATS
			CURRENT_TIME="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f1`"
			if [ "`isnum \"$CURRENT_TIME\"`" == "0" ] || [ "`echo -e \"$CURRENT_TIME < 0\" | bc`" == "1" ]; then
				espeak_say_natural "loop file error"
				draw_banner "ERROR"
				sleep 0.25
				draw_pitch
				draw_position
				return 200
			fi
			orig_CURRENT_TIME=$CURRENT_TIME
			if [ "$CURRENT_TIME" == "" ]; then
				CURRENT_TIME=0.0
			fi
			END_TIME="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f2`"
			if [ "`isnum \"$END_TIME\"`" == "0" ] || [ "`echo -e \"$END_TIME < 0\" | bc`" == "1" ]; then
				espeak_say_natural "loop file error"
				draw_banner "ERROR"
				sleep 0.25
				draw_pitch
				draw_position
				return 200
			fi
			orig_END_TIME=$END_TIME
			if [ "$END_TIME" == "" ]; then
				END_TIME=5.0
			fi
			space="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f3 | cut -d'.' -f1`"
			if [ "`isnum \"$space\"`" != "1" ]; then
				espeak_say_natural "loop file error"
				draw_banner "ERROR"
				sleep 0.25
				draw_pitch
				draw_position
				return 200
			fi
			orig_space=$space
			if [ "$space" == "" ]; then
				space=0
			fi
			##
			#ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
			#filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
			#if [ ! -e "$filename_without_ext.repeat.$ext" ]; then
			#	ffmpeg -i "$FILENAME" -ss $CURRENT_TIME -t $(calc "$END_TIME-$CURRENT_TIME") -c copy "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
			#	cp "$FILENAME.locked" "$filename_without_ext.repeat.$ext.locked" >/dev/null 2>/dev/null
			#fi

			#add_downloaded true	
			##
			
			#return 200
				#sox "$ALETHEIA/_clip.mp3" "$ALETHEIA/clips/$TITLE.mp3" speed `calc "2^($INTERVAL/$EDO)"`

				#new="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
				#sox "$ALETHEIA/clips/$TITLE.mp3" "$new (LOOP $repeat_times).mp3" pad 0 `calc "$space/12" | sed -e "s/\t//g" | cut -d'~' -f2` repeat $repeat_times >"$ALETHEIA/error_log" 2>"$ALETHEIA/error_log"

		else
			draw_banner "NONE"
			espeak_say_natural "no loops"
			sleep 0.25
			draw_pitch
			draw_position
			if [ "$LOOP" == false ]; then
				echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			fi
			return 200
		fi
	fi
	if [ "$END_TIME" != "" ]; then
		etime=$END_TIME
		date_time=`/usr/bin/time -p date +%s.%N 2>&1 | head -1`
		date_time=$(calc "$date_time/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		timespent_timed=`/usr/bin/time -p calc "10 + (1687968170.908741168-1687968192.276557242) * (0.35) + ($date_time * 0.35)" 2>&1 | head -1`
		timespent_timed=$(calc "$timespent_timed/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		s="`calc \"1/(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		orig_old_s=$old_s
		time="`calc \"($END_TIME-$CURRENT_TIME)*($s)\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		#time="`echo -e "($etime-$CURRENT_TIME)*($s)" | bc`"
		throwaway=""
		CURRENT_TIME="`printf '%.2f' $CURRENT_TIME`"
		etime="`printf '%.2f' $etime`"
		RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
		if [ "$REPEAT_TOTAL" == "0" ]; then
			draw_banner "LOOP 0/$REPEAT_TOTAL"
		else
			draw_banner "LOOP 1/$REPEAT_TOTAL" false false true
		fi
		#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-${#PADDING}))
		#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
		draw_loop
		scale=false
		until [ "$throwaway" == "q" ] || [ "$throwaway" == "" ]; do
			if [ "$throwaway" == "" ]; then
				timespent=0
				x=0
				if [ "$throwaway" == "" ]; then
					if [ "$space" -gt "0" ]; then
						echo -e "pause" >"$ALETHEIA/pipe$$" &
						read -rsn1 -t `calc "$space/12" | sed -e "s/\t//g" | cut -d'~' -f2` throwaway
						echo -e "pause" >"$ALETHEIA/pipe$$" &
					fi
				fi
				if [ "$throwaway" != "" ]; then
					continue
				fi
				#s="`calc \"1/(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				#s="`echo -e "1/(2^($INTERVAL/$EDO))" | bc`"
				#time="`echo -e "($etime-$CURRENT_TIME)*($s)" | bc`"
				#time="`calc \"($etime-$CURRENT_TIME)*($s)\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				#s="`calc \"1/(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				new_flaggy=false
				echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
				time_before=`date +%s.%N`
				if [ "$scale" == true ]; then
					#if [ "$scale_down" == true ]; then
					#	INTERVAL=$(($INTERVAL-1))
					#elif [ "$scale_down" == false ]; then
					#	INTERVAL=$(($INTERVAL+1))
					#fi
					#echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$$! &

					#LOCKED=false
					#draw_pitch
					#orig_num="`echo \"$time/$SCALE_SPEED\" | bc`"
					#if [ "$num" != "0" ]; then
					#	orig_num="`echo \"$time/$num\" | bc`"
					#else
					#	orig_num="$time"
					#	if [ "$scale_down" == true ]; then
					#		INTERVAL=$(($INTERVAL-1))
					num="`echo -ne \"$time\" | cut -d'.' -f1`"
					#	elif [ "$scale_down" == false ]; then
					#		INTERVAL=$(($INTERVAL+1))
					#	fi
					#	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					#	draw_pitch
					#fi

					#if [ "$scale_down" == true ]; then
					#	INTERVAL=$(($INTERVAL+1))
					#elif [ "$scale_down" == false ]; then
					#	INTERVAL=$(($INTERVAL-1))
					#fi
					#read -n1 -t $orig_num readme 
					#if [ "$readme" != "" ]; then
					#	if [ "$readme" == "q" ]; then
					#		scale=false
					#		break
					#	fi
					#fi
					skip=false
					while [ "$num" -gt "0" ]; do
					#while [ "`echo \"$num > 0\" | bc`" == "1" ]; do
						old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
						if [ "$skip" == false ]; then
							if [ "$scale_down" == true ]; then
								INTERVAL=$(($INTERVAL-1))
							elif [ "$scale_down" == false ]; then
								INTERVAL=$(($INTERVAL+1))
							fi
						fi
						old_time_before=$time_before
						time_before=`date +%s.%N`
						if [ "$skip" == false ]; then
							echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						else
							skip=false
						fi
						time_after=`date +%s.%N`
						draw_pitch
						orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
						###
						time_x=`date +%s.%N`
						#flagged=false
						#if [ "$switch" == true ]; then
						#	switch=false
							#timespent="`calc \"$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*4)*$orig_old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
							if [ "$new_flaggy" == true ]; then
								new_text="($timespent_timed)"
							else
								new_text="0"
							fi
							timespent="`calc \"$timespent +($time_before-$old_time_before)*($old_s)+($time_x-$time_after)*($orig_old_s)+($date_time*2)*$old_s+($date_time*2)*$orig_old_s+$timespent_timed\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
						#else
						#	timespent="`calc \"$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($old_s)+($date_time*4)*$old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
						#fi
						# FIXME
						#s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
						s=$orig_old_s
						old_s=$s
						s="`calc \"1/$s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"

						time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						numberz=`calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						if [ "`echo \"$numberz <= 0\" | bc`" == "1" ]; then
							numberz=0
						fi
						if [ "`echo -e \"$numberz >= 0\" | bc`" == "1" ]; then
							if [ "$numberz" == "0" ]; then
								throwaway=""
								skip=true
							else
								if [ "`echo \"($numberz/$num) < 1\" | bc`" == "1" ]; then
									skip=true
								fi
								time_y=`date +%s.%N`
								#time_before=$time_y
								timespent="`calc \"$timespent + (($time_y-$time_x) * ($old_s)) + ($date_time * $old_s)\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
								new_flaggy=true
								if [ "$WEB_CLIENT" == "0" ]; then
									read -rsn1 -t "`echo \"$numberz/$num\" | bc`" readme
								else
									read -rsn1 -t "`echo \"$numberz/$num\" | bc`" readme <$ALETHEIA/input_fifo
								fi
								time_after=`date +%s.%N`
							fi
						fi
						###
						#read -n1 -t $orig_num readme 
						if [ "$readme" != "" ]; then
							#secondary_scale_func "$readme"
							if [ "$readme" == "q" ] || [ "$readme" == "u" ] || [ "$readme" == "" ]; then
								scale=false
								#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
								espeak_say_natural "scale closed"
								draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
								#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
								#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
								#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
								break
							elif [ "$readme" == "c" ]; then
								if [ "$scale_down" == true ]; then
									scale_down=false
								else
									scale_down=true
								fi
								skip=true
							elif [ "$readme" == "m" ]; then
								half_precise
								skip=true
							elif [ "$readme" == "t" ]; then
								set_default_edo
								skip=true
							elif [ "$readme" == "o" ]; then
								double_precise
								skip=true
							elif [ "$readme" == "8" ]; then
								master_volume_change "-3% -3%"
								skip=true
							elif [ "$readme" == "9" ]; then
								master_volume_change "+3% +3%"
								skip=true
							elif [ "$readme" == "*" ]; then
								master_volume_change "-1% -1%"
								skip=true
							elif [ "$readme" == "(" ]; then
								master_volume_change "+1% +1%"
								skip=true
							fi
						fi
						num=$(($num-1))
					done
				else
					if [ "`echo \"$time <= 0\" | bc`" == "1" ]; then
						time=0.01
						etime="`echo \"$CURRENT_TIME+0.01\" | bc`"
					fi
				#while [ "$num" -ge "0" ]; do
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t $time throwaway
						#read -n1 -t "`echo \"$time/$orig_num\" | bc`" throwaway
					else
						read -rsn1 -t $time throwaway <$ALETHEIA/input_fifo
						#read -n1 -t "`echo \"$time/$orig_num\" | bc`" throwaway <$ALETHEIA/input_fifo
					fi
				#	num=$(($num-1))
				#done
				fi
				time_after=`date +%s.%N`
			fi
			if [ "$throwaway" == "" ]; then
				continue
			fi
			if [ "$throwaway" == "l" ] || [ "$throwaway" == "h" ] || [ "$throwaway" == "L" ] || [ "$throwaway" == "H" ]; then
				case $throwaway in
				'l')
					if [ "`echo -e \"($etime+0.05)<$TOTAL_TIME\" | bc`" == "1" ]; then
						etime=`calc "$etime+0.05" | sed -e "s/\t//g"`
					else
						etime=$TOTAL_TIME
					fi
					;;
				'h')
					if [ "`echo -e \"(($etime-0.05) > $CURRENT_TIME)\" | bc`" == "1" ]; then
						etime=`calc "$etime-0.05" | sed -e "s/\t//g"`
					fi
					;;
				'L')
					if [ "`echo -e \"($etime < $TOTAL_TIME-0.05)\" | bc`" == "1" ]; then
						etime=`calc "$etime+0.01" | sed -e "s/\t//g"`
					fi
					;;
				'H')
					if [ "`echo -e \"($etime > $CURRENT_TIME+0.05)\" | bc`" == "1" ]; then
						etime=`calc "$etime-0.01" | sed -e "s/\t//g"`
					fi
					;;
				esac

				time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`

				#espeak_say_natural " $etime"
				CURRENT_TIME="`printf '%.2f' $CURRENT_TIME`"
				etime="`printf '%.2f' $etime`"
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop

				if [ "`echo -e \"$(calc \"$etime-$CURRENT_TIME\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t $time throwaway
					else
						read -rsn1 -t $time throwaway <$ALETHEIA/input_fifo
					fi
				else
					echo "seek `calc \"$etime-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway
					else
						read -rsn1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway <$ALETHEIA/input_fifo
						#sleep `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`
						#throwaway=""
					fi
				fi
				flagged=false
			elif [ "$throwaway" == "s" ] || [ "$throwaway" == "f" ] || [ "$throwaway" == "S" ] || [ "$throwaway" == "F" ]; then
				case $throwaway in
				's')
					if [ "`echo -e \"(($CURRENT_TIME-0.05) >= 0.0)\" | bc`" == "1" ]; then
						CURRENT_TIME=`calc "$CURRENT_TIME-0.05" | sed -e "s/\t//g"`
					fi
					;;
				'f')
					if [ "`echo -e \"(($CURRENT_TIME+0.05) < $etime)\" | bc`" == "1" ]; then
						CURRENT_TIME=`calc "$CURRENT_TIME+0.05" | sed -e "s/\t//g"`
					fi
					;;
				'S')
					if [ "`echo -e \"(($CURRENT_TIME-0.01) >= 0.0)\" | bc`" == "1" ]; then
						CURRENT_TIME=`calc "$CURRENT_TIME-0.01" | sed -e "s/\t//g"`
					fi
					;;
				'F')
					if [ "`echo -e \"(($CURRENT_TIME+0.01) <= ($etime-0.05))\" | bc`" == "1" ]; then
						CURRENT_TIME=`calc "$CURRENT_TIME+0.01" | sed -e "s/\t//g"`
					fi
					;;
				esac
				truth="`echo \"$CURRENT_TIME < 0.0\" | bc`"
				if [ "$truth" == "1" ]; then
					CURRENT_TIME="0.0"
				fi
				time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				#espeak_say_natural "$CURRENT_TIME"
				CURRENT_TIME="`printf '%.2f' $CURRENT_TIME`"
				etime="`printf '%.2f' $etime`"
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "d" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				toggle_voice
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "" ] || [ "$throwaway" == "\\" ]; then
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "u" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				espeak_say_natural "scale"
				draw_banner "SCALE"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				if [ "$scale" == true ]; then
					scale=false
					if [ "$updown" == "u" ] || [ "$updown" == "q" ]; then
						#espeak_say_natural " $INTERVAL of $EDO"
						espeak_say_natural "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					#else
					#	draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
					#	throwaway=""
					#	flagged=false
					fi
				else
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 updown
					else
						read -rsn1 updown <$ALETHEIA/input_fifo
					fi
					if [ "$updown" == "j" ]; then
						scale_down=true
						scale=true
						#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						throwaway=""
						#flagged=false
						#draw_banner "WAIT"
						espeak_say_natural "scaling"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$updown" == "k" ]; then
						scale_down=false
						scale=true
						throwaway=""
						#flagged=false
						espeak_say_natural "scaling"
						#draw_banner "WAIT"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$updown" == "u" ] || [ "$updown" == "q" ] || [ "$updown" == "" ]; then
						espeak_say_natural "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					#else
					#	draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
					#	throwaway=""
					#	flagged=false
					fi
				fi
				#flagged=true
			elif [ "$throwaway" == "q" ]; then
				draw_pitch
				draw_position
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$throwaway" == "a" ]; then
				toggle_pause
				set_equalizer
				#toggle_pause
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$throwaway" == "T" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				set_only_display_song
				redraw_buffer
				flagged=true
			elif [ "$throwaway" == "Z" ]; then
				#toggle_pause
				#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				#RIGHT_BANNER_WIDTH=$((12+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				#draw_banner "EXPORT" false false true
				#espeak_say_natural "export loop"
				#tput rc
				##
				#read xp
				#read -n1 xp
				#if [ "$xp" == "" ] || [ "$xp" == "q" ]; then
				#	stty -echo
				#	#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				#	RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				#	draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#	#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#	#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				#	draw_loop
				#	espeak_say_natural "export closed"
				#else
				#	stty echo
				#	xp="`read_line \"$xp\"`"
				#	stty -echo
				#	if [ "`isnum \"$xp\"`" == "0" ]; then
				#		stty -echo
				#		#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				#		RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				#		draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#		#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#		#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				#		draw_loop
				#		espeak_say_natural "Invalid number. Export Closed."
				#	else
				#		#clear
				#		#tput cup $((`tput lines`/2)) $(((`tput cols`/2)-5))
				#		#echo -ne "$NOCOLOR${CYAN}-- ${BLUE}WAIT ${CYAN}--"
				#		#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
						draw_banner "WAIT" false false true
						espeak_say_natural "wait"
				#		if [ "`isnum $xp`" != "0" ]; then
				#			repeat_times=$xp
				##		else
				#			repeat_times=0
				#		fi
						ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
						filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
						rm -f "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
						rm -f "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
						ffmpeg -i "$FILENAME" -ss $CURRENT_TIME -t $(calc "$etime-$CURRENT_TIME+0.265+0.00000") -c copy "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
						len="`ffprobe -i \"$filename_without_ext.repeat0.$ext\" -show_entries format=duration -v quiet -of csv='p=0'`"
						#sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat.$ext" trim 0 `echo -e \"$len-0.2\" | bc` >/dev/null 2>/dev/null
						sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat.$ext" trim 0 -0.180 >/dev/null 2>/dev/null
						rm -f "$filename_without_ext.repeat0.$ext"
						cp "$FILENAME.locked" "$filename_without_ext.repeat.$ext.locked" >/dev/null 2>/dev/null
						#mkdir -p "$ALETHEIA/clips" >/dev/null 2>/dev/null
						#rm -f "$ALETHEIA/clips/_clip.mp3" >/dev/null 2>/dev/null
						#rm -f "$ALETHEIA/clips/"$TITLE".mp3" >/dev/null 2>/dev/null
						#ffmpeg -i "$FILENAME" -ss $CURRENT_TIME -t $(calc "$etime-$CURRENT_TIME+0.1") -c copy "$ALETHEIA/clips/_clip.mp3" >"$ALETHEIA/error_log" 2>"$ALETHEIA/error_log"
						#sox "$ALETHEIA/clips/_clip.mp3" "$ALETHEIA/clips/$TITLE.mp3" speed `calc "2^($INTERVAL/$EDO)"` >"$ALETHEIA/error_log" 2>"$ALETHEIA/error_log"

						#new="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
						#sox "$ALETHEIA/clips/$TITLE.mp3" "$new (LOOP $repeat_times).mp3" pad 0 `calc "$space/12" | sed -e "s/\t//g" | cut -d'~' -f2` repeat $repeat_times >"$ALETHEIA/error_log" 2>"$ALETHEIA/error_log"
						#rm -f "$ALETHEIA/clips/$TITLE.mp3" >/dev/null 2>/dev/null
						RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
						draw_loop
						espeak_say_natural "finished"
				#	fi
				#fi
				#toggle_pause
				old_time_before=$time_before
				time_before=`date +%s.%N`
				flagged=true
			elif [ "$throwaway" == "A" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				sort_queue
				SHUFFLED=false
				flagged=true
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
			elif [ "$throwaway" == "R" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				shuffle_queue
				SHUFFLED=true
				flagged=true
			elif [ "$throwaway" == "I" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				say_status
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "Y" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				zero_interval_jump
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "w" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				reset_to_locked
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$throwaway" == "q" ] || [ "$throwaway" == "" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				draw_pitch
				draw_position
				REPEAT_ONLY=false
				#if [ "$loops_flagged" == true ]; then
				#	if [ "$ONLY_LOCKED" == true ]; then
				#		unset queue_array
				#		IFS=$'\n'
				#		index=0
				#		for i in `find "$MUSICDIR" -iname "*.mp3.locked" -o -iname "*.flac.locked" | shuf`; do
				#			queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
				#			index=$(($index+1))
				#		done
				#		#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3.locked\" -o -iname \"*.flac.locked\" | shuf`"
				#		#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/\.locked$//g\"`"
				#		espeak_say_natural "only locked"
				#	else
				#		unset queue_array
				#		IFS=$'\n'
				#		index=0
				#		for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
				#			queue_array[$index]="$i"
				#			index=$(($index+1))
				#		done
				#		#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
				#		espeak_say_natural "all"
				#	fi
				#	unset IFS
				#	SHUFFLED=true
				#	TOTAL_QUEUE=$index
					#SHUFFLED=true
					#TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
				#	tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
					#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
				#	if [ "$tmp" != "" ]; then
				#		POSITION="$tmp"
				#	else
				#		POSITION=1
				#	fi
				#	reset_buffer
				#	redraw_screen
				#	loops_flagged=false
				#fi
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				return 200
			#	old_time_before=$time_before
			#	time_before=`date +%s.%N`
			#	draw_banner "QUIT" true
			#	if [ "$VOICE_ENABLED" == true ]; then
			#		espeak_say_natural "Quit?"
			#	fi
			#	throwaway_=""
			#	until [ "$throwaway_" == "n" ] || [ "$throwaway_" == "q" ]; do
			#		read -n1 throwaway_
			#		if [ "$throwaway_" == "y" ]; then
			#			echo -ne "$NOCOLOR"
			#			echo "quit 0" >$ALETHEIA/pipe$$ &
			#			kill $MPLAYER_PID >/dev/null 2>/dev/null
			#			clear
			#			stty echo
			#			#return $RETURN_QUIT
			#			exit 0
			#		#elif [ "$throwaway_" == "q" ]; then
			#		#	draw_pitch
			#		#	draw_position
			#		#	flagged=false
			#		#	throwaway=""
			#		#	break
			#		elif [ "$throwaway_" == "n" ] || [ "$throwaway_" == "q" ]; then
			#			#draw_pitch
			#			#draw_position
			#			flagged=true
			#			draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
			#			tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
			#			echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
			#			break
			#		fi
			#	done
			#	#throwaway=""
			#	#flagged=false
			elif [ "$throwaway" == "W" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				add_downloaded "noposition"
				flagged=true
			elif [ "$throwaway" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					espeak_say_natural "playing downloaded"
					JUMP="$DOWNLOAD_POSITION"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					espeak_say_natural "nothing downloaded"
				fi
				flagged=true
			elif [ "$throwaway" == "?" ]; then
				toggle_pause true
				RIGHT_BANNER_WIDTH="$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))"
				draw_banner "HELP" false false true
				#draw_banner "PAUSE" false true
				#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				tput cup $LINES $(($COLS-1-11))
				echo -ne "${GREEN_BLACK}BEG$WHITE_BLACK:${GREEN_BLACK}END$WHITE_BLACK:${GREEN_BLACK}GAP$PADDING"
				loop_help_screen
				killall espeak-ng >/dev/null 2>/dev/null
				toggle_pause true
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "i" ]; then
				toggle_pause true
				#draw_banner "PAUSE" false true
				orig_POSITION_WIDTH=$POSITION_WIDTH
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				main_menu
				#POSITION_WIDTH=$orig_POSITION_WIDTH
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				toggle_pause true
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "M" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
				fi
				orig_orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				INTERVAL="$((-($INTERVAL)))"
				echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				#espeak_say_natural " $INTERVAL $EDO"
				#if [ "$SCALETEMPO" == true ]; then
				#	SCALETEMPO=false
				#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
					#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
				#fi
				draw_pitch
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				switch=true
				flagged=true
			elif [ "$throwaway" == "v" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				toggle_scale_tempo
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$throwaway" == "z" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_wait
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				reset_dimensions
				draw_volume
				draw_equalizer
				reset_buffer
				redraw_buffer
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "," ]; then
				if [ "$space" -gt "0" ]; then
					space=$(($space-1))
				fi
				espeak_say_natural "$space"
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				if [ "`echo -e \"$(calc \"$etime-$CURRENT_TIME\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time throwaway
					else
						read -n1 -t $time throwaway <$ALETHEIA/input_fifo
					fi
				else
					echo "seek `calc \"$etime-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway <$ALETHEIA/input_fifo
					fi
				fi
				flagged=false
			elif [ "$throwaway" == "." ]; then
				space=$(($space+1))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				espeak_say_natural "$space"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				if [ "`echo -e \"$(calc \"$etime-$CURRENT_TIME\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time throwaway
					else
						read -n1 -t $time throwaway <$ALETHEIA/input_fifo
					fi
				else
					echo "seek `calc \"$etime-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway <$ALETHEIA/input_fifo
					fi
				fi
				flagged=false
			elif [ "$throwaway" == "k" ] || [ "$throwaway" == "j" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#POSITION_WIDTH=0
				#RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				orig_orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				if [ "$throwaway" == "k" ]; then
					pitch_up true
				else
					pitch_down true
				fi
				orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				switch=true
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			#elif [ "$throwaway" == "T" ]; then
			#	old_time_before=$time_before
			#	time_before=`date +%s.%N`
			#	set_only_display_song
			#	redraw_buffer
			#	flagged=true
			elif [ "$throwaway" == "2" ] || [ "$throwaway" == "1" ] || [ "$throwaway" == "!" ] || [ "$throwaway" == "@" ] || [ "$throwaway" == "9" ] || [ "$throwaway" == "8" ] || [ "$throwaway" == "*" ] || [ "$throwaway" == "(" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$throwaway" == "2" ]; then
					if [ "$VOLUME" -le "95" ]; then
						VOLUME=$(($VOLUME+5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					espeak_say_natural "$VOLUME"
				elif [ "$throwaway" == "1" ]; then
					if [ "$VOLUME" -ge "5" ]; then
						VOLUME=$(($VOLUME-5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					espeak_say_natural "$VOLUME"
				elif [ "$throwaway" == "@" ]; then
					if [ "$VOLUME" -le "99" ]; then
						VOLUME=$(($VOLUME+1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					espeak_say_natural "$VOLUME"
				elif [ "$throwaway" == "!" ]; then
					if [ "$VOLUME" -ge "1" ]; then
						VOLUME=$(($VOLUME-1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					espeak_say_natural "$VOLUME"
				elif [ "$throwaway" == "8" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >$ALETHEIA/pipe$$ &
						MUTE=false
						draw_pitch
					fi
					master_volume_change "-3% -3%"
				elif [ "$throwaway" == "9" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >$ALETHEIA/pipe$$ &
						MUTE=false
						draw_pitch
					fi
					master_volume_change "+3% +3%"
				elif [ "$throwaway" == "*" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >$ALETHEIA/pipe$$ &
						MUTE=false
						draw_pitch
					fi
					master_volume_change "-1% -1%"
				elif [ "$throwaway" == "(" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >$ALETHEIA/pipe$$ &
						MUTE=false
						draw_pitch
					fi
					master_volume_change "+1% +1%"
				fi
				flagged=true
			elif [ "$throwaway" == "6" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEAT_TOTAL" == "1" ]; then
					flagged=true
					espeak_say_natural "no more loops"
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$(($REPEAT_CURRENT+1))
						if [ "$REPEAT_CURRENT" -gt "$REPEAT_TOTAL" ]; then
							REPEAT_CURRENT=1
						fi
						espeak_say_natural "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						CURRENT_TIME="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f1`"
						orig_CURRENT_TIME=$CURRENT_TIME
						if [ "$CURRENT_TIME" == "" ]; then
							CURRENT_TIME=0.00
						fi
						etime="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f2`"
						orig_END_TIME=$etime
						if [ "$etime" == "" ]; then
							etime=5.00
						fi
						if [ "$CURRENT_TIME" == "$etime" ]; then
							CURRENT_TIME=0.00
							etime=5.00
						fi

						CURRENT_TIME="`printf '%.2f' $CURRENT_TIME`"
						etime="`printf '%.2f' $etime`"
						
						time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						space="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f3`"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
						RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
						#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"

						#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
						#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
						draw_loop
					else
						espeak_say_natural "none"
						CURRENT_TIME=0.00
						etime=5.00
						END_TIME=$etime
						space=0
						#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
						RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "LOOP 0/$REPEAT_TOTAL"
					else
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
					#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
					draw_loop
					#read -n1 -t 0.75 t
					#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
					#draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
					#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
					#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
					#throwaway="$t"
					throwaway=""
					flagged=false
				fi
			elif [ "$throwaway" == "e" ]; then
				#espeak_say_natural "Ends"
				if [ "`echo -e \"$(calc \"$etime-$CURRENT_TIME\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time throwaway
					else
						read -n1 -t $time throwaway <$ALETHEIA/input_fifo
					fi
				else
					echo "seek `calc \"$etime-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`  throwaway
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` throwaway <$ALETHEIA/input_fifo
						#sleep `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2`
						#throwaway=""
					fi
				fi
				flagged=false
			elif [ "$throwaway" == "q" ]; then
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$throwaway" == "5" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.7
				CURRENT_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
				#espeak_say_natural " $CURRENT_TIME"
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "7" ]; then
				#espeak_say_natural "end"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.7
				etime="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
				#espeak_say_natural " $etime"
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "n" ]; then
				RIGHT_BANNER_WIDTH=0
				ps -p $MPLAYER_PID >/dev/null
				if [ "$?" != "1" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
							JUMP="1"
							POSITION="1"
							draw_position
							return $RETURN_JUMP
						else
							return 0
						fi
					fi
				fi
			elif [ "$throwaway" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				#POSITION_WIDTH=$(($RIGHT_BANNER_WIDTH))
				if [ "$REPEAT_ONLY" == false ]; then
					REPEAT_ONLY=true
					#draw_banner "ONLY LOOPS"
					#espeak_say_natural "loops"
					#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
					#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
					draw_loop
					#sleep 0.25
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					#draw_pitch
					#draw_position
				else
					REPEAT_ONLY=false
					#draw_banner "LOOP OFF"
					#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
					#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
					#draw_loop
					if [ "$ONLY_LOCKED" == true ]; then
						unset queue_array
						IFS=$'\n'
						index=0
						for i in `find "$MUSICDIR" -iname "*.mp3.locked" -o -iname "*.flac.locked" | shuf`; do
							queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
							index=$(($index+1))
						done
						unset IFS
						#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3.locked\" -o -iname \"*.flac.locked\" | shuf`"
						#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/\.locked$//g\"`"
						espeak_say_natural "only locked"
					else
						unset queue_array
						IFS=$'\n'
						index=0
						for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
						espeak_say_natural "all"
					fi
					SHUFFLED=true
					#TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
					TOTAL_QUEUE=$index
					#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
					tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
					if [ "$tmp" != "" ]; then
						#tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
						POSITION="$tmp"
					else
						POSITION=1
					fi
					reset_buffer
					redraw_screen
					#sleep 0.25
					RIGHT_BANNER_WIDTH=$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))
					POSITION_WIDTH=$RIGHT_BANNER_WIDTH
					draw_pitch
					draw_position
					if [ "$LOOP" == false ]; then
						echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
					fi
					break
				fi
				flagged=true
			elif [ "$throwaway" == "b" ]; then
				RIGHT_BANNER_WIDTH=0
				ps -p $MPLAYER_PID >/dev/null
				if [ "$?" != "1" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					#if [ "$TRACK_RANDOM" == true ]; then
					#	return $RETURN_TRACK_RANDOM_BACK
					#elif [ "$LOOP_ARTIST" == true ]; then
					#	return $RETURN_LOOP_ARTIST_BACK
					#elif [ "$ONLY_LOCKED" == true ]; then
					#	return $RETURN_ONLY_LOCKED_BACK
					#else
					#	return $RETURN_BACK
					#fi
					if [ "$REPEAT_ONLY" == true ]; then
						return $RETURN_ONLY_LOCKED_BACK
					else
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM_BACK
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST_BACK
						elif [ "$ONLY_LOCKED" == true ]; then
							return $RETURN_ONLY_LOCKED_BACK
						fi	
					fi
				fi
			elif [ "$throwaway" == "y" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				#PAUSE=false
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#new_edo="$DEFAULT_EDO"
				#if [ "$new_edo" -gt "$EDO" ]; then
				#	temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
				#	INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
				#elif [ "$new_edo" -lt "$EDO" ]; then
				#	temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2`"
				#	INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
				#fi
				#EDO="$new_edo"
				#INTERVAL_LIMIT=`calc "$EDO * 2.6"`
				#INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
				#espeak_say_natural " $INTERVAL of $EDO"
				#echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				set_default_edo
				time_x=`date +%s.%N`
				LOCKED=false
				#draw_pitch
				flagged=true
			elif [ "$throwaway" == "p" ]; then
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				toggle_pause
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 throwaway
				else
					read -n1 throwaway <$ALETHEIA/input_fifo
				fi
				old_time_before=$time_before
				time_before=`date +%s.%N`
				toggle_pause
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				time_x=`date +%s.%N`
				flagged=true
			elif [ "$throwaway" == "o" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				double_precise
				#espeak_say_natural " $INTERVAL"
				flagged=true
			elif [ "$throwaway" == "m" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				half_precise
				#espeak_say_natural " $INTERVAL"
				flagged=true
			elif [ "$throwaway" == "x" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					espeak_say_natural "unlocked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}&"
					else
						echo -ne "$BLUE_BLACK "
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/1" >"$FILENAME".locked
						#echo "$INTERVAL/$EDO/$VOLUME/$EQUALIZER/1" >"$FILENAME".locked
					else
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/0" >"$FILENAME".locked
						#echo "$INTERVAL/$EDO/$VOLUME/$EQUALIZER/0" >"$FILENAME".locked
					fi
					LOCKED=true
					espeak_say_natural "locked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}$"
					fi
				fi
				flagged=true
			elif [ "$throwaway" == "%" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEAT_TOTAL" -ge "1" ]; then
					espeak_say_natural "unlocked $REPEAT_CURRENT"
					draw_banner "UNLOCKED $REPEAT_CURRENT"
					#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
					#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
					draw_loop
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t 0.25 t
					else
						read -n1 -t 0.25 t <$ALETHEIA/input_fifo
					fi
					throwaway="$t"
					if [ "$REPEAT_TOTAL" == "1" ]; then
						rm -f "$FILENAME.repeats"
						REPEATS=""
						REPEAT_CURRENT=0
						REPEAT_TOTAL=0
					else
						sed -i "${REPEAT_CURRENT}d" "$FILENAME.repeats"
						REPEATS="`echo -ne \"$REPEATS\" | sed \"${REPEAT_CURRENT}d\"`"
						REPEAT_TOTAL=$(($REPEAT_TOTAL-1))
						REPEAT_CURRENT=$(($REPEAT_CURRENT-1))
					fi

					if [ "$REPEAT_TOTAL" == "0" ]; then
						tput cup $(($LOCKING_POS+2)) $((1))
						if [ "$ONLY_DISPLAY_SONG" == false ]; then
							if [ -e "$FILENAME.locked" ]; then
								echo -ne "${WHITE}$"
							else
								echo -ne "${BLUE} "
							fi
						fi
					fi
					if [ "$REPEATS" != "" ]; then
						if [ "$REPEAT_CURRENT" == "0" ]; then
							REPEAT_CURRENT=1
						fi
						CURRENT_TIME="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f1`"
						etime="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f2`"
						END_TIME=$etime
						time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						space="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f3`"
					fi
				else
					espeak_say_natural "no repeats"
				fi
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				throwaway=""
				flagged=false
			elif [ "$throwaway" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEATS" != "" ]; then
					REPEATS="`echo -ne \"$REPEATS\" | sed -e \"s/$orig_CURRENT_TIME\/$orig_END_TIME\/$orig_space/$CURRENT_TIME\/$etime\/$space/g\"`"
					echo -ne "$REPEATS" >"$FILENAME.repeats"
					espeak_say_natural "saved loop"
				else
					espeak_say_natural "no loops"
				fi
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "SAVED" false false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 -t 0.25 throwaway
				else
					read -n1 -t 0.25 throwaway <$ALETHEIA/input_fifo
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				flagged=true
			elif [ "$throwaway" == "&" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEATS" != "" ]; then
					echo "$CURRENT_TIME/$etime/$space" >>"$FILENAME.repeats"
					REPEATS="$REPEATS\n$CURRENT_TIME/$etime/$space"
					REPEAT_CURRENT=$(($REPEAT_CURRENT+1))
					REPEAT_TOTAL=$(($REPEAT_TOTAL+1))
					espeak_say_natural "locked $REPEAT_TOTAL"
					tput cup $(($LOCKING_POS+2)) $((1))
					if [ "$ONLY_DISPLAY_SONG" == false ]; then
						if [ -e "$FILENAME.locked" ]; then
							echo -ne "${WHITE_BLACK}#"
						else
							echo -ne "${WHITE_BLACK}&"
						fi
					fi
				else
					REPEATS="$CURRENT_TIME/$etime/$space`echo -ne \"\n\"`"
					echo "$CURRENT_TIME/$etime/$space" >"$FILENAME.repeats"
					espeak_say_natural "locked"
					tput cup $(($LOCKING_POS+2)) $((1))
					if [ "$ONLY_DISPLAY_SONG" == false ]; then
						if [ -e "$FILENAME.locked" ]; then
							echo -ne "${WHITE_BLACK}#"
						else
							echo -ne "${WHITE_BLACK}&"
						fi
					fi
					REPEAT_CURRENT=1
					REPEAT_TOTAL=$(($REPEAT_TOTAL+1))
				fi
				#RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+2))
				RIGHT_BANNER_WIDTH=$((${#CURRENT_TIME}+${#etime}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOCKED $REPEAT_TOTAL"
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 -t 0.25 t
				else
					read -n1 -t 0.25 t <$ALETHEIA/input_fifo
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				#tput cup $LINES $(($COLS-$RIGHT_BANNER_WIDTH-1))
				#echo -ne "$BLUE_BLACK$CURRENT_TIME$WHITE_BLACK:$BLUE_BLACK$etime$WHITE_BLACK:$BLUE_BLACK$space"
				draw_loop
				throwaway="$t"
				flagged=true
			else
				old_time_before=$time_before
				time_before=`date +%s.%N`
				master_volume_secondary_func "$throwaway"
				flagged=true
			fi
			if [ "$flagged" == true ]; then
				time_x=`date +%s.%N`
				flagged=false
				if [ "$switch" == true ]; then
					switch=false
					timespent="`calc \"$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*3)*$orig_old_s+($date_time*1)*$orig_orig_old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				else
					timespent="`calc \"$timespent +($time_after-$old_time_before)*($orig_old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*4)*$orig_old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				fi
				#s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				s=$orig_old_s
				old_s=$s
				s="`calc \"1/$s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"

				time=`calc "($etime-$CURRENT_TIME)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				throwaway=""
				numberz=`calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				if [ "`echo \"$numberz <= 0\" | bc`" == "1" ]; then
					numberz=0
				fi
				if [ "`echo -e \"$numberz >= 0\" | bc`" == "1" ]; then
					if [ "$numberz" == "0" ]; then
						throwaway=""
					else
						time_y=`date +%s.%N`
						time_before=$time_y
						timespent="`calc \"$timespent +(($time_y-$time_x)*($old_s))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
						if [ "$WEB_CLIENT" == "0" ]; then
							read -n1 -t "$numberz" throwaway
						else
							read -n1 -t "$numberz" throwaway <$ALETHEIA/input_fifo
						fi
						time_after=`date +%s.%N`
					fi
				fi
			fi

		done
		scale=false
		#draw_pitch
		#draw_position
		REPEAT_ONLY=false
		if [ ! -e "$FILENAME.locked" ]; then
			espeak_say_natural "loop closed"
		fi

		END_TIME="$etime"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		if [ "$LOOP" == false ]; then
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		fi
		return 200
	fi
}

zero_interval() {
	reverse=false
	zero=false
	if [ "$INTERVAL" != "0" ]; then
		draw_banner "ZERO" false true
		zero=true
		SAVED_INTERVAL=$INTERVAL
		SAVED_EDO=$EDO
		espeak_say_natural "scaling"
		old_int="$INTERVAL"
		old_edo="$EDO"
		new_INTERVAL="$DEFAULT_INTERVAL"
		#FIXME
		#new_EDO="$DEFAULT_EDO"
		new_EDO="$EDO"
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			draw_banner "RESET" false true
			espeak_say_natural "scaling"
			old_int="0"
			old_edo="$EDO"
			new_INTERVAL="$SAVED_INTERVAL"
			new_EDO="$SAVED_EDO"
			reverse=true
		else
			old_int="0"
			new_INTERVAL="$DEFAULT_INTERVAL"
			new_EDO="$EDO"
		fi
	fi
	
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
	fi

	if [ "$old_int" -gt "$new_INTERVAL" ]; then
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -lt "$old_int" ]; do
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
			elif [ "$c" == "q" ]; then				
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "quit"
				fi
				read -n1 throwaway
				if [ "$throwaway" == "y" ]; then
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					clear
					stty echo
					return $RETURN_QUIT
				elif [ "$throwaway" == "q" ]; then
					flaggy=true
					#espeak_say_natural " $INTERVAL of $EDO"
					draw_pitch
					break
				#else
				#	#draw_pitch
				#	#draw_position
				#	continue
				fi
			elif [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				#espeak_say_natural " $INTERVAL of $EDO"
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$(($old_int-1))"
				INTERVAL="$(($INTERVAL-1))"
				echo -e "speed_set `calc \"2^($old_int/$old_edo)\"`" >$ALETHEIA/pipe$$ &
			fi
			draw_pitch 1
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	else
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -gt "$old_int" ]; do
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				#espeak_say_natural " $INTERVAL of $EDO"
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$(($old_int+1))"
				INTERVAL="$(($INTERVAL+1))"
				echo -e "speed_set `calc \"2^($old_int/$old_edo)\"`" >$ALETHEIA/pipe$$ &
				draw_pitch 1
			fi
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	fi
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	#espeak_say_natural " $INTERVAL of $EDO"
	LOCKED=false
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

scale_edo() {
	espeak_say_natural "scale e d o"
	draw_banner "SCALE"
	stopat=""
	read -rsn1 edo_change
	if [ "$edo_change" = "J" ]; then
		if [ "$EDO" -le "2" ]; then
		#if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		downwards=true
		time=2.5
		#edo_change="$(($INTERVAL-$EDO))"
		edo_change="$(($EDO-1))"
	elif [ "$edo_change" = "K" ]; then
		if [ "$EDO" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		downwards=false
		time=2.5
		edo_change="$(($EDO+1))"
		#edo_change="$(($INTERVAL+$EDO))"
	elif [ "$edo_change" == "j" ]; then
		#if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
		#	espeak_say_natural "Scale canceled."
		#	RIGHT_BANNER_WIDTH=0
		#	draw_pitch
		#	draw_position
		#	return
		#fi
		espeak_say_natural "scaling"
		downwards=true
		time=$SCALE_SPEED
		edo_change="$(($EDO-1))"
		#edo_change="$(($INTERVAL-$EDO))"
	elif [ "$edo_change" == "k" ]; then
		#if [ "$INTERVAL" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
		#	espeak_say_natural "Scale canceled."
		#	RIGHT_BANNER_WIDTH=0
		#	draw_pitch
		#	draw_position
		#	return
		#fi
		espeak_say_natural "scaling"
		downwards=false
		time=$SCALE_SPEED
		#edo_change="$(($INTERVAL+$EDO))"
		edo_change="$(($EDO+1))"
	elif [ "$edo_change" == "d" ]; then
		toggle_voice
		#draw_banner "SCALE"
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "" ] || [ "$edo_change" == "q" ]; then
		#scale_screen
		espeak_say_natural "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "?" ]; then
		scale_screen
		#RIGHT_BANNER_WIDTH=0
		#draw_pitch
		#draw_banner "SCALE"
		draw_pitch
		draw_position
		return
	elif [ "`isnum \"$edo_change\"`" != "0" ] || [ "$edo_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="`read_line \"$edo_change\"`"
		if [ "$tmp" -lt "$EDO" ]; then
			#if [ "$tmp" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$tmp" -le "0" ]; then
				espeak_say_natural "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			espeak_say_natural "scaling"
			stopat=$tmp
			downwards=true
			time=$SCALE_SPEED
			#edo_change="$(($INTERVAL-$EDO))"
			edo_change="$(($EDO-1))"
		elif [ "$tmp" -gt "$EDO" ]; then
			#if [ "$tmp" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$tmp" -ge "2000000" ]; then
				espeak_say_natural "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			espeak_say_natural "scaling"
			stopat=$tmp
			downwards=false
			time=$SCALE_SPEED
			#edo_change="$(($INTERVAL+$EDO))"
			edo_change="$(($EDO+1))"
		else
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		espeak_say_natural "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$edo_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
		fi
		original_edo="$EDO"
		c=""
		flaggy=false
		orig_edo=$EDO
		orig_interval=$INTERVAL
		while [ "$edo_change" != "$original_edo" ]; do
			if [ "$downwards" == true ]; then # && [ "$edo_change" -lt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t $time c
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				#elif [ "$c" == "c" ] || [ "$downwards" == true ]; then
				elif [ "$c" == "c" ]; then
					downwards=false
					sleep $SCALE_SPEED
					espeak_say_natural "order reversed"
					#original_edo="$EDO"
					#EDO=$(($EDO+1))
					edo_change="$(((2000000)))"
					flaggy=false

					#INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					#INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
					#temp="`calc \"$EDO/$orig_edo\" | cut -d'~' -f2`"
					#INTERVAL="`echo \"$orig_interval*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
					#echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					#draw_pitch
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					original_edo="$EDO"
					old_EDO=$EDO
					EDO="$(($EDO-1))"
					edo_change="$(($edo_change-1))"
					INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
					if [ "$flaggy" == false ]; then
						temp="`calc \"$orig_edo/$EDO\" | cut -d'~' -f2`"
						INTERVAL="`echo \"$orig_interval/$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
					fi
					if [ "$EDO" == "1" ]; then
						flaggy=true
					fi
					echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					draw_pitch
				fi
				if [ "$EDO" == "$stopat" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				fi
				#if [ "$EDO" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
				if [ "$EDO" == "2000000" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				elif [ "$EDO" == "1" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				fi

			elif [ "$downwards" == false ]; then # && [ "$edo_change" -gt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t $time c
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				elif [ "$c" == "c" ]; then
					sleep $SCALE_SPEED
					espeak_say_natural "order reversed"
					original_edo="$EDO"
					flaggy=false
					downwards=true
					#EDO=$(($EDO-1))
					edo_change="1"
					#original_edo="$EDO"

					#INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					#INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`

					#temp="`calc \"$orig_edo/$EDO\" | cut -d'~' -f2`"
					#INTERVAL="`echo \"$orig_interval*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
					#echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					#draw_pitch
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					original_edo=$EDO
					#old_EDO=$EDO
					EDO="$(($EDO+1))"
					edo_change=$(($edo_change+1))

					INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`

					if [ "$flaggy" == false ]; then
						temp="`calc \"$EDO/$orig_edo\" | cut -d'~' -f2`"
						INTERVAL="`echo \"$orig_interval*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
					fi

					if [ "$INTERVAL" == "0" ]; then
						flaggy=true
					fi
					echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					draw_pitch 2
				fi
				if [ "$EDO" == "$stopat" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				fi
				#if [ "$INTERVAL" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
				if [ "$EDO" == "2000000" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				#elif [ "$INTERVAL" == "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
				elif [ "$EDO" == "0" ]; then
					#espeak_say_natural " $INTERVAL of $EDO"
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

main_menu() {
	z=""
	read -rsn1 -t 0.1 _input <$ALETHEIA/input_fifo
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi
	local initial_screen=$1
	tagged=false

	#unset OPT
	#OPT[1]="Begin"
	OPT[1]="Music"
	OPT[2]="Sound"
	OPT[3]="Video"
	#OPT[4]="Locks"
	#OPT[5]="Loops"
	OPT[4]="Queue"
	OPT[5]="Voice"
	OPT[6]="Help"
	OPT[7]="Quit"
	TOTAL_OPTS=${#OPT[@]}

	OPT_MUSIC_SUBMENU[1]="Loops"
	OPT_MUSIC_SUBMENU[2]="Locks"
	TOTAL_OPTS_MUSIC_SUBMENU=${#OPT_MUSIC_SUBMENU[@]}

	SELECTION="1"
	#z=" "

	pad_=1

	#empty_pane
	flag=false
	tmp_flag=true

	until [ "$z" = "," ]; do
		if [ "$z" == "" ]; then
			first=$((($LINES/2) - ($TOTAL_OPTS/2)-1))
			last=$(($first + $TOTAL_OPTS - 1))
			#first=$(($LINES-3-$TOTAL_OPTS))
			#last=$(($first+$TOTAL_OPTS-1))
			x=1
			if [ "$initial_screen" == true ]; then
				#tput cup $(($LINES-2))
				#tput el
				echo -ne "$NOCOLOR"
				#if [ "$PANELS_ENABLED" == "1" ] && [ "$flag" = false ]; then
				#	tput cup 0
				#	echo -ne "$WHITE_BLACK"
				#	printf '%*s' $(($COLS-7-1))
				#	echo -ne "$ALETHEIA_NAME$NOCOLOR"

					#tput cup $(( ($LINES/2) - 6 )) 1
					#echo -ne "$NOCOLOR $ALETHEIA_NAME "

				#	tput cup $LINES
				#	echo -ne "$WHITE_BLACK"
				#	printf '%*s' $(($COLS-${#VERSION}-1))
				#	echo -ne "$VERSION$NOCOLOR"
				#fi
				draw_volume
				draw_equalizer
				#tput cup 1
				#echo -ne "$BLUE\033(0`printf '%*s' $(($COLS)) | tr ' ' 'q'`\033(B"
				#echo -ne "$PANEL_HORIZONTAL_DIVIDER"
				#tput cup $(($LINES-2))
				#echo -ne "$BLUE\033(0`printf '%*s' $(($COLS)) | tr ' ' 'q'`\033(B"
				#echo -ne "$PANEL_HORIZONTAL_DIVIDER"
				draw_banner "MENU"
				draw_position
			else
				#tput cup $(( ($LINES/2) - 5 )) 1
				#echo -ne "$NOCOLOR $ALETHEIA_NAME "

				#RIGHT_BANNER_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+3))"
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				#draw_banner "MENU" false false true
				draw_banner "MENU"
				echo -ne "$NOCOLOR"
			fi

			tput cup $first
			#echo -ne "$PADDING`tput cuf $((($COLS/2)-5))`$BLUE`echo -ne \"\033(0\"`lqqqqqqqk`echo -ne \"\033(B\"`"
			menu_buf="$PADDING`tput el``tput cuf $((($COLS/2)-5))`$BLUE$TOP_BAR_MENU"
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				menu_buf="$menu_buf\b\033(0wqqqqqqqk\033(B`tput el`"
			else
				menu_buf="$menu_buf`tput el`"
			fi
			#tput cup $(($last+2)) $(($COLS-2))
			#echo -ne "$RIGHTPADDING"
			if [ "$initial_screen" == true ]; then
				tput cup $(($LINES-2))
				tput el
			fi
		#	if [ "$flag" == false ] || [ "$flag" == "" ]; then
		#		for x in `seq 1 $(($first-1))`; do
		#			tput cup $x
		#			tput el
		#		done

		#	fi		

			for i in `seq 1 $TOTAL_OPTS`; do
				pad="  "
				temp="${#OPT[$i]}"
				while [ "$temp" -le "$pad_" ]; do
					pad="$pad "
					temp="$(($temp+1))"
				done
				if [ "$i" = "$SELECTION" ]; then
					COLOR="$WHITE"
					#tput cup $(($first + $i))
					#printf '%*s' $((($COLS/2) - 5))
					if [ "${#OPT[$i]}" -lt "5" ]; then
						pad=" "
					else
						pad=""
					fi
					#menu_buf="$menu_buf\n$PADDING`tput cuf $((($COLS/2)-5))`$BLUE$BAR`tput rev`$BLUE_BLACK $BLUE${OPT[$i]} $pad$NOCOLOR$BLUE$BAR"
					menu_buf="$menu_buf\n$PADDING`tput el``tput cuf $((($COLS/2)-5))`$BLUE$BAR`tput rev`$BLUE_BLACK $BLUE${OPT[$i]} $pad$NOCOLOR$BLUE$BAR"
					if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "1" ]; then
							if [ "$MUSIC_SELECTION" == "1" ] && [ "$i" == "1" ]; then
								menu_buf="${menu_buf}${BLUE}`tput rev` Loops $NOCOLOR$WHITE$BAR$NOCOLOR"
							#elif [ "$MUSIC_SELECTION" == "2" ]; then
							#	menu_buf="${menu_buf}$WHITE Loops $WHITE$BAR$NOCOLOR"
							elif [ "$i" == "1" ]; then
								menu_buf="${menu_buf}$WHITE Loops $WHITE$BAR$NOCOLOR"
							fi
						fi
					fi
					menu_buf="$menu_buf`tput el`"	
					if [ "$tagged" == false ] || [ "$tagged" == "" ]; then
						if [ "$nospeak" == false ]; then
							if [ "$tmp_flag" == true ]; then
								if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
									espeak_say_natural "menu, ${OPT[$i]}, ${OPT_MUSIC_SUBMENU[$MUSIC_SELECTION]}"
								else
									espeak_say_natural "menu, ${OPT[$i]}"
								fi
								tmp_flag=false
							else
								if [ "$no_queue_flag" == false ]; then
									if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
										espeak_say_natural "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$MUSIC_SELECTION]}"
									else
										espeak_say_natural "${OPT[$i]}"
									fi
								else
									no_queue_flag=false
								fi
							fi
						fi
					fi
				else
					#tput cup $(($first + $i))
					#printf '%*s' $((($COLS/2) - 5))

					if [ "${#OPT[$i]}" -lt "5" ]; then
						pad=" "
					else
						pad=""
					fi
					#menu_buf="$menu_buf\n$PADDING`tput cuf $((($COLS/2)-5))`$BLUE$BAR$WHITE ${OPT[$i]} $pad$NOCOLOR$BLUE$BAR"
					menu_buf="$menu_buf\n$PADDING`tput el``tput cuf $((($COLS/2)-5))`$BLUE$BAR$WHITE ${OPT[$i]} $pad$NOCOLOR$BLUE$BAR"
					if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "1" ]; then
							if [ "$i" -ge "2" ]; then
									if [ "$MUSIC_SELECTION" == "$i" ] && [ "$i" == "2" ]; then
										menu_buf="${menu_buf}`tput rev`$BLUE ${OPT_MUSIC_SUBMENU[$i]} $NOCOLOR$WHITE$BAR$NOCOLOR"
									elif [ "$i" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
										menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$i]} $BAR$NOCOLOR"
									fi
							fi
								
						fi
						if [ "$i" == "3" ]; then
							menu_buf="$menu_buf\b\033(0tqqqqqqqj\033(B"
						fi
					fi
					menu_buf="$menu_buf`tput el`"	
				fi
			done

			#tput cup $(($last+2))
			menu_buf="$menu_buf\n$PADDING`tput el``tput cuf $((($COLS/2)-5))`$BLUE$BOTTOM_BAR_MENU`tput el`"

			for i in `seq 1 $(($first-1))`; do
				tput cup $i
				tput el
			done

			tput cup $first

			echo -ne "$menu_buf"

			for i in `seq $(($first+$TOTAL_OPTS+2)) $(($LINES-2))`; do
				tput cup $i
				tput el
			done

			unset belowmenu

			#if [ "$flag" == false ] || [ "$flag" == "" ]; then
			#	for x in `seq $(($last+3)) $(($LINES-2))`; do
			#		tput cup $x
			#		tput el
			#		#x=$(($x+1))
			#	done
			#fi
		fi

		if [ "$z" == "" ]; then
			until [ "$z" != "" ]; do
				read -rsn1 -t 0.01 tmp_z <$ALETHEIA/input_fifo
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					new_LINES=`tput lines`
					new_COLS=`tput cols`
					if [ "$new_LINES" != "$LINES" ] || [ "$new_COLS" != "$COLS" ]; then
						COLS=$new_COLS
						LINES=$new_LINES
						draw_wait
						#reset_dimensions
						#redraw_screen false
						#if [ "$MUTE" == true ]; then
						#	draw_banner "MUTE"
						#elif [ "$PAUSE" == true ]; then
						#	draw_banner "PAUSE"
						#fi
						#espeak_say_natural "screen redrawn"
						screen_redrawn=true
						break
					else
						screen_redrawn=false
					fi
					read -rsn1 -t 0.25 z
					if [ "$?" == "0" ]; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "j" ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_SELECTION=$(($MUSIC_SELECTION+1))
			else
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$(($SELECTION+1))"
				else
					SELECTION="1"
				fi
			fi
			tagged=false
			flag=true
			z=""
			continue
		elif [ "$z" == "k" ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_SELECTION=$(($MUSIC_SELECTION-1))
			else
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$(($SELECTION-1))"
				else
					SELECTION="$TOTAL_OPTS"
				fi
			fi
			tagged=false
			flag=true
			z=""
			continue
		#elif [ "$z" == "#" ]; then
		#	killall gtts-cli >/dev/null 2>/dev/null
		#	killall play >/dev/null 2>/dev/null
		#	read -rsn1 -t 0.1 new_input <$ALETHEIA/input_fifo
		#	if [ "$new_input" != "" ]; then
		#		#z="$_input"
		#		z="$new_input"
		#		#nospeak=true
		#	else
		#		read -rsn1 z
		#		#z=""
		#		#nospeak=false
		#	fi
		#	if [ "`isnum \"$z\"`" == "1" ]; then
		#		SELECTION="$z"
		#		z=""
		#	fi
		elif [ "$z" == "l" ]; then
			if [ "$SELECTION" == "1" ]; then
				MUSIC_RIGHT_WINDOW=true
				MUSIC_SELECTION=1
			fi
			z=""
			continue
		elif [ "$z" == "h" ]; then
			if [ "$SELECTION" == "1" ] && [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_RIGHT_WINDOW=false
				MUSIC_SELECTION=1
			fi
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			if [ "$initial_screen" == true ]; then
				tmp_flag=true
			fi
			draw_banner "MENU"
			draw_position
			flag=true
			z=""
			continue
		elif [ "$z" == "i" ]; then
			if [ "$initial_screen" == true ]; then
				#empty_pane
				flag=true
				z=""
				continue
			else
				#empty_pane
				z=","
				#tput cup $(($LINES-2))
				#tput el
			fi
		elif [ "$z" == "a" ]; then
			set_equalizer false true
			draw_equalizer
			z=""
			continue
		elif [ "$z" == "|" ]; then
			#about
			vanish
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_colors true
			z=""
			continue
		elif [ "$z" == "" ]; then
			invert_colors true
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			z=""
			continue
		elif [ "$z" == "X" ]; then
			set_scale_speed
			draw_banner "MENU"
			z=""
			continue
		elif [ "$z" == "q" ]; then
			if [ "$initial_screen" == true ]; then
				clear
				tput cnorm
				stty echo
				exit 0
			fi
			#empty_pane
			z=","
			#tput cup $(($LINES-2))
			#tput el
		elif [ "$z" == "C" ]; then
			yt_artist
			z=""
			continue
		elif [ "$z" == "F" ]; then
			yt_search
			z=""
			continue
		elif [ "$z" == "f" ]; then
			tmux_attach
			z=""
			continue
		#elif [ "$z" == "" ]; then
		#	if [ "$REPEAT_ONLY" == false ]; then
		#		REPEAT_ONLY=true
		#		#artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		#		#if [ "$LOOP_ARTIST" == true ]; then
		#		#	if [ "`find \"$MUSICDIR\" | grep -e \"^$artist - \" | grep -e \"\.repeats$\"`" == "" ]; then
		#		#		LOOP_ARTIST=false
		#		#	fi
		#		#fi
		#		draw_banner "LOOPS ON"
		#		espeak_say_natural "loops on" false true
		#		sleep 0.25
		#		draw_banner "MENU"
		#		draw_position
		#	else
		#		REPEAT_ONLY=false
		#		draw_banner "LOOPS OFF"
		#		espeak_say_natural "loops off" false true
		#		sleep 0.25
		#		draw_banner "MENU"
		#		draw_position
		#	fi
		#	z=""
		#	continue
		elif [ "$z" == "8" ]; then
			master_volume_change "-3% -3%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			master_volume_change "+3% +3%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			master_volume_change "-1% -1%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			master_volume_change "+1% +1%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$(($VOLUME-5))
					espeak_say_natural "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$(($VOLUME+5))
					espeak_say_natural "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$(($VOLUME-1))
					espeak_say_natural "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$(($VOLUME+1))
					espeak_say_natural "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "MENU"
			#tput cup $LINES
			#echo -ne "$WHITE_BLACK`printf '%*s' $COLS`"
			flag=true
			tmp_flag=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait
			REDRAWN=true
			reset_dimensions
			#empty_pane
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
				reset_buffer
			fi
			flag=false
			z=""
			continue
		elif [ "$z" == ":" ]; then
			#tput cup $(($LINES-2))
			#tput el
			voice_settings_screen true
			if [ "$initial_screen" == true ]; then
				empty_pane
			else
				redraw_buffer
			fi
			flag=false
			z=""
			continue
		elif [ "$z" == "?" ]; then
			#tput cup $(($LINES-2))
			#tput el
			if [ "$initial_screen" == true ]; then
				help_screen true
				empty_pane
			else
				help_screen false
				redraw_buffer
			fi
			flag=false
			tmp_flag=true
			z=""
			continue
		elif [ "$z" == "S" ]; then
			new_playlist true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			flag=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			enable_panels
			z=""
			continue
		elif [ "$z" == "s" ]; then
			if [ "$initial_screen" == false ]; then
				REPEAT_ONLY=false
			else
				VIDEO=false
				unset queue_array
				IFS=$'\n'
				index=0
				for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				unset IFS
				TOTAL_QUEUE=$index
				SHUFFLED=true
				if [ "$TOTAL_QUEUE" == "0" ]; then
					draw_banner "NO MUSIC"
					espeak_say_natural "no music"
					no_queue_flag=true
					tput cup $LINES
					echo -ne "$WHITE_BLACK"
					printf '%*s' $COLS
					echo -ne "$NOCOLOR"
					continue
				fi
				JUMP="1"
				echo -ne "$NOCOLOR"
				#kill $MPLAYER_PID >/dev/null 2>/dev/null
				#return $RETURN_JUMP
			fi
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			redraw_buffer
			z=""
			continue
		elif [ "$z" == "Q" ]; then
			#tput cup $(($LINES-2))
			#tput el
			queue_controls true
			if [ "$?" == "$RETURN_JUMP" ]; then
				JUMP=1
				return $RETURN_JUMP
			fi
			empty_pane
			flag=false
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$(($SELECTION+1))"
				fi
				tagged=false
				flag=true
				z=""
				continue
				;;
			'[A')
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$(($SELECTION-1))"
				fi
				tagged=false
				flag=true
				z=""
				continue
				;;
			*)
				if [ "$initial_screen" == true ]; then
					exit 0
				else
					#empty_pane
					tput cup $(($LINES-2))
					tput el
					z=","
				fi
				;;
			esac
	#	elif [ "$z" == "" ]; then
	#		if [ "$initial_screen" == true ]; then
	#			exit 0
	#		else
	#			z=","
	#		fi
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_RIGHT_WINDOW=false
				if [ "$MUSIC_SELECTION" == "1" ]; then
					VIDEO=false
					load_only_loops true
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						espeak_say_natural "no music"
						sleep 0.25
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "$MUSIC_SELECTION" == "2" ]; then
					VIDEO=false
					set_only_locked
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						espeak_say_natural "no music"
						sleep 0.25
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi
					#JUMP="1"
					#echo -ne "$NOCOLOR"
					#kill $MPLAYER_PID >/dev/null 2>/dev/null
					#return $RETURN_JUMP
					#VIDEO=false
					#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3.locked\" -o -iname \"*.flac.locked\" | shuf`"
					#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/.locked$//g\"`"
					#SHUFFLED=true
					#ONLY_LOCKED=true
					#selected_locks=true
					#TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
			case $SELECTION in
			*)
				if [ "${OPT[$SELECTION]}" == "Search" ]; then
					new_playlist true
					if [ "$?" == "$RETURN_JUMP" ]; then
						return $RETURN_JUMP
					fi
				#	draw_banner "START"
				#	tmp="`read_line`"
				#	if [ "$tmp" == "" ]; then
				#		if [ "$initial_screen" == false ]; then
				#			draw_banner "MENU"
				#		else
				#			empty_pane
				#		fi
				#		continue
				#	else
				#		for i in "$tmp"; do
				#			KEYWORD="$KEYWORD$i.*"
				#		done
				#		QBUFFER="`find \"$MUSICDIR\" -iregex \".*${KEYWORD}mp3\" -o -iregex \".*${KEYWORD}flac\"`"
				#		#if [ -e "$ALETHEIA/queue" ]; then
				#		#	QBUFFER="`cat \"$ALETHEIA/queue\"`"
				#		#fi
				#		VIDEO=false
				#		TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
				#		JUMP="1"
				#		echo -ne "$NOCOLOR"
				#		kill $MPLAYER_PID >/dev/null 2>/dev/null
				#		return $RETURN_JUMP
				#	fi
					flag=true
				elif [ "${OPT[$SELECTION]}" == "Music" ]; then
					QUEUE_RENDERED=false
					pick=""
					if [ "$initial_screen" == false ]; then
						REPEAT_ONLY=false
					fi
					VIDEO=false
					#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
					unset queue_array
					IFS=$'\n'
					index=0
					for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
					#for i in $(find "$MUSICDIR" \( -iname "*.mp3" -o -iname "*.flac" \) -not -iname "*\.repeat\.*" | shuf); do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					SHUFFLED=true
					#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
					TOTAL_QUEUE=$index
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						espeak_say_natural "no music"
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				#elif [ "${OPT[$SELECTION]}" == "Begin" ]; then
				#	new_playlist true
				#	if [ "$?" == "$RETURN_JUMP" ]; then
				#		return $RETURN_JUMP
				#	fi
				elif [ "${OPT[$SELECTION]}" == "Locks" ]; then
					if [ "$initial_screen" == false ]; then
						REPEAT_ONLY=false
					fi
					VIDEO=false
					QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3.locked\" -o -iname \"*.flac.locked\" | shuf`"
					QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/.locked$//g\"`"
					SHUFFLED=true
					ONLY_LOCKED=true
					selected_locks=true
					TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						espeak_say_natural "no music"
						sleep 0.25
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Loops" ]; then
					VIDEO=false
					load_only_loops 1
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						espeak_say_natural "no music"
						sleep 0.25
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Sound" ]; then
					QUEUE_RENDERED=false
					pick=""
					REPEAT_ONLY=false
					VIDEO=false
					if [ -e "$HOME/Sounds/" ]; then
						unset queue_array

						IFS=$'\n'
						index=0
						for i in `find "$HOME/Sounds" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						#new_QBUFFER="`find \"$HOME/Sounds\" -iname \"*.mp3\" -o -iname \"*.flac\" | sort`"
						SHUFFLED=true
						#new_TOTAL_QUEUE="`echo -e \"$new_QBUFFER\" | wc -l`"
						new_TOTAL_QUEUE=$index
					else
						new_TOTAL_QUEUE=0
					fi
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO SOUNDS"
						espeak_say_natural "no sounds" true
						tmp_flag=true
						no_queue_flag=true
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						draw_position
						continue
						
					else
						#QBUFFER="$new_QBUFFER"
						TOTAL_QUEUE="$new_TOTAL_QUEUE"
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Video" ]; then
					QUEUE_RENDERED=false
					REPEAT_ONLY=false
					#VIDEO=true
					if [ -e "$HOME/Videos/" ]; then
						unset queue_array

						IFS=$'\n'
						index=0
						for i in `find "$HOME/Videos" -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.webm" | shuf`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						#QBUFFER="`find "$HOME/Videos" -iname \"*.mkv\" -o -iname \"*.mp4\" | sort`"
						#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
						TOTAL_QUEUE=$(($index))
					else
						TOTAL_QUEUE=0
					fi
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO VIDEOS"
						espeak_say_natural "no videos"
						no_queue_flag=true
						tmp_flag=true
						tput cup $LINES
						echo -ne "$WHITE_BLACK"
						printf '%*s' $COLS
						echo -ne "$NOCOLOR"
						continue
						
					fi					
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
					#if [ "$initial_screen" == false ] || [ "$initial_screen" == "" ]; then
					#	queue_controls true
					#else
					#tput cup $(($LINES-2))
					#tput el
					if [ -e "$ALETHEIA/playlists/" ] && [ "`ls -1 \"$ALETHEIA/playlists/\" | wc -l`" != "0" ]; then
						queue_controls true
					else
						queue_controls true
					#	draw_banner "NO QUEUES"
					#	espeak_say_natural "no queues" true
					#	tmp_flag=true
						#tput cup $LINES
						#echo -ne "$WHITE_BLACK"
						#printf '%*s' $COLS
						#echo -ne "$NOCOLOR"
					#	draw_banner "MENU"
					#	draw_position
						#no_queue_flag=true
					fi
					#fi
					if [ "$?" == "$RETURN_JUMP" ]; then
						JUMP=1
						return $RETURN_JUMP
					fi
					if [ "$initial_screen" == true ]; then
						empty_pane
					else
						reset_buffer
						redraw_buffer
					fi
					tmp_flag=true
					flag=false
					#empty_pane
				elif [ "${OPT[$SELECTION]}" == "Voice" ]; then
					voice_settings_screen true
					if [ "$initial_screen" == true ]; then
						empty_pane
					else
						redraw_buffer
					fi
					flag=false
				elif [ "${OPT[$SELECTION]}" == "Help" ]; then
					#if [ "$DIMENSIONS_RESET" == true ]; then
					#	render_help_screen
					#	render_voice_settings_screen
					#	DIMENSIONS_RESET=false
					#fi
					if [ "$initial_screen" == true ]; then
						help_screen true
						empty_pane
					else
						help_screen false
						redraw_buffer
						#RIGHT_BANNER_WIDTH=$((${#POSITION}+${#TOTAL_QUEUE}+3))
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					fi
					flag=false
					tmp_flag=true
					#if [ "$initial_screen" == false ] || [ "$initial_screen" == "" ]; then
					#	draw_volume
					#	draw_equalizer
					#	draw_position
					#fi
				#elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
				#	queue_controls
				#	break
				elif [ "${OPT[$SELECTION]}" == "Quit" ]; then
					clear
					exit 0
				else
					z=","
				fi

			esac
		fi
		if [ "$z" = "," ]; then
			if [ "$1" == false ] || [ "$1" == "" ]; then
				#espeak_say_natural "closed"
				#reset_buffer
				redraw_buffer
				#tput cup $(($LINES-2))
				#tput el
				draw_pitch
				draw_position
			fi
			z=","
		fi
	done
}

scale() {
	if [ "$WEB_CLIENT" != 1 ]; then
		espeak_say_natural "scale"
	fi
	draw_banner "SCALE"
	stopat=""
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 interval_change <&1
	else
		read -rsn1 interval_change <$ALETHEIA/input_fifo
	fi

	if [ "$interval_change" = "J" ]; then
		if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		backwards=true
		time=2.5
		interval_change="$(($INTERVAL-$EDO))"
	elif [ "$interval_change" = "K" ]; then
		if [ "$INTERVAL" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		backwards=false
		time=2.5
		interval_change="$(($INTERVAL+$EDO))"
	elif [ "$interval_change" == "j" ]; then
		if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		backwards=true
		time=$SCALE_SPEED
		interval_change="$(($INTERVAL-$EDO))"
	elif [ "$interval_change" == "k" ]; then
		if [ "$INTERVAL" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		espeak_say_natural "scaling"
		backwards=false
		time=$SCALE_SPEED
		interval_change="$(($INTERVAL+$EDO))"
	elif [ "$interval_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "?" ]; then
		scale_screen
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "" ] || [ "$interval_change" == "q" ] || [ "$interval_change" == "u" ]; then
		#scale_screen
		espeak_say_natural "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "`isnum \"$interval_change\"`" != "0" ] || [ "$interval_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="`read_line \"$interval_change\"`"
		if [ "`isnum \"$tmp\"`" == "0" ]; then
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		if [ "$tmp" -lt "$INTERVAL" ]; then
			if [ "$tmp" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
				espeak_say_natural "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			espeak_say_natural "scaling"
			stopat=$tmp
			backwards=true
			time=$SCALE_SPEED
			interval_change="$(($INTERVAL-$EDO))"
		elif [ "$tmp" -gt "$INTERVAL" ]; then
			if [ "$tmp" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
				espeak_say_natural "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			espeak_say_natural "scaling"
			stopat=$tmp
			backwards=false
			time=$SCALE_SPEED
			interval_change="$(($INTERVAL+$EDO))"
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "SCALE" false true
		else
			espeak_say_natural "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		espeak_say_natural "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$interval_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
		fi
		orig_int="$INTERVAL"
		c=""
		while [ "$interval_change" != "$orig_int" ]; do
			if [ "$interval_change" -le "$orig_int" ] || [ "$BACKWORDS" == true ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t $SCALE_SPEED c
				else
					read -rsn1 -t $SCALE_SPEED c <$ALETHEIA/input_fifo
				fi
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ] || [ "$c" == "" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "scale closed"
					break
				elif [ "$c" == "c" ]; then
					if [ "$c" == "c" ]; then
						sleep $SCALE_SPEED
						espeak_say_natural "order reversed"
					fi
					if [  "$backwards" == true ] && [ "$c" != "c" ]; then
						#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
						#	SCALETEMPO=false
						#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
							#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
						#fi
						INTERVAL="$(($INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						interval_change="$(($interval_change * -1))"
					else 
						#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
						#	SCALETEMPO=false
						#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
							#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
						#fi
						backwards=true
						interval_change="$(($interval_change*-1))"
						INTERVAL="$(($INTERVAL-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
					#	SCALETEMPO=false
						echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
						#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
					#fi
					INTERVAL="$(($INTERVAL-1))"
					echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "scale finished"
					break
				fi
				if [ "$INTERVAL" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "limit reached"
					break
				elif [ "$INTERVAL" == "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "limit reached"
					break
				fi

			elif [ "$interval_change" -ge "$orig_int" ] || [ "$backwards" == false ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t $SCALE_SPEED c
				else
					read -rsn1 -t $SCALE_SPEED c <$ALETHEIA/input_fifo
				fi
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ] || [ "$c" == "" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "scale closed"
					break
				elif [ "$c" == "c" ] || [ "$backwards" == true ];  then
					if [ "$c" == "c" ]; then
						sleep $SCALE_SPEED
						espeak_say_natural "order reversed"
					fi
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
						#	SCALETEMPO=false
						#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
							#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
						#fi
						INTERVAL="$(($INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						INTERVAL="$(($INTERVAL+1))"
					else
						#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
						#	SCALETEMPO=false
						#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
							#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
						#fi
						backwards=true
						INTERVAL="$(($INTERVAL-1))"
						interval_change="$(($interval_change*-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					INTERVAL="$(($INTERVAL+1))"
					echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "scale finished"
					break
				fi
				if [ "$INTERVAL" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "limit reached"
					break
				elif [ "$INTERVAL" == "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
					#espeak_say_natural " $INTERVAL of $EDO" false 1
					espeak_say_natural "limit reached"
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

scale_octave() {
	draw_banner "OCTAVE" false true
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
	fi
	if [ "$1" == "-" ]; then
		orig_int=$INTERVAL
		if [ "$(($INTERVAL-$EDO))" -ge "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$(($INTERVAL-$EDO))
				echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				draw_pitch
			else
				#espeak_say_natural "Scaling to $(($INTERVAL-$EDO))"
				espeak_say_natural "scaling"
				x=0
				while [ "$x" -lt "$EDO" ]; do
					read -rsn1 -t $SCALE_SPEED c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$(($INTERVAL-1))"
						echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						draw_pitch
						x=$(($x+1))
					fi
				done
			fi
			#espeak_say_natural " $INTERVAL of $EDO"
		fi
	elif [ "$1" == "+" ]; then
		orig_int=$INTERVAL
		if [ "$(($INTERVAL+$EDO))" -le "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$(($INTERVAL+$EDO))
				echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				draw_pitch
			else
				#espeak_say_natural "Scaling to $(($INTERVAL+$EDO))"
				espeak_say_natural "scaling"
				x=0
				while [ "$x" -le "$EDO" ]; do
					read -rsn1 -t $SCALE_SPEED c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$(($INTERVAL+1))"
						echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						draw_pitch
						x=$(($x+1))
					fi
				done
			fi
			#espeak_say_natural "$INTERVAL of $EDO"
		fi
	fi
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

set_custom_int() {
	espeak_say_natural "enter interval"
	draw_banner "INT"
	read -n1 interval_jump
	if [ "`isnum \"$interval_jump\"`" == "1" ] || [ "$interval_jump" == "-" ]; then
		interval_jump="`read_line \"$interval_jump\"`"
	else
		espeak_say_natural "closed"
		draw_pitch
		redraw_buffer
		return
	fi
	if [ "$interval_jump" != "" ]; then
		PAUSE=false
		echo -e "speed_set `calc \"2^($interval_jump/$EDO)\"`" >$ALETHEIA/pipe$$ &
		INTERVAL="$interval_jump"
	else
		espeak_say_natural "closed"
		draw_position
	fi
	draw_pitch
}

toggle_mute() {
	echo "pausing_keep mute" >$ALETHEIA/pipe$$ &
	if [ $MUTE = false ]; then
		pactl set-sink-mute @DEFAULT_SINK@ 1 >/dev/null 2>/dev/null
		espeak_say_natural "muted"
		MUTE=true
		draw_banner "MUTE"
	else
		pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
		espeak_say_natural "unmuted"
		MUTE=false
		draw_pitch
	fi
}

toggle_pause() {
	echo -e "pause" >$ALETHEIA/pipe$$ &
	#if [ "$RIGHT_BANNER_WIDTH" -gt "$POSITION_WIDTH" ]; then
	#	result="$(($PANE_WIDTH - $RIGHT_BANNER_WIDTH))"
	#else
	#	result="$(($PANE_WIDTH - ${#POSITION} - ${#TOTAL_QUEUE} - 3))"
	#fi
	if [ $PAUSE = false ]; then
		PAUSE=true
		if [ "$1" == false ] || [ "$1" == "" ]; then
			espeak_say_natural "paused"
			draw_banner "PAUSE" false false true
		fi
	else
		PAUSE=false
		if [ "$1" == false ] || [ "$1" == "" ]; then
			espeak_say_natural "unpaused"
			draw_pitch
		fi
	fi
}

interval_to_zero() {
	INTERVAL="0"
	echo "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
	LOCKED=false
	#espeak_say_natural " $INTERVAL of $EDO"
	draw_volume
	draw_equalizer
	draw_pitch
	draw_position
}

reset_all_tuning() {
	#VOLUME="$DEFAULT_VOLUME"
	#EQUALIZER="$DEFAULT_EQUALIZER"
	#echo -e "af_del equalizer" >"$ALETHEIA/pipe$$" &
	#equal="`echo $EQUALIZER | cut -d':' -f1`"
	#equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
	#equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
	SCALETEMPO=false
	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
	#sleep 0.1
	#echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	espeak_say_natural "reset"
	draw_volume
	draw_equalizer
	draw_pitch
}

reset_to_locked() {
	if [ -e "$FILENAME.locked" ]; then
		BOTH="`cat \"$FILENAME\".locked`"
		INTERVAL="`echo \"$BOTH\" | cut -d'/' -f1`"
		EDO="`echo \"$BOTH\" | cut -d'/' -f2`"
		#INTERVAL_LIMIT=$(($EDO * 3))
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
		#VOLUME="`echo \"$BOTH\" | cut -d'/' -f3`"
		EQUALIZER="`echo \"$BOTH\" | cut -d'/' -f4`"
		SCALETEMPO_FLAG="`echo \"$BOTH\" | cut -d'/' -f5`"
		LOCKED=true

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		
		if [ "$EQUALIZER" == "" ]; then
			EQUALIZER="$DEFAULT_EQUALIZER"
			equal="`echo $EQUALIZER | cut -d':' -f1`"
			equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
			equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
		else
			if [ "$EQUALIZER" != "0:0:0:0:0:0:0:0:0:0" ]; then
				echo -e "af_del equalizer" >"$ALETHEIA/pipe$$" &
				echo -e "af_add equalizer=$EQUALIZER" >"$ALETHEIA/pipe$$" &

				equal="`echo $EQUALIZER | cut -d':' -f1`"
				equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
				equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
			fi
		fi

		if [ "$SCALETEMPO_FLAG" == "" ]; then
			SCALETEMPO=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
		elif [ "$SCALETEMPO_FLAG" == "0" ]; then
			SCALETEMPO=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
		else
			SCALETEMPO=true
			echo -e "af_add scaletempo" >"$ALETHEIA/pipe$$" &
			#echo -e "af_cmdline scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
		fi
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		sleep 0.1
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#espeak_say_natural " $INTERVAL of $EDO"
	else
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$DEFAULT_EDO"
		#INTERVAL_LIMIT=$(($EDO * 3))
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
		echo "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		VOLUME="$DEFAULT_VOLUME"
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#espeak_say_natural " $INTERVAL of $EDO"
	fi
	draw_equalizer
	draw_volume
	draw_pitch
	draw_position
}

set_custom_edo() {
	draw_banner "EDO"
	espeak_say_natural "enter e d o"
	read -n1 new_edo
	if [ "`isnum \"$new_edo\"`" == "1" ]; then
		new_edo="`read_line \"$new_edo\"`"
	else
		espeak_say_natural "closed"
		draw_pitch
		redraw_buffer
		return
	fi

	reset_buffer
	if [ "$new_edo" = "" ]; then
		espeak_say_natural "closed"
		draw_pitch
		redraw_buffer
		return
	fi

	if [ "`isnum \"$new_edo\"`" != "0" ]; then
		PAUSE=false
		LEVEL="${#new_edo}"
		if [ "$new_edo" -lt "1" ]; then
			tput cup $(($LINES-3))
			tput el
			return
		fi
		if [ "$new_edo" -gt "$EDO" ]; then
			temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
			INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
		elif [ "$new_edo" -lt "$EDO" ]; then
			temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2 | bc`"
			INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
		else
			#redraw_buffer
			draw_pitch
			draw_position
			return
		fi

		EDO="$new_edo"
		LOCKED_EDO="$EDO"
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		LOCKED=false
		redraw_buffer
		draw_volume
		draw_equalizer
		draw_pitch
		draw_position
		#espeak_say_natural " $INTERVAL of $EDO"
	else
		draw_pitch
		redraw_buffer
	fi
}

double_precise() {
	if [ "$EDO" -lt "$EDO_LIMIT" ]; then
		INTERVAL=$(($INTERVAL * 2))
		EDO=$(($EDO*2))
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		#espeak_say_natural " $INTERVAL"
		#espeak_say_natural "double"
		draw_pitch
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	else
		espeak_say_natural "limit"
	fi
}

half_precise() {
	old="`calc \"($INTERVAL/$EDO)\"`"
	if [ "$(($EDO % 2))" = "0" ]; then
		new_edo="$(($EDO/2))"
		if [ "$new_edo" -ge "2" ]; then
		#if [ "$new_edo" -ge "12" ] || [ "$new_edo" -ge "$LOCKED_EDO" ]; then
			temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
			INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
			if [ "`isnum \"$INTERVAL\"`" == "0" ]; then
				INTERVAL=0
			fi
			EDO="$new_edo"
			new="`calc \"($INTERVAL/$EDO)\"`"
			echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
			#espeak_say_natural "half"
			#espeak_say_natural " $INTERVAL"
			INTERVAL_LIMIT=`calc "$EDO * 2.6"`
			INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
		else
			espeak_say_natural "limit"
		fi
		if [ "$old" != "$new" ]; then
			LOCKED=false
		fi
		draw_pitch
	fi
}

pitch_down() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
	#if [ ! -p "$ALETHEIA/pipe$$" & ]; then
		#kill $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
		fi
	fi
	#if [ "$INTERVAL" == "0" ] && [ "$SCALETEMPO" == true ]; then
	#	SCALETEMPO=false
	#	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	#fi
	if [ "$INTERVAL" -gt "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
		INTERVAL=$(($INTERVAL-1))
		#BPM="`calc \"$BPM * (2^(-1/$EDO))\" | cut -d'~' -f2-`"
		#BPM="`printf '%0.2f' $BPM`"
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &

		LOCKED=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch 1
		fi
		#if [ "$1" == false ] || [ "$1" == "" ]; then
		#	read -n1 -t 0.1 key
		#	if [ "$key" == "j" ]; then
		#		pitch_down
		#		if [ "$?" != "200" ]; then
		#			return $?
		#		fi
		#	fi
		#fi
		#espeak_say_natural " $INTERVAL"
	else
		espeak_say_natural "limit"
	fi

	return 200
}

pitch_up() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
	#if [ ! -p "$ALETHEIA/pipe$$" & ]; then
		#kill $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -lt "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
		INTERVAL=$(($INTERVAL+1))
		#BPM="`calc \"$BPM * (2^(1/$EDO))\" | cut -d'~' -f2`"
		#BPM="`printf '%0.2f' $BPM`"
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &

		LOCKED=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch 1
		fi
		#if [ "$1" == false ] || [ "$1" == "" ]; then
		#	read -n1 -t 0.1 key
		#	if [ "$key" == "k" ]; then
		#		pitch_up
		#		if [ "$?" != "200" ]; then
		#			return $?
		#		fi
		#	fi
		#fi
		#espeak_say_natural " $INTERVAL"
	else
		espeak_say_natural "limit"
	fi

	return 200
}

edo_down() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
	#if [ ! -p "$ALETHEIA/pipe$$" & ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		draw_pitch
	fi
	#if [ "$EDO" -gt "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
	if [ "$EDO" -gt "1" ]; then
		EDO=$(($EDO-1))
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
		tmpz=$(($EDO*2))
		if [ "$INTERVAL" -gt "$tmpz" ] || [ "$INTERVAL" -lt "$((-$tmpz))" ]; then
			if [ "$INTERVAL" -lt "0" ]; then
				INTERVAL=-$tmpz
			else
				INTERVAL=$tmpz
			fi
		fi

		LOCKED=false
		draw_pitch 2
		#read -n1 -t 0.1 key
		#if [ "$key" == "k" ]; then
		#	edo_down
		#	if [ "$?" != "200" ]; then
		#		return $?
		#	fi
		#fi
		espeak_say_natural " $EDO"
	else
		espeak_say_natural "limit"
	fi

	return 200
}

set_default_edo() {
	#espeak_say_natural "default e d o"
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		draw_pitch
	fi
	new_edo="$DEFAULT_EDO"
	if [ "$new_edo" -gt "$EDO" ]; then
		temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
		INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
	elif [ "$new_edo" -lt "$EDO" ]; then
		temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2`"
		INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
	fi
	EDO="$new_edo"
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	#espeak_say_natural " $INTERVAL of $EDO"
	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
	LOCKED=false
	draw_pitch 1
}

edo_up() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -lt "2000000" ]; then
		EDO=$(($EDO+1))
		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &

		LOCKED=false
		draw_pitch 2
		#read -n1 -t 0.1 key
		#if [ "$key" == "k" ]; then
		#	edo_up
		#	if [ "$?" != "200" ]; then
		#		return $?
		#	fi
		#fi
		espeak_say_natural "$EDO"
	else
		espeak_say_natural "limit"
	fi

	return 200
}

toggle_scale_tempo() {
	if [ "$SCALETEMPO" == false ]; then
		#echo -e "af_cmdline scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
		echo -e "af_add scaletempo" >"$ALETHEIA/pipe$$" &
		espeak_say_natural "tempo"
		SCALETEMPO=true
		ONLY_PITCH=false
	else
		if [ "$ONLY_PITCH" == false ]; then
			ONLY_PITCH=true
			espeak_say_natural "pitch"
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			#sleep 0.2
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		else
			#echo -e "af_cmdline scaletempo=speed=both" >"$ALETHEIA/pipe$$" &
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			espeak_say_natural "pitch and tempo"
			SCALETEMPO=false
			ONLY_PITCH=false
		fi
	fi
	if [ "$PAUSE" == true ]; then
		PAUSE=false
	fi
	draw_pitch 3
}

secondary_scale_func() {
	if [ "$1" == "v" ]; then
		toggle_scale_tempo
	elif [ "$1" == "j" ]; then
		pitch_down
	elif [ "$1" == "k" ]; then
		pitch_up
	elif [ "$1" == "l" ]; then
		espeak_say_natural "forward"
		echo "seek +5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "h" ]; then
		espeak_say_natural "backward"
		echo "seek -5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "8" ]; then
		master_volume_change "-3% -3%"
	elif [ "$1" == "9" ]; then
		master_volume_change "+3% +3%"
	elif [ "$1" == "*" ]; then
		master_volume_change "-1% -1%"
	elif [ "$1" == "(" ]; then
		master_volume_change "+1% +1%"
	elif [ "$1" == "H" ]; then
		less_precise
	elif [ "$1" == "L" ]; then
		more_precise
	elif [ "$1" == "o" ]; then
		pause=false
		if [ "$mute" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$
			mute=false
			draw_pitch
		fi
		double_precise
	elif [ "$1" == "m" ]; then
		pause=false
		if [ "$mute" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$
			mute=false
			draw_pitch
		fi
		half_precise				
	elif [ "$1" == "a" ]; then
		PAUSE=false
		pause=false
		draw_banner "$2" false true
		set_equalizer
		draw_banner "$2" false true
	elif [ "$1" == "y" ]; then
		set_default_edo
	elif [ "$1" == "!" ]; then
		pcm_volume_change "$1"
		#if [ "$PAUSE" == true ]; then
		#	PAUSE=false
		#	draw_pitch
		#fi
		#if [ "$MUTE" == true ]; then
		#	echo "mute" >$ALETHEIA/pipe$$ &
		#	MUTE=false
		#	draw_pitch
		#fi
		#if [ "$VOLUME" -ge "1" ]; then
		#	VOLUME="$(($VOLUME-1))"
		#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#	espeak_say_natural " $VOLUME"
		#	#LOCKED=false
		#	draw_equalizer
		#	draw_volume
		#fi
	elif [ "$1" == "@" ]; then
		pcm_volume_change "$1"
		#if [ "$PAUSE" == true ]; then
		#	PAUSE=false
		#	draw_pitch
		#fi
		#if [ "$MUTE" == true ]; then
		#	echo "mute" >$ALETHEIA/pipe$$ &
		#	MUTE=false
		#	draw_pitch
		#fi
		#if [ "$VOLUME" -le "99" ]; then
		#	VOLUME="$(($VOLUME+1))"
		#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#	espeak_say_natural " $VOLUME"
		#	#LOCKED=false
		#	draw_equalizer
		#	draw_volume
		#fi
	elif [ "$1" == "1" ]; then
		pcm_volume_change "$1"
		#if [ "$PAUSE" == true ]; then
		#	PAUSE=false
		#	draw_pitch
		#fi
		#if [ "$MUTE" == true ]; then
		#	echo "mute" >$ALETHEIA/pipe$$ &
		#	MUTE=false
		#	draw_pitch
		#fi
		#if [ "$VOLUME" -ge "5" ]; then
		#	VOLUME="$(($VOLUME-5))"
		#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#	espeak_say_natural " $VOLUME"
		#	#LOCKED=false
		#	draw_equalizer
		#	draw_volume
		#fi
	elif [ "$1" == "2" ]; then
		pcm_volume_change "$1"
		#if [ "$PAUSE" == true ]; then
		#	PAUSE=false
		#	draw_pitch
		#fi
		#if [ "$MUTE" == true ]; then
		#	echo "mute" >$ALETHEIA/pipe$$ &
		#	MUTE=false
		#	draw_pitch
		#fi
		#if [ "$VOLUME" -le "95" ]; then
		#	VOLUME="$(($VOLUME+5))"
		#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		#	espeak_say_natural " $VOLUME"
		#	#LOCKED=false
		#	draw_equalizer
		#	draw_volume
		#fi
	elif [ "$1" == "p" ]; then
		toggle_pause
		draw_banner "$2" false true
		#draw_position
		if [ "$WEB_CLIENT" == "0" ]; then
			read -n1 throwaway
		else
			read -n1 throwaway <$ALETHEIA/input_fifo
		fi

		toggle_pause
		draw_banner "$2" false true
	elif [ "$1" == "T" ]; then
		set_only_display_song
		redraw_buffer
	elif [ "$1" == "\\" ]; then
		echo "seek 0 2" >"$ALETHEIA/pipe$$" &
	else
		#if [ "$1" == "" ]; then
		#	read -n2 -t 0.03 key >/dev/null 2>/dev/null
		#	case $key in
		#		'[B')
		#			SCALE_SPEED="`echo -e \"$SCALE_SPEED+5\" | bc`"
		#			;;
		#		'[A')
		#			if [ "`echo -e \"($SCALE_SPEED-2.5) > 0\" | bc`" == "1" ]; then
		#				SCALE_SPEED="`echo -e \"$SCALE_SPEED-5\" | bc`"
		#			fi
		#			;;
		#	esac
		#else
			master_volume_secondary_func "$1"
		#fi
		return
	fi
}

oscillate() {
	old_int="$INTERVAL"
	espeak_say_natural "oscillate"
	draw_banner "OSCILLATE"
	tput rc
	read -rsn1 result
	if [ "$result" == "q" ] || [ "$result" == "G" ] || [ "$result" == "" ]; then
		espeak_say_natural "closed"
		draw_pitch
		draw_position
		return
	fi
	if [ "$result" != "" ]; then
		result="`read_line \"$result\"`"
	fi
	if [ "$result" != "" ]; then
		#if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			#if [ "$INTERVAL" -lt "$result" ]; then
			#	result="`calc \"abs($INTERVAL) - abs($result)\"`"
			#elif [ "$INTERVAL" -gt "$result" ]; then
			#	result="`calc \"abs($result) - abs($INTERVAL)\"`"
			#else
			#	draw_pitch
			#	draw_position
			#	return
			#fi
		if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			if [ "$INTERVAL" -lt "$result" ]; then
				NEGATIVE=true
			else
				NEGATIVE=false
			fi
			abs_int=${INTERVAL#-}
			abs_result=${result#-}
			if [ "$abs_int" -gt "$abs_result" ]; then
				result="`echo -e \"$abs_int - $abs_result\" | bc`"
			elif [ "$abs_int" -lt "$abs_result" ]; then
				result="`echo -e \"$abs_result - $abs_int\" | bc`"
			else
				espeak_say_natural "closed"
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -gt "0" ]; then
			if [ "$INTERVAL" -gt "$result" ]; then
				result="`echo -e \"$INTERVAL - $result\" | bc`"
				NEGATIVE=false
			elif [ "$INTERVAL" -lt "$result" ]; then
				result="`echo -e \"$result - $INTERVAL\" | bc`"
				NEGATIVE=true
			else
				espeak_say_natural "closed"
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -lt "0" ]; then
			abs_result=${result#-}
			result="`echo -e \"$abs_result + $INTERVAL\" | bc`"
			NEGATIVE=false
		elif [ "$INTERVAL" -lt "0" ] && [ "$result" -gt "0" ]; then
			abs_int=${INTERVAL#-}
			result="`echo -e \"$result + $abs_int\" | bc`"
			NEGATIVE=true
		elif [ "$INTERVAL" == "0" ] || [ "$result" == "0" ]; then
			if [ "$INTERVAL" == "0" ] && [ "$result" == "0" ]; then
				espeak_say_natural "closed"
				draw_pitch
				draw_position
				return
			elif [ "$INTERVAL" == "0" ]; then
				if [ "$result" -lt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				result="`calc \"abs($result)\" | sed \"s/\\t//g\"`"
			elif [ "$result" == "0" ]; then
				if [ "$INTERVAL" -lt "0" ]; then
					NEGATIVE=true
				else
					NEGATIVE=false
				fi
				result="`calc \"abs($INTERVAL)\" | sed \"s/\\t//g\"`"
			fi
		fi
		#result="`calc \"abs($(($INTERVAL-$result)))\" | sed \"s/\\t//g\"`"
		#elif [ "$INTERVAL" -lt "0" ] && [ "$result" -ge "0"
		#result="`calc \"abs($(($INTERVAL-$result)))\" | sed \"s/\\t//g\"`"
		#if [ "$INTERVAL" -lt "$result" ]; then
			#if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			#	result="`calc \"abs($(($INTERVAL-$result)))\" | sed \"s/\\t//g\"`"
		#	result="`calc \"abs($(($INTERVAL-$result)))\" | sed \"s/\\t//g\"`"
		#elif [ "$INTERVAL" -lt "$result" ]; then
		#	result="`calc \"abs($(($result-$INTERVAL)))\" | sed \"s/\\t//g\"`"
		#else
		#	result=0
		#fi
	fi
	if [ "$result" == "0" ]; then
		espeak_say_natural "closed"
		draw_pitch
		draw_position
		return
	fi
	draw_banner "OSCILLATE" false true
	espeak_say_natural "oscillating"
	if [ "$result" == "" ]; then
		old_int="$INTERVAL"
		INTERVAL="$((-($INTERVAL)))"
		if [ "$INTERVAL" -lt "0" ]; then
			result="$old_int"
		else
			result="$INTERVAL"
		fi
		result="$(($result*2))"
		if [ "$old_int" -gt "0" ]; then
			NEGATIVE=false
		else
			NEGATIVE=true
		fi
	fi
	x=0

	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >$ALETHEIA/pipe$$ &
		MUTE=false
	fi
	while [ "$x" -lt "$result" ]; do
		read -rsn1 -t $SCALE_SPEED c
		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		#FIXME
		if [ "$c" == "o" ]; then
			old_int=$(($old_int*2))
			if [ "$EDO" -lt "$EDO_LIMIT" ]; then
				x=$(($x*2))
				result=$(($result*2))
			fi
		elif [ "$c" == "m" ]; then
			#old_int=$INTERVAL
			if [ "$(($EDO % 2))" == "0" ]; then
				old_int=$(($old_int/2))
				x=$(($x/2))
				result=$(($result/2))
			fi
		fi
		secondary_scale_func "$c" "OSCILLATE"
		if [ "$c" == "c" ]; then
			x=$(($result-$x-2))
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
		# FIXME
		elif [ "$c" == "H" ]; then
			old_int=$INTERVAL
		elif [ "$c" == "L" ]; then
			old_int=$INTERVAL
		#elif [ "$c" == "o" ]; then
		#	#old_int=$(($old_int*2))
		#	x=$(($x*2))
		#	result=$(($result*2))
		#elif [ "$c" == "m" ]; then
		#	#old_int=$INTERVAL
		#	x=$(($x/2))
		#	result=$(($result/2))
		elif [ "$c" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "OSCILLATE" false true
			redraw_screen false 1 1 1 0
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_pitch
			draw_banner "OSCILLATE" false true
		elif [ "$c" == "q" ] || [ "$c" == "" ]; then
			#espeak_say_natural " $INTERVAL of $EDO"
			break
		elif [ "$c" == "" ]; then
			if [ "$NEGATIVE" == false ]; then
				INTERVAL="$(($old_int-1))"
				old_int="$(($old_int-1))"
			else
				INTERVAL="$(($old_int+1))"
				old_int="$(($old_int+1))"
			fi
			echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
			draw_pitch
			x="$(($x+1))"
		fi

		if [ "$x" == "$result" ]; then
			x=0
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				#RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch
				draw_position
				return
			fi
			if [ "$c" == "o" ]; then
				old_int=$(($old_int*2))
				if [ "$EDO" -lt "$EDO_LIMIT" ]; then
					x=$(($x*2))
					result=$(($result*2))
				fi
			elif [ "$c" == "m" ]; then
				#old_int=$INTERVAL
				if [ "$(($EDO % 2))" == "0" ]; then
					old_int=$(($old_int/2))
					x=$(($x/2))
					result=$(($result/2))
				fi
			fi
			secondary_scale_func "$c" "OSCILLATE"
			if [ "$c" == "c" ]; then
				x=$(($result-$x-2))
				if [ "$NEGATIVE" == true ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
			elif [ "$c" == "H" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "L" ]; then
				old_int=$INTERVAL
			#elif [ "$c" == "o" ]; then
			#	old_int=$(($old_int*2))
			#elif [ "$c" == "m" ]; then
			#	old_int=$INTERVAL
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				draw_banner "OSCILLATE" false true
				redraw_screen false 1 1 1 0
			elif [ "$c" == "q" ] || [ "$c" == "" ]; then
				break
			elif [ "$c" == "" ]; then
				echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
			fi
		fi

	done
	#espeak_say_natural " $INTERVAL of $EDO"
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

pcm_volume_change() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	if [ "$1" == "1" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "5" ]; then
			VOLUME="$(($VOLUME-5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			#LOCKED=false
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "2" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "95" ]; then
			VOLUME="$(($VOLUME+5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			#LOCKED=false
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "!" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "1" ]; then
			VOLUME="$(($VOLUME-1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			#LOCKED=false
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "@" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >$ALETHEIA/pipe$$ &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "99" ]; then
			VOLUME="$(($VOLUME+1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			#LOCKED=false
			draw_equalizer
			draw_volume 1
		fi
	fi
	read -n1 -t 0.1 key
	if [ "$key" != "" ]; then
		if [ "$key" == "1" ] || [ "$key" == "2" ] || [ "$key" == "!" ] || [ "$key" == "@" ]; then
			pcm_volume_change "$1"
			if [ "$?" != "200" ]; then
				return $?
			fi
		fi
	fi
	#espeak_say_natural " $VOLUME"
	return 200
}

master_volume_change() {
	leftvolume="`echo -n \"$MASTER_VOLUME_LEFT\" | cut -d'%' -f1`"
	if [ "$leftvolume" == "" ]; then
		leftvolume=0
	fi
	pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
	#if [ "$leftvolume" -lt "13" ]; then
	#	if [ "$1" == "2%+ 2%+" ]; then
	#		#MIXER_OUTPUT="`amixer set Master unmute -M 1%+,1%+ | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
	#		pactl set-sink-volume @DEFAULT_SINK@ +1% +1%
	#	elif [ "$1" == "2%- 2%-" ]; then
	#		#MIXER_OUTPUT="`amixer set Master unmute -M 1%-,1%- | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
	#		pactl set-sink-volume @DEFAULT_SINK@ -1% -1%
#
#		else
#			#MIXER_OUTPUT="`amixer set Master unmute -M $1 | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
#			pactl set-sink-volume @DEFAULT_SINK@ $1
#
#		fi
#	elif [ "$leftvolume" == "13" ]; then
#		if [ "$1" == "2%- 2%-" ]; then
#			#MIXER_OUTPUT="`amixer set Master unmute -M 1%-,1%- | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
#			pactl set-sink-volume @DEFAULT_SINK@ -1% -1%
#
#		else
#			#MIXER_OUTPUT="`amixer set Master unmute -M $1 | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
#			pactl set-sink-volume @DEFAULT_SINK@ $1
#
#		fi
#	else
#		#MIXER_OUTPUT="`amixer set Master unmute -M $1 | grep \"Front\" | grep \"\[\"`" 2>>/dev/null
		dir="`echo -ne \"$1\" | cut -b1`"
		num="`echo -ne \"$1\" | cut -b2`"
		if [ "$dir" == "+" ]; then
			if [ "$(($leftvolume+$num))" -lt "99" ]; then
				pactl set-sink-volume @DEFAULT_SINK@ $1
			else
				if [ "$num" == "1" ]; then
					pactl set-sink-volume @DEFAULT_SINK@ 100%
				else
					pactl set-sink-volume @DEFAULT_SINK@ 99%
				fi
			fi
		else
			if [ "$(($leftvolume-$num))" -gt "1" ]; then
				pactl set-sink-volume @DEFAULT_SINK@ $1
			else
				pactl set-sink-volume @DEFAULT_SINK@ 1%
			fi
		fi
#	fi
	#MASTER_VOLUME_LEFT="`echo \"$MIXER_OUTPUT\" | grep Left | cut -d'[' -f2 | cut -d']' -f1`"
	#MASTER_VOLUME_RIGHT="`echo \"$MIXER_OUTPUT\" | grep Right | cut -d'[' -f2 | cut -d']' -f1`"
	MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
	MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
	MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
	if [ "`echo -ne \"$MASTER_VOLUME_LEFT\" | cut -d'%' -f1`" -gt "100" ]; then
		MASTER_VOLUME_LEFT="100%"
		if [ "`echo -ne \"$MASTER_VOLUME_RIGHT\" | cut -d'%' -f1`" -gt "100" ]; then
			MASTER_VOLUME_RIGHT="100%"
		fi
		pactl set-sink-volume @DEFAULT_SINK@ 100% $MASTER_VOLUME_RIGHT
	fi
	if [ "`echo -ne \"$MASTER_VOLUME_RIGHT\" | cut -d'%' -f1`" -gt "100" ]; then
		MASTER_VOLUME_RIGHT="100%"
		pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_LEFT 100%
	fi

	draw_volume 2 3
	read -n1 -t 0.1 key
	if [ "$key" != "" ]; then
		if [ "$key" == "8" ] || [ "$key" == "9" ] || [ "$key" == "*" ] || [ "$key" == "(" ]; then
			master_volume_change "$1"
		fi
	fi
	#if [ "$VOICE_ENABLED" == true ]; then
	#	tmp="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
	#	tmp2="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
	#	if [ "$MASTER_VOLUME_LEFT" == "$MASTER_VOLUME_RIGHT" ]; then
	#		espeak_say_natural " $tmp"
	#	else
	#		espeak_say_natural " $tmp, $tmp2"
	#	fi
	#fi
}

fade_volume() {
	updown=""
	read -rsn1 -t 0.1 _input <$ALETHEIA/input_fifo
	if [ "$_input" != "" ]; then
		#input=$_input
		#if [ "$_input" == "y" ]; then
		#	echo -ne "$NOCOLOR"
		#	kill $MPLAYER_PID >/dev/null 2>/dev/null
		#	clear
		#	stty echo
		#	return $RETURN_QUIT
		#fi
		updown="$_input"
	fi
	draw_banner "FADE"
	espeak_say_natural "fade"
	PAUSE=false
	MUTE=false
	x=0
	if [ "$updown" == "" ]; then
		read -n1 updown
	fi
	down=false
	up=false
	if [ "$updown" == "j" ]; then
		down=true
		espeak_say_natural "down"
	elif [ "$updown" == "k" ]; then
		up=true
		espeak_say_natural "up"
	else
		espeak_say_natural "closed"
		draw_pitch
		return
	fi

	if [ "$down" == true ] && [ "$VOLUME" == "0" ]; then
		espeak_say_natural "closed"
		draw_pitch
		return
	fi
	if [ "$up" == true ] && [ "$VOLUME" == "100" ]; then
		espeak_say_natural "closed"
		draw_pitch
		return
	fi
	while [ "$x" -le "100" ] && [ "$VOLUME" -ge "0" ] && [ "$VOLUME" -le "100" ]; do
		if [ "$up" == true ]; then
			if [ "$VOLUME" == "100" ]; then
				#espeak_say_natural "$VOLUME"
				draw_pitch
				return
			fi
			VOLUME="$(($VOLUME+1))"
		elif [ "$down" == true ]; then
			if [ "$VOLUME" == "0" ]; then
				#espeak_say_natural "$VOLUME"
				draw_pitch
				return
			fi
			VOLUME="$(($VOLUME-1))"
		fi
		echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		draw_volume
		read -rsn1 -t 0.25 c
		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "3" ]; then
			espeak_say_natural "closed"
			draw_pitch
			break
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "FADE"
		elif [ "$c" == "c" ]; then
			if [ "$down" == true ]; then
				down=false
				up=true
			else
				down=true
				up=false
			fi
			espeak_say_natural "order reversed"
		elif [ "$c" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "FADING"
			redraw_screen false 1 1 0 1
		fi
		x=$(($x+1))
	done
	draw_pitch
	redraw_buffer
}

sleep_countdown() {
	local var="$1"
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 -t `calc "$1 * 60"` tmp
	else
		read -rsn1 -t `calc "$1 * 60"` tmp <$ALETHEIA/input_fifo
	fi
	if [ "$tmp" != "" ]; then
		espeak_say_natural "sleep canceled"
		tput cup $(($LINES-3))
		tput el
		echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
		echo -ne "${PADDING}${WHITE}Sleep canceled"
		draw_pitch
		return
	fi
	if [ "$SLEEPING" == true ]; then
		SLEEPING=false
		empty_pane
		tput cup $(($LINES-3))
		#espeak_say_natural "Going to sleep now..."
		echo -ne "${PADDING}${WHITE}Sleeping now..."
		x="$VOLUME"
		while [ "$x" -ge "0" ] && [ "$VOLUME" -gt "0" ]; do
			VOLUME="$(($VOLUME-1))"
			echo "volume $x 1" >"$ALETHEIA/pipe$$" &
			draw_volume
			if [ "$SLEEP_MODE" == "0" ]; then
				read -rsn1 -t 0.7 tmp
			else
				read -rsn1 -t 0.7 tmp <$ALETHEIA/input_fifo
			fi
			if [ "$tmp" != "" ]; then
				echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
				return
			fi
			x=$(($x-1))
		done

		kill $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$SUSPEND" == true ]; then
			systemctl suspend
		fi
		#killall $SCRIPTNAME 2>/dev/null >/dev/null
		exit 0
	fi
}

set_sleep() {
	if [ "$WEB_CLIENT" == "0" ]; then
		empty_pane
		draw_banner "SLEEP"
		espeak_say_natural "sleep"
		tput cup $(($LINES-3))
		echo -ne "$NOCOLOR${PADDING}${WHITE}How many minutes$BLUE? "
		answer="`read_line`"
	else
		answer="180"
	fi

	if [ "$answer" != "" ]; then
		if [ "`isnum \"$answer\"`" != "0" ]; then
			SLEEPING=true
			if [ "$WEB_CLIENT" == "0" ]; then
				empty_pane
				tput cup $(($LINES-3))
				espeak_say_natural "suspend?"
				echo -ne "${PADDING}${WHITE}Do you want to suspend$BLUE? "
				read -rsn1 suspend
			else
				suspend="y"
			fi
		
			if [ "$suspend" == "y" ] || [ "$suspend" == "Y" ]; then
				SUSPEND=true
			else
				SUSPEND=false
			fi
			tput cup $(($LINES-3))
			tput el
			if [ "$VOICE_ENABLED" == true ]; then
				if [ "$answer" != "1" ]; then
					#if [ "$WEB_CLIENT" == "0" ]; then
						#if [ "$SUSPEND" == true ]; then
						#	espeak_say_natural "Suspending in $answer minutes."
						#else
						#	espeak_say_natural "Sleeping in $answer minutes."
						#fi
					#else
					espeak_say_natural "sleep enabled"
					#fi
				else
					#if [ "$SUSPEND" == true ]; then
					#	espeak_say_natural "Suspending in $answer minute."
					#else
					#	espeak_say_natural "Sleeping in $answer minute."
					#fi
					espeak_say_natural "sleep enabled"
				fi
			fi
			if [ "$SUSPEND" == true ]; then
				echo -ne "${PADDING}${WHITE}Suspending in $BLUE$answer ${WHITE}minute"
			else
				echo -ne "${PADDING}${WHITE}Sleeping in $BLUE$answer ${WHITE}minute"
			fi
			if [ "$answer" != "1" ]; then
				echo -ne "s"
			fi
			PAUSE=false
			if [ "$MUTE" == true ]; then
				echo "mute" >$ALETHEIA/pipe$$ &
				MUTE=false
			fi
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_position
			sleep_countdown "$answer"
			sleep 1
			redraw_buffer
		else
			espeak_say_natural "closed"
			draw_pitch
			redraw_buffer
		fi
	else
		espeak_say_natural "closed"
		draw_pitch
		redraw_buffer
	fi
}

read_line() {
	local h=$1
	IFS=$'\n'
        line=""
        stty -echo
	if [ "$h" != "" ]; then
		x="$1"
	else
		read -n1 x
	fi
	if [ "$x" == "" ]; then
		unset IFS
		return
	fi
        if [ "$x" == "" ]; then
		unset IFS
                return
        fi

        echo -ne $x >/dev/stderr
	if [ "$VOICE_ENABLED" == true ]; then
		if [ "$x" == "-" ]; then
			espeak_say_natural "negative"
		elif [ "$x" == "." ]; then
			espeak_say_natural "point"
		else
			espeak_say_natural " $x"
		fi
	fi


        if [ "$x" != "" ]; then
                line="$x"
	fi

        read -n1 x
        while [ ! -z $x ]; do
                if [ "$x" == "" ]; then
			unset IFS
                        return
                fi
                if [ "$x" == "" ]; then
                        if [ "`echo $line | wc -c`" -lt "2" ]; then
				read -n1 x
				continue
                        fi
                        line="`echo $line | rev | cut -c2- | rev`"
                        echo -ne "\b \b" >/dev/stderr
                        read -n1 x
                        continue
                elif [ "$x" == "" ]; then
                        echo -n $line
			unset IFS
                        return
		else
                        line="$line$x"
                fi

                echo -ne "$x" >/dev/stderr
		if [ "$VOICE_ENABLED" == true ]; then
			if [ "$x" == "-" ]; then
				espeak_say_natural "negative"
			elif [ "$x" == "." ]; then
				espeak_say_natural "point"
			else
				espeak_say_natural " $x"
			fi
		fi
                read -n1 x
        done

	unset IFS
        echo -n "$line"
}

read_number() {
	stty -echo
	number="0"
	echo -ne "$number" >/dev/stderr
	read -n1 x
	if [ "$x" == "" ]; then
		return
	fi
	while [ ! -z "$x" ]; do
		if [ "$x" == "j" ]; then
			if [ "$number" -gt "-12" ]; then
				for i in `seq 1 ${#number}`; do
					echo -ne "\b" >/dev/stderr
					tput el >/dev/stderr
				done
				number="$(($number-1))"
				echo -ne $number >/dev/stderr
				espeak_say_natural " $number"
			fi
		elif [ "$x" == "k" ]; then
			if [ "$number" -lt "12" ]; then
				for i in `seq 1 ${#number}`; do
					echo -ne "\b" >/dev/stderr
					tput el >/dev/stderr
				done
				number="$(($number+1))"
				echo -ne $number >/dev/stderr
				espeak_say_natural " $number"
			fi
		elif [ "$x" == "-" ]; then
			for i in `seq 1 ${#number}`; do
				echo -ne "\b" >/dev/stderr
				tput el >/dev/stderr
			done
			echo -ne $x >/dev/stderr
			if [ "$VOICE_ENABLED" == true ]; then
				#espeak-ng -s$VOICE_SPEED -v$VOICE_GENDER -a$VOICE_VOLUME -p$VOICE_PITCH --punct " $x" &
				espeak_say_natural " $x"
				#gtts-cli " $x" | play -t mp3 - >/dev/null 2>/dev/null &
			fi
			tmp="`read_line`"
			#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			#killall play >/dev/null 2>/dev/null
			#killall gtts-cli >/dev/null 2>/dev/null
			if [ "$tmp" == "" ]; then
				echo -ne ""
				return
			fi
			if [ "`isnum \"$tmp\"`" != "0" ]; then
				echo -ne "-$tmp"
				return
			fi
		elif [ "`isnum \"$x\"`" != "0" ]; then
			for i in `seq 1 ${#number}`; do
				echo -ne "\b" >/dev/stderr
				tput el >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			espeak_say_natural " $x"
			#tmp="`read_line`"
			tmp=""
			if [ "$tmp" == "" ]; then
				echo -ne "$x"
				return
			elif [ "`isnum \"$tmp\"`" != "0" ]; then
				echo -ne "$x$tmp"
				return
			fi
		elif [ "$x" == "" ]; then
			echo -e ""
			return
		elif [ "$x" == "q" ]; then
			echo -e ""
			return
		elif [ "$x" == "" ]; then
			break
		fi
		read -rsn1 x
	done
	echo -ne "$number"
	return
}

reset_dimensions() {
	local norender=$1
	new_LINES=`tput lines`
	new_COLS=`tput cols`
	if [ "$LINES" != "$new_LINES" ] || [ "$COLS" != "$new_COLS" ]; then
		DIMENSIONS_RESET=true
		COLS=$new_COLS
		LINES=$new_LINES
		PANE_WIDTH="$(($COLS - 1 - 1))"
	fi
	LINES=$new_LINES
	COLS=$new_COLS
	#if [ "$new_COLS" -lt 25 ]; then
	#	echo -ne "${RED}Error: Columns < 25"
	#	read -n1 throwaway
	#	clear
	#else
		#if [ "$WEB_CLIENT" == "0" ]; then
	if [ "$norender" == "false" ] || [ "$norender" == "" ]; then
		render_help_screen
		render_voice_settings_screen
		render_repeat_help_screen
	fi
		#fi
	#fi
}

redraw_screen() {
	#reset_dimensions
	#if [ "$WEB_CLIENT" == "0" ]; then
		reset_buffer
	#fi

	if [ "$2" == "" ]; then
		draw_volume
		draw_equalizer
		draw_pitch
		draw_position
	else
		if [ "$2" == "1" ]; then
			draw_volume
		fi
		if [ "$3" == "1" ]; then
			draw_equalizer
		fi
		if [ "$4" == "1" ]; then
			draw_pitch
		fi
		if [ "$5" == "1" ]; then
			draw_position
		fi
	fi

	redraw_buffer
	tput cup 1
	tput el
	tput cup $(($LINES-2))
	tput el

	#if [ "$1" == "false" ] || [ "$1" == "" ]; then
	#	render_help_screen
	#fi
}

winch_window() {
	draw_wait
	espeak_say_natural "screen redrawn"
	tput civis
	reset_dimensions
	redraw_screen #false
	if [ "$MUTE" == true ]; then
		draw_banner "MUTE"
	elif [ "$PAUSE" == true ]; then
		draw_banner "PAUSE"
	fi
}

reset_buffer() {
	number_per_page="$(($LINES-4))"
	original_number_per_page="$number_per_page"

	BUFFER=""

#	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
#		number_per_page="$TOTAL_QUEUE"
#		FLAGGED=true
#	fi

	HALF="$(($POSITION % $number_per_page + $(($number_per_page/2 + 1))))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		HALF="1"
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
		number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$(($number_per_page*2 - 1))" ]; then
		HALF="$(($POSITION-$original_number_per_page/2))"
	fi

	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
		number_per_page="$TOTAL_QUEUE"
		FLAGGED=true
	fi

	half_page="$(($number_per_page/2))"

	if [ "$POSITION" -gt "$half_page" ]; then
		if [ "$(($number_per_page % 2))" != "" ]; then
			HALF=$((($POSITION - ($half_page))))
		else
			HALF=$((1+($POSITION - ($half_page))))
		fi

		if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
		fi
	fi

	HALF_OFFSET="0"
	if [ "$HALF" -lt "1" ]; then
		HALF_OFFSET="$(($HALF*-1)) - 1"
		HALF="1"
	fi

	COLOR2="$BLUE"

	pos_on_page=0
	#if [ "$ONLY_DISPLAY_SONG" == true ]; then
		#line="$TITLE"
		#offset="$(($COLS - 1 - 1))"
		#line="$(echo -ne "$line" | sed -e 's/^ .*//g' | cut -b 1-$(($offset)))"
		#BUFFER="`printf '%*s' $(($LINES-4)) | sed -e \"s/ /$(tput el)\n/g\"`${PADDING}$BLUE$artist $WHITE- $song\n`tput el`\n"

	#else
	_last=$(($HALF+($number_per_page)-$HALF_OFFSET))
	#FIXME
	#lines="`echo -e \"$QBUFFER\" | sed -n \"$HALF,${_last}p\"`"
	diff=$(($_last-$HALF))
	highest=1
		#for i in `seq $HALF $(($HALF + $(($number_per_page-1)) - $HALF_OFFSET))`; do
		if [ "$TOTAL_QUEUE" -lt "$diff" ]; then
			diff="$TOTAL_QUEUE"
		fi

		for i in `seq 1 $(($diff))`; do
			#line="`echo -e \"$QBUFFER\" | sed -n ${i}p`"
			#line="`echo -e \"$lines\" | sed -n ${i}p`"
			line="`echo -ne \"${queue_array[$(($i+$HALF-2))]}\"`"
			new_line="$line"
			#glines="`echo -ne \"$lines\" | rev | cut -d'/' -f1 | rev | sed \"s/ - //g\" | cut -d'' -f1`"
			#IFS=$'\n'
			#tmpo="`echo -ne \"$QBUFFER\" | rev | cut -d'/' -f1 | rev | sed \"s/ - //g\" | cut -d'' -f1`"
			#for xyz in "`echo -ne \"$QBUFFER\" | rev | cut -d'/' -f1 | rev | sed \"s/ - //g\" | cut -d'' -f1`"; do
			#	if [ "${#xyz}" -gt "$highest" ]; then
			#		highest=${#xyz}
			#	fi
			#done
			#unset IFS
			#highest="`echo -ne \"$tmpo\" | wc -L`"
			pos=$(($i-1+$HALF))
			orig_line="$line"
			# Too slow. Needs an option to cache all at once
			USE_ID_TAGS=0
			line="`echo \"$line\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
			if [ "$ONLY_DISPLAY_SONG" == false ]; then
				if [ "$USE_ID_TAGS" == "1" ]; then
					#op="`exiftool -Artist -Title \"$line\"`"
					#artist="`echo -ne \"$op\" | head -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
					#song="`echo -ne \"$op\" | tail -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
					if [ "$pos" == "$POSITION" ]; then
						line="$ARTIST - $SONG"
					else

						op="`exiftool -Artist -Title \"$orig_line\"`"
						if [ "$op" != "" ]; then
							artist="`echo -ne \"$op\" | head -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
							song="`echo -ne \"$op\" | tail -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
							line="$artist - $song"
						else
							if [ "`echo -ne \"$line\" | grep \" - \"`" != "" ]; then
								artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
								song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
								line="$artist - $song"
							fi

						fi
					fi
				else
					#line="`echo \"$line\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
					if [ "`echo -ne \"$line\" | grep \" - \"`" != "" ]; then
						artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
						song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
						line="$artist - $song"
					#else
					#	line="`echo \"$line\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
					fi
				fi
			fi
			if [ "$pos" == "$POSITION" ]; then
				REPLACE="$BLUE_BLACK"
			else
				REPLACE=""
			fi
			ext="`echo -ne \"$orig_line\" | rev | cut -d'.' -f1 | rev`"
			filename_without_ext="`echo -ne \"$orig_line\" | rev | cut -d'.' -f2- | rev`"
			if [ -e "$filename_without_ext.repeat.$ext" ]; then
				REP="$BLUE"
			else
				REP=""
			fi
			if [ -e "$orig_line.locked" ]; then
				if [ -e "$orig_line.repeats" ]; then
					
					FLAGGY="$BLUE$REPLACE${WHITE}$REP#"
				else
					FLAGGY="$BLUE${REPLACE}${WHITE}$"
				fi
			else
				if [ -e "$orig_line.repeats" ]; then
					FLAGGY="$BLUE$REPLACE${WHITE}$REP&"
				else
					FLAGGY="${BLUE} "
				fi
			fi
			#if [ -e "$line.repeats" ]; then
			#	FLAGGY="$BLUE#"
			#fi

			#line="`echo \"$line\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
			#if [ "$ONLY_DISPLAY_SONG" == true ]; then
			#	line="`echo -n \"$line\" | cut -d'-' -f2 | sed -e \"s/^[ ]*//g\"`"
			#fi
			
			if [ "$pos" -lt "$POSITION" ]; then
				COLOR="$WHITE"
				COLOR3="$WHITE"
				COLOR4="$WHITE"
			elif [ "$pos" -gt "$POSITION" ]; then
				COLOR="$WHITE"
				COLOR3="$WHITE"
				COLOR4="$WHITE"
			else
				LOCKING_POS=$pos_on_page
				COLOR="$WHITE"
				COLOR3="$BLUE"
				COLOR4="$BLUE"
			fi

			#tput setab 0
			#for i in `seq 1 25`; do
			#	tput setaf $i
			#	echo -e "$i"
			#done

			#sleep 45

			if [ "$pos" -lt "10" ] && [ "$TOTAL_QUEUE" -gt "9" ]; then
				pad="0"
				display_pad="${GREEN} $NOCOLOR"
			#elif [ "$pos" -lt "100" ]; then
			#	pad=""
			else
				pad=""
				display_pad=""
			fi

			#if [ "$pos" -lt "10" ]; then
			#	i=" $pos"
			#	pad=""
			#fi

			pos_on_page=$(($pos_on_page+1))
			
			offset="$(($COLS - 11 - ${#pos} - ${#pad}))"
			#if [ "${#line}" -gt "$offset" ]; then
			#	cut=true
			#else
			#	cut=false
			#fi
			if [ "${#line}" -gt "$offset" ]; then
				line="$(echo -ne "$line" | sed -e 's/^ .*//g' | cut -b 1-$(($offset-1)))…"
			#else
			#	line="$(echo -ne "$line" | sed -e 's/^ .*//g' | cut -b 1-$offset)"
			fi
			#FIXME
			#if [ "`echo -ne \"$line\" | grep \" - \"`" != "" ]; then
			#	new_artist="`echo -ne \"$line\" | sed \"s/ - //g\" | cut -d'' -f1`"
			#	if [ "$new_artist" != "" ]; then
			#		new_song="`echo -ne \"$line\" | sed \"s/ - //g\" | cut -d'' -f2`"
			#	fi
			#	redone_line="$BLUE$new_artist $WHITE- $BLUE$new_song"
			#else
			#	redone_line="$BLUE$line"
			#fi
			
			#testing="`echo -ne \"$line\" | sed \"s/ - //g\" | cut -d'' -f1`"
			#if [ "${#testing}" -gt "$highest" ]; then
			#	highest=${#testing}
			#fi
			#if [ "$cut" == true ]; then
			#	line="$(echo -ne "$line" | cut -b 1-$(($offset-3)))"
			#	if [ "`echo -ne \"$line\" | rev | cut -b1`" == " " ]; then
			#		line="$(echo -ne \"$line\" | cut -b 1-$(($offset-1)))"
			#		line="$line...."
			#	else
			#		line="$line..."
			#	fi
			#fi
			#artist="`echo -e \"$line\" | sed -e \"s/ - //g\" | cut -d '' -f1`"
			#song="`echo -e \"$line\" | sed -e \"s/ - //g\" | cut -d '' -f2`"
			#new_line="`echo -e \"$lines\" | sed -n ${i}p`"
			#new_line="`echo -ne \"${queue_array[$(($i+$HALF-1))]}\"`"
			#new="`ls -1 \"${new_line}*:\"`" >/dev/null 2>/dev/null
			#if [ "$new" != "" ]; then
			#if [ -e "$new_line.bpm" ]; then
			#	BPM="`cat \"$new_line.bpm\"`"
			#else
			#	BPM="`sox -V0 \"$new_line\" -t raw -r 44100 -e float -c 1 - | bpm`" 2>/dev/null
			#	echo -ne "$BPM" >"$new_line.bpm"
			#fi
			if [ -e "$new_line.time" ]; then
				song_length="`cat \"$new_line.time\"`"
				if [ "$song_length" == "" ]; then
					song_length="--:--"
				fi
			else
				song_length="`ffprobe -i \"$new_line\" -show_entries format=duration -v quiet -of csv=\"p=0\" | cut -d'.' -f1`"
				if [ "$song_length" == "" ]; then
					song_length="--:--"
				else
					song_length="`date -u -d @$song_length +%M:%S`"
					echo -ne "$song_length" >"$new_line.time"
				fi
			fi
			one="`echo -ne \"$song_length\" | cut -d':' -f1`"
			two="`echo -ne \"$song_length\" | cut -d':' -f2`"
	#		artistx="`echo -ne \"$line\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev | sed \"s/ - //g\" | cut -d'' -f1`"
	#		songx="`echo -ne \"$line\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev | sed \"s/ - //g\" | cut -d'' -f2`"
	#		if [ "$highest" -gt "16" ]; then
	#			highest=16
	#		fi
			#offseto="$(($COLS-1-6-${#pos}-${#pad}-1-${#artistx}-($highest+$CENTER_BAR_POSITION-${#artistx})-2-2-${#song_length}-1))"
	#		offseto="$(($COLS-${#pos}-${#pad}-13-${#artistx}-($highest+$CENTER_BAR_POSITION-${#artistx})-${#song_length}))"
	#		songx="`echo -ne \"$songx\" | cut -c 1-$offseto`"
			#if [ "$highest" -gt "$offseto" ]; then
			#	offsetp=
	#		artistx="`echo -ne \"$artistx\" | cut -c 1-$((16+$CENTER_BAR_POSITION))`"
	#		if [ "$pos" -gt "9999" ]; then
	#			highest=$(($highest-3))
	#		elif [ "$pos" -gt "999" ]; then
	#			highest=$(($highest-2))
	#		elif [ "$pos" -gt "99" ]; then
	#			highest=$(($highest-1))
	#		fi
			#one="${one#"${one%%[!0]*}"}"
			if [ "$PANELS_ENABLED" == true ] && [ "$pos" == "$POSITION" ]; then
				BUFFER="$BUFFER$BLUE_BLACK$PADDING$FLAGGY $display_pad$pos $line`printf '%*s' $(($COLS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-${#one}-3))`$one$WHITE_BLACK:$BLUE_BLACK$two$RIGHTPADDING`tput sgr0`\n"
				
			else
				if [ "$PANELS_ENABLED" == false ]; then
					if [ "$pos" == "$POSITION" ]; then
						#song_length="`echo -ne \"$song_length\" | sed \"s/:/$(echo -ne \"$WHITE\"):$(echo -ne \"$BLUE\")/g\"`"
						BUFFER="$BUFFER$PADDING$BLUE$FLAGGY $BLUE$display_pad$BLUE$pos $line`printf '%*s' $(($COLS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-${#one}-3))`$BLUE$BLUE$one$WHITE:$BLUE$two$RIGHTPADDING\n"
					else
						#song_length="`echo -ne \"$song_length\" | sed \"s/:/$(echo -ne \"$BLUE\"):$(echo -ne \"$WHITE\")/g\"`"
						BUFFER="$BUFFER$PADDING$WHITE$FLAGGY $BLUE$display_pad$BLUE$pos $COLOR$line`printf '%*s' $(($COLS-${#pos}-${#pad}-(${#PADDING}*2)-2-1-${#line}-${#one}-3))`$WHITE$one:$two$RIGHTPADDING\n"
					fi
				else
					BUFFER="$BUFFER$PADDING$WHITE$COLOR2$FLAGGY$BLUE $display_pad$pos $COLOR$line`tput sgr0``tput el`\n"
				fi
			fi
		done
}


cleanup_sigint() {
	#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
	killall espeak-ng >/dev/null 2>/dev/null
	if [ "$WEB_CLIENT" == "1" ]; then
		killall node >/dev/null 2>/dev/null
	fi
	killall play >/dev/null 2>/dev/null
	kill $MPLAYER_PID >/dev/null 2>/dev/null

	#tmp_volume_left="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
	#tmp_volume_right="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
	#if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
		#amixer sset Master $MASTER_VOLUME_LEFT,$MASTER_VOLUME_LEFT >/dev/null 2>/dev/null
	#	pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_LEFT >/dev/null 2>/dev/null
	#elif [ "$tmp_volume_left" -lt "$tmp_volume_right" ]; then
		#amixer sset Master $MASTER_VOLUME_RIGHT,$MASTER_VOLUME_RIGHT >/dev/null 2>/dev/null
	#	pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_RIGHT >/dev/null 2>/dev/null
	#fi
	#echo -e "$QBUFFER" >"$ALETHEIA/queue"
	if [ "$WEB_CLIENT" == "1" ]; then
		echo -ne "" >"$ALETHEIA/current_song"
	fi
	echo -ne "$NOCOLOR"
	clear
	tput cnorm
	stty echo
	#stty ixon
	#kill $MPLAYER_PID 2>/dev/null >/dev/null
	rm -f "$ALETHEIA/pipe$$"
	#killall aletheia >/dev/null 2>/dev/null
	exit 0
}

cleanup() {
	#FIXME
	killall espeak-ng node play >/dev/null 2>/dev/null

	tmp_volume_left="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
	tmp_volume_right="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
	if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
		#amixer sset Master $MASTER_VOLUME_LEFT,$MASTER_VOLUME_LEFT >/dev/null 2>/dev/null
		pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_LEFT >/dev/null 2>/dev/null
	elif [ "$tmp_volume_left" -lt "$tmp_volume_right" ]; then
		#amixer sset Master $MASTER_VOLUME_RIGHT,$MASTER_VOLUME_RIGHT >/dev/null 2>/dev/null
		pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_RIGHT >/dev/null 2>/dev/null
	fi
	#echo -e "$QBUFFER" >"$ALETHEIA/queue"
	echo -ne "" >"$ALETHEIA/current_song"
	echo -ne "$NOCOLOR"
	#clear
	tput cnorm
	stty ixon
	rm -f "$ALETHEIA/pipe$$"
	kill $MPLAYER_PID 2>/dev/null >/dev/null
	# FIXME
	#killall aletheia >/dev/null 2>/dev/null
	exit 0
}

redraw_buffer() {
	#echo -ne "$NOCOLOR"
	tput cup 1
	tput el
	tput cup $(($LINES-2))
	tput el
	#echo -ne "$BLUE\033(0`printf '%*s' $(($COLS)) | tr ' ' 'q'`\033(B"
	#echo -ne "$BLUE$PANEL_HORIZONTAL_DIVIDER"
	#p=$((${#PADDING}+${#pos}+${#pad}+3+${#artistx}+($highest+1+$CENTER_BAR_POSITION-${#artistx})))
	#tput cup 1 $p
	#echo -ne "$TBAR"
	#tput cup 1 $(($COLS-8))
	#echo -ne "$TBAR"
	#tput el
	tput cup 2
	echo -ne "$BUFFER"

	if [ "$number_per_page" -lt "$TOTAL_QUEUE" ]; then
		number_per_page=$TOTAL_QUEUE
	fi

	if [ "$number_per_page" == "" ] || [ "$number_per_page" == "1" ]; then
		empty_pane 3
	fi

	#if [ "$number_per_page" -lt "$original_number_per_page" ]; then
	#	empty_pane "$(($number_per_page + 2))"
	#fi
	empty_pane $(($number_per_page+2))

	if [ "$TOTAL_QUEUE" -lt "$(($LINES-4))" ]; then
		empty_pane $(($TOTAL_QUEUE+2))
	fi

	tput cup $(($LINES-2))
	#echo -ne "$BLUE\033(0`printf '%*s' $(($COLS)) | tr ' ' 'q'`\033(B"
	#echo -ne "$BLUE$PANEL_HORIZONTAL_DIVIDER"
	#tput cup $(($LINES-2)) $(($COLS-8))
	#echo -ne "$BOTTOM_TBAR"
	#tput cup $(($LINES-2)) $p
	#echo -ne "$BOTTOM_TBAR"
	#tput el
}

empty_pane() {
	tput civis
	lineno=$1
	pane="$(($LINES-2))"

	if [ "$lineno" == "" ]; then
		lineno="1"
	fi

	tput sgr0
	while [ "$lineno" -le "$pane" ]; do
		tput cup $lineno
		tput el
		lineno="$(($lineno+1))"
	done
}

draw_volume() {
	#if [ "$WEB_CLIENT" == "0" ]; then
		tput cup 0

		tmp_volume_left="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
		tmp_volume_right="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
		if [ "$tmp_volume_left" == "" ]; then
			tmp_volume_left="0"
			tmp_volume_right="0"
		fi
		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		#if [ "$1" == "1" ]; then
		#	replace_vol="$GREEN_BLACK"
		#	unset replace_left
		#	unset replace_right
		#elif [ "$1" == "2" ] || [ "$1" == "3" ]; then
		#	unset replace_vol
		#	if [ "$1" == "2" ]; then
		#		replace_left="$GREEN_BLACK"
		#	else
		#		unset replace_left
		#	fi
		#	if [ "$2" == "3" ]; then
		#		replace_right="$GREEN_BLACK"
		#	else
		#		unset replace_right
		#	fi
		#else
		#	unset replace_vol
		#	unset replace_left
		#	unset replace_right
		#fi
		#echo -ne "$BLUE_BLACK$PADDING$replace_vol$VOLUME$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$replace_left$tmp_volume_left$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$replace_right$tmp_volume_right"
		echo -ne "$BLUE_BLACK$PADDING$VOLUME$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_left$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_right"
		printf '%*s' $(($COLS - (${#CORNER_DIVIDER}*2) - ${#equal} -${#VOLUME} - (${#PADDING}*2) - ${#tmp_volume_left} - ${#tmp_volume_right}))
		echo -ne "$NOCOLOR"
	#fi
}

draw_position() {
	#if [ "$WEB_CLIENT" == "0" ]; then
		local equalizer=$1
		RIGHT_BANNER_WIDTH=0
		POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
		tput cup $LINES $(($COLS-${#POSITION} - ${#TOTAL_QUEUE} - 1 - (${#CORNER_DIVIDER}*2) - ${#RIGHTPADDING}))
		if [ "$LOOP" == true ]; then
			center="1"
		elif [ "$LOOP_ARTIST" == true ]; then
			center="2"
		elif [ "$TRACK_RANDOM" == true ]; then
			center="3"
		elif [ "$ONLY_LOCKED" == true ]; then
			center="4"
		else
			center="0"
		fi
		echo -ne "$BLUE_BLACK$POSITION$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$TOTAL_QUEUE$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$center$RIGHTPADDING$NOCOLOR"
		return
	#fi
}

set_only_display_song() {
	if [ "$ONLY_DISPLAY_SONG" == true ]; then
		ONLY_DISPLAY_SONG=false
		#draw_banner "PARTIAL"
		espeak_say_natural "partial"
	else
		ONLY_DISPLAY_SONG=true
		#draw_banner "FULL"
		espeak_say_natural "full"
	fi
	#sleep 0.25
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
		#redraw_buffer
		#draw_pitch
		#draw_position
	fi
}

yt_artist() {
	which yt_artist >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "artist" yt_artist "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`" 1
		else
			tmux new-session -s "artist" yt_artist "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`" 0
		fi
		tput civis
		espeak_say_natural "closed"
		redraw_screen true
	else
		espeak_say_natural "feature not installed"
	fi
}

yt_search() {
	which yt_search >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "search" yt_search 1 "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		else
			tmux new-session -s "search" yt_search 0 "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		fi
		espeak_say_natural "closed"
		tput civis
		redraw_screen true
	else
		espeak_say_natural "feature not installed"
	fi
}

tmux_attach() {
	which yt_search >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		# FIXME
		espeak_say_natural "attached"
		tmux attach >/dev/null 2>/dev/null
		tput civis
		espeak_say_natural "closed"
		draw_pitch
		draw_position
		redraw_screen true
	else
		espeak_say_natural "feature not installed"
	fi
}

enable_panels() {
	#draw_wait
	if [ "$PANELS_ENABLED" == true ]; then
		espeak_say_natural "panels disabled"
		PANELS_ENABLED=false
		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37m'
			BLUE_BLACK='\033[1;37m'
			RED_BLACK='\033[1;37m'
			CYAN_BLACK='\033[1;37m'
			WHITE_BLACK='\033[1;37m'
		else
			GREEN_BLACK='\033[1;32m'
			BLUE_BLACK='\033[1;34m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			WHITE_BLACK='\033[1;37m'
		fi
	else
		espeak_say_natural "panels enabled"
		PANELS_ENABLED=true
		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32;1;40m'
			BLUE_BLACK='\033[1;34;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		fi
	fi
	if [ "$BLACK_BACKGROUND" == true ]; then
		WHITE='\033[1;37m'
		LIGHTWHITE='\033[0;37m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;37;1;40m'
		else
			WHITE_BLACK='\033[1;37m'
		fi
	else
		WHITE='\033[1;30m'
		LIGHTWHITE='\033[0;30m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;30;1;40m'
		else
			WHITE_BLACK='\033[1;30m'
		fi
	fi
	reset_buffer
	draw_volume
	draw_equalizer
	if [ "$1" == true ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
}

toggle_colors() {
	draw_wait
	if [ "$COLORS_ENABLED" == false ]; then
		COLORS_ENABLED=true
		RED='\033[1;31m'
		LIGHTRED='\033[0;31m'
		GREEN='\033[1;32m'
		BLUE='\033[1;34m'
		YELLOW='\033[1;33m'
		LIGHTBLUE='\033[1;34m'
		PURPLE='\033[1;35m'
		CYAN='\033[1;36m'
		LIGHTCYAN='\033[0;36m'
		LIGHTRED='\033[0;31m'
		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;32;1;40m'
			BLUE_BLACK='\033[1;34;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32m'
			BLUE_BLACK='\033[1;34m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			WHITE_BLACK='\033[1;37m'
		fi
	else
		COLORS_ENABLED=false
		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;37m'
			BLUE_BLACK='\033[1;37m'
			RED_BLACK='\033[1;37m'
			CYAN_BLACK='\033[1;37m'
			WHITE_BLACK='\033[1;37m'
		fi
		#GREEN_BLACK='\033[1;37;1;40m'
		#BLUE_BLACK='\033[1;37;1;40m'
		#RED_BLACK='\033[1;37;1;40m'
		#CYAN_BLACK='\033[1;37;1;40m'
		RED='\033[1;37m'
		LIGHTRED='\033[0;37m'
		GREEN='\033[1;37m'
		BLUE='\033[1;37m'
		YELLOW='\033[1;37m'
		LIGHTBLUE='\033[1;37m'
		PURPLE='\033[1;37m'
		CYAN='\033[1;37m'
	fi
	if [ "$BLACK_BACKGROUND" == true ]; then
		WHITE='\033[1;37m'
		LIGHTWHITE='\033[1;37m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;37;1;40m'
		else
			WHITE_BLACK='\033[1;37m'
		fi
	else
		WHITE='\033[1;30m'
		LIGHTWHITE='\033[1;30m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;30;1;40m'
		else
			WHITE_BLACK='\033[1;30m'
		fi
	fi
	#if [ "$WEB_CLIENT" == "0" ]; then
		render_help_screen
		render_voice_settings_screen
		render_repeat_help_screen
	#fi
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	if [ "$COLORS_ENABLED" == false ]; then
		espeak_say_natural "color disabled"
	else
		espeak_say_natural "color enabled"
	fi
}

invert_colors() {
	draw_wait
	if [ "$BLACK_BACKGROUND" == true ]; then
		BLACK_BACKGROUND=false
	else
		BLACK_BACKGROUND=true
	fi
	if [ "$BLACK_BACKGROUND" == true ]; then
		WHITE='\033[1;37m'
		LIGHTWHITE='\033[0;37m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;37;1;40m'
		else
			WHITE_BLACK='\033[1;37m'
		fi
	else
		WHITE='\033[1;30m'
		LIGHTWHITE='\033[0;30m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;30;1;40m'
		else
			WHITE_BLACK='\033[1;30m'
		fi
	fi
	#if [ "$WEB_CLIENT" == "0" ]; then
		render_help_screen
		render_voice_settings_screen
		render_repeat_help_screen
	#fi
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	espeak_say_natural "color inverted"
}

draw_wait() {
	if [ "$1" == "" ] || [ "$1" == false ]; then
		echo -ne "$NOCOLOR"
		clear
	fi
	tput cup $((`tput lines`/2)) $(((`tput cols`/2)-5))
	echo -ne "$NOCOLOR${WHITE}-- ${BLUE}WAIT ${WHITE}--$NOCOLOR"
	espeak_say_natural "wait" false true
}

draw_animation() {
	flaggy=false
	x=1
	#if [ "$(($COLS%2))" == "0" ]; then
	#	tput cup $(($LINES/2)) $(($COLS/2-2))
	#else
	#	tput cup $(($LINES/2)) $(($COLS/2-4))
	#fi
	#tput cup $LINES 1
	#echo -ne "$BLUE["
	#tput cup $LINES 9
	#echo -ne "$BLUE]$WHITE"
	#tput cup $LINES 2
	#tput cup $(($LINES/2)) $(( ($COLS/2) - 5 ))
	tput cup $(($LINES-2)) $(( ($COLS/2) - 5 ))
	echo -ne "$BLUE["
	#tput cup $(($LINES/2)) $(( ($COLS/2) + 5 ))
	tput cup $(($LINES-2)) $(( ($COLS/2) + 5 ))
	echo -ne "$BLUE]$WHITE"
	#tput cup $(($LINES/2)) $(( ($COLS/2) - 4 ))
	tput cup $(($LINES-2)) $(( ($COLS/2) - 4 ))
}

tmp_func() {
#####
	if [ "$WEB_CLIENT" == "1" ]; then
		number_per_page="4"
		original_number_per_page="$number_per_page"

		BUFFER=""

	#	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
	#		number_per_page="$TOTAL_QUEUE"
	#		FLAGGED=true
	#	fi

		HALF="$(($POSITION % $number_per_page + $(($number_per_page/2 + 1))))"

		if [ "$POSITION" -lt "$number_per_page" ]; then
			HALF="1"
		elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
			number_per_page="$original_number_per_page"
		elif [ "$POSITION" -gt "$(($number_per_page*2 - 1))" ]; then
			HALF="$(($POSITION-$original_number_per_page/2))"
		fi

		if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi

		half_page="$(($number_per_page/2))"

		if [ "$POSITION" -gt "$half_page" ]; then
			if [ "$(($number_per_page % 2))" != "" ]; then
				HALF=$((($POSITION - ($half_page))))
			else
				HALF=$((1+($POSITION - ($half_page))))
			fi

			if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
			fi
		fi

		HALF_OFFSET="0"
		if [ "$HALF" -lt "1" ]; then
			HALF_OFFSET="$(($HALF*-1)) - 1"
			HALF="1"
		fi

		COLOR2="$BLUE"

		pos_on_page=0
		#if [ "$ONLY_DISPLAY_SONG" == true ]; then
			#line="$TITLE"
			#offset="$(($COLS - 1 - 1))"
			#line="$(echo -ne "$line" | sed -e 's/^ .*//g' | cut -b 1-$(($offset)))"
			#BUFFER="`printf '%*s' $(($LINES-4)) | sed -e \"s/ /$(tput el)\n/g\"`${PADDING}$BLUE$artist $WHITE- $song\n`tput el`\n"

		#else
		_last=$(($HALF+($number_per_page)-$HALF_OFFSET))
		if [ "$(($_last-$HALF))" -lt "5" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			if [ "$POSITION" == "$TOTAL_QUEUE" ] || [ "$POSITION" == "$(($TOTAL_QUEUE-1))" ]; then
				HALF=$(($_last-5))
			fi
		fi
		#lines="`echo -e \"$QBUFFER\" | sed -n \"$HALF,${_last}p\"`"
		if [ "$HALF" == "1" ]; then
			HALF=2
			_last=$((${_last}+1))
		fi
		lines="`printf '%s\n' \"${queue_array[@]}\" | sed -n \"$(($HALF-1)),$((${_last}-1))p\"`"
		diff=$(($_last-$HALF))
		if [ "$POSITION" -lt "3" ]; then
			pos=$POSITION
		else
			pos=2
		fi
		echo -ne "$lines" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/\n/<br\/>/g" >"$ALETHEIA/current_queue"
		if [ "$POSITION" -lt "3" ]; then
			pos=$(($pos-1))
		elif [ "$POSITION" -gt "$(($TOTAL_QUEUE-1))" ]; then
			pos=$(($pos+1))
		fi
		if [ "$POSITION" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=4
		elif [ "$POSITION" == "$(($TOTAL_QUEUE-1))" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=3
		fi
		echo -ne "$pos" >"$ALETHEIA/current_pos"
	fi
}

say_locked_and_loops() {
	while [ true ]; do
		ps -p $play_pid >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	espeak_say_natural "locked" true
	espeak_say_natural "$INTERVAL" true
	espeak_say_natural "`echo -ne \"$REPEATS\" | wc -l`" true
       	espeak_say_natural "loops" true 
}

say_unlocked_and_loops() {
	while [ true ]; do
		ps -p $play_pid >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	espeak_say_natural "unlocked" true
	espeak_say_natural "`echo -ne \"$REPEATS\" | wc -l`" true
	espeak_say_natural "loops" true 
}

say_locked_and_no_loops() {
	while [ true ]; do
		ps -p $play_pid >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	espeak_say_natural "locked" true
	espeak_say_natural "`echo -ne \"$INTERVAL\" | sed \"s/\-/negative /g\"`" true
	espeak_say_natural "$EDO"
	espeak_say_natural "no loops" true
}

say_unlocked_and_no_loops() {
	while [ true ]; do
		ps -p $play_pid >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	espeak_say_natural "unlocked" true
	espeak_say_natural "no loops" true 
}

jump_to_first_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	#JUMP="`echo -ne \"$QBUFFER\" | grep -ne \"/$artist -\" | head -1 | cut -d':' -f1`"
	JUMP="`printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | head -1 | cut -d':' -f1`"
	kill $MPLAYER_PID >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

jump_to_last_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	#JUMP="`echo -ne \"$QBUFFER\" | grep -ne \"/$artist -\" | tail -1 | cut -d':' -f1`"
	JUMP="`printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | tail -1 | cut -d':' -f1`"
	kill $MPLAYER_PID >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

load_only_loops() {
	if [ "$LOOPS_ONLY" == false ] || [ "$1" == true ]; then
		draw_banner "WAIT"
		if [ "$ONLY_LOCKED" == true ]; then
			espeak_say_natural "only locked loops"
		else
			espeak_say_natural "loops"  true
		fi
		artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		if [ "$LOOP_ARTIST" == true ]; then
			if [ "`find \"$MUSICDIR\" | grep -e \"^$artist - \" | grep -e \"\.repeats$\"`" == "" ]; then
				LOOP_ARTIST=false
			fi
		fi
		if [ "$ONLY_LOCKED" == true ]; then
			unset queue_array
			IFS=$'\n'
			index=0
			for i in `find "$MUSICDIR" -iname "*.mp3.locked" -o -iname "*.flac.locked" | sort`; do
				var1="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
				if [ -e "$var1.repeats" ]; then
					queue_array[$index]="$var1"
					index=$(($index+1))
				fi
			done
			unset IFS
			new_QBUF=""
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in `find "$MUSICDIR" -iname "*\.repeats" | shuf | sed -e "s/\.repeats$//g"`; do
				#queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3.repeats\" -o -iname \"*.flac.repeats\" | shuf`"
		fi
		#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/.repeats$//g\"`"
		#QBUFFER="`echo -ne \"$QBUFFER\" | sed \"s/.locked$//g\"`"
		SHUFFLED=true
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		TOTAL_QUEUE="$index"
		#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
		tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1 | head -1`"
		#if [ "$tmp" == "" ]; then
		#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
		#fi
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		reset_buffer
		#redraw_screen
		redraw_buffer
		#if [ ! -e "$FILENAME.repeats" ]; then
		#	repeat
		#	repeat_tmp="$?"
		#	if [ "$repeat_tmp" != "200" ]; then
		#		return $repeat_tmp
		#	fi
		#else
			#kill $MPLAYER_PID >/dev/null 2>/dev/null
			#killall play >/dev/null 2>/dev/null
			#JUMP="1"
			#return $RETURN_JUMP
		#fi
		#draw_banner "ONLY LOOPS"
		#espeak_say_natural "loops"
		#sleep 0.25
		draw_pitch
		draw_position
	#else
	#	loops_flagged=false
	#	REPEAT_ONLY=false
	#	draw_banner "LOOP OFF"
	#	espeak_say_natural "reset"
	#	unset queue_array
	#	IFS=$'\n'
	#	index=0
	#	for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
	#		queue_array[$index]="$i"
	#		index=$(($index+1))
	#	done
	#	unset IFS
	#	#QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
	#	SHUFFLED=true
	#	#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
	#	TOTAL_QUEUE="$index"
	#	#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
	#	tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
	#	if [ "$tmp" != "" ]; then
	#		POSITION="$tmp"
	#	else
	#		POSITION=1
	#	fi
	#	#if [ "$tmp" == "" ]; then
	#	#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
	#	#fi
	#	#POSITION="$tmp"
	#	reset_buffer
	#	redraw_screen
	#	sleep 0.25
	#	draw_pitch
	#	draw_position
	else
		draw_banner "WAIT"
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
		#for i in $(find "$MUSICDIR" \( -iname "*.mp3" -o -iname "*.flac" \) -not -iname "*\.repeat\.*" | shuf); do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		SHUFFLED=true
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		TOTAL_QUEUE=$index
		tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		#if [ "$tmp" == "" ]; then
		#	tmp=`echo -ne "$QBUFFER" | grep -n "$TITLE" | cut -d':' -f1`
		#fi
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		reset_buffer
		#redraw_screen
		redraw_buffer
	fi
}

master_volume_secondary_func() {
	case "$1" in
	'[')
		master_volume_change "-1% +0%"
		;;
	']')
		master_volume_change "+0% -1%"
		;;
	'{')
		master_volume_change "+1% +0%"
		;;
	'}')
		master_volume_change "+0% +1%"
		;;
	esac
}

generate_random_color() {
  printf "#%02x%02x%02x\n" $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

hex_to_decimal() {
  local hex=$1
  echo "ibase=16; $hex" | bc
}

generate_complementary_color() {
  local color=$1
  #local r=$(printf "%x" 0x${color:1:2})
  #local g=$(printf "%x" 0x${color:3:2})
  #local b=$(printf "%x" 0x${color:5:2})
  local r=$(hex_to_decimal "${color:1:2}")
  local g=$(hex_to_decimal "${color:3:2}")
  local b=$(hex_to_decimal "${color:5:2}")

  local comp_r=$((255 - $r))
  local comp_g=$((255 - $g))
  local comp_b=$((255 - $b))

  printf "#%02x%02x%02x\n" $comp_r $comp_g $comp_b
}

draw_pitch() {
	#if [ "$WEB_CLIENT" == "0" ]; then
		if [ "$PAUSE" == true ]; then
			draw_banner "PAUSE"
			return
		elif [ "$MUTE" == true ]; then
			draw_banner "MUTE"
			return
		fi

		tput cup $LINES

		if [ "$SCALETEMPO" == true ]; then
			if [ "$ONLY_PITCH" == true ]; then
				toggle=2
			else
				toggle=1
			fi
		else
			toggle=0
		fi

		#if [ "$1" == "1" ]; then
		#	replace_int="$GREEN_BLACK"
		#	unset replace_edo
		#	unset replace_scaletempo
		#elif [ "$1" == "2" ]; then
		#	unset replace_int
		#	replace_edo="$GREEN_BLACK"
		#	unset replace_scaletempo
		#elif [ "$1" == "3" ]; then
		#	unset replace_int
		#	unset replace_edo
		#	replace_scaletempo="$GREEN_BLACK"
		#else
		#	unset replace_int
		#	unset replace_edo
		#	unset replace_scaletempo
		#fi
		

		#echo -ne "$BLUE_BLACK$PADDING$replace_int$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$replace_edo$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$replace_scaletempo$toggle"
		echo -ne "$BLUE_BLACK$PADDING$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$toggle"

		POSITION_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))"
		if [ "$POSITION_WIDTH" -lt "$RIGHT_BANNER_WIDTH" ]; then
			printf '%*s' $(($COLS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - $RIGHT_BANNER_WIDTH))
		else
			printf '%*s' $(($COLS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - $POSITION_WIDTH))
		fi
	#fi
	#if [ "$1" != "" ]; then
	#	echo -ne "$BLUE_BLACK$PADDING$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$toggle"
	#fi
}

draw_equalizer() {
	#if [ "$WEB_CLIENT" == "0" ]; then
		stty -echo
		equal1="`echo $EQUALIZER | cut -d':' -f1`"
		equal2="`echo $EQUALIZER | cut -d':' -f4`"
		equal3="`echo $EQUALIZER | cut -d':' -f8`"
		equal="`echo $EQUALIZER | cut -d':' -f1`"
		equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
		equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
		#tput cup 0 $(($COLS-${#equal}-1 ))
		tput cup 0 $(($COLS-${#equal1}-${#equal2}-${#equal3}-(${#CORNER_DIVIDER}*2)-${#RIGHTPADDING}))
		#clr2="$BLUE_BLACK"
		#equal_print=`echo -n "$BLUE_BLACK$equal" | sed -e "s/:/$(echo -ne \"$WHITE_BLACK$CORNER_DIVIDER$clr2\")/g"`
		echo -ne "$BLUE_BLACK$equal1$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$equal2$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$equal3$RIGHTPADDING"
	#fi
}

toggle_voice() {
	if [ "$VOICE_ENABLED" == false ]; then
		VOICE_ENABLED=true
		#espeak-ng ".,"
		#if [ "$1" == false ] || [ "$1" == "" ]; then
		#	draw_banner "VOICE ON" false false true
		#fi
		if [ "$2" == false ] || [ "$2" == "" ]; then
			espeak_say_natural "on" false true
		fi
	else
		#if [ "$1" == false ] || [ "$1" == "" ]; then
		#	draw_banner "VOICE OFF" false false true
		#fi
		if [ "$2" == false ] || [ "$2" == "" ]; then
			espeak_say_natural "off" false true
		fi
		VOICE_ENABLED=false
		ONLY_VOICE_TITLES=false
	fi
	#stty -echo
	#sleep 0.25
	#stty echo
	#if [ "$1" == "" ]; then
	#	draw_pitch
	#else
		draw_banner "$3"
	#fi
}

queue_help_screen() {
	espeak_say_natural "queue controls"
	local flagged=false
	original_number_per_page="$number_per_page"
	number_per_page="$(($LINES-4))"

	FLAGGED=false
	if [ "$QUEUE_HELP_LENGTH" -le "$number_per_page" ]; then
		number_per_page="$QUEUE_HELP_LENGTH"
		FLAGGED=true
	fi

	pos=1
	while [ "$pos" -le "$QUEUE_HELP_LENGTH" ]; do
		buf=""
		tput cup 0
		if [ "$(($QUEUE_HELP_LENGTH-$pos))" -lt $number_per_page ]; then
			number_per_page=$(($QUEUE_HELP_LENGTH-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
			return
		fi
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$QUEUE_HELP\" | sed -n ${i}p`"
			if [ "`echo \"$line\" | cut -b2`" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
			else
				tmp1="$BLUE `echo \"$line\" | cut -b1`"
				tmp2="$WHITE`echo \"$line\" | cut -d' ' -f2-`"
			fi

			buf="$buf$PADDING$tmp1 $tmp2`tput el`\n"
		done
		draw_banner "CONTROLS" false true

		tput cup 2
		echo -ne "$NOCOLOR$buf"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page + 2))"
		fi

		#if [ "$flagged" == false ]; then
			#if [ "$VOICE_ENABLED" == true ]; then
				#killall espeak-ng play gtts-cli >/dev/null 2>/dev/null
			#	killall espeak-ng >/dev/null 2>/dev/null
				#killall play >/dev/null 2>/dev/null
				#killall gtts-cli >/dev/null 2>/dev/null
				#echo -e "$SCALE_HELP" | sed -n "$pos,$(($pos+$number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | gtts-cli - | play -t mp3 - >/dev/null 2>/dev/null & #| espeak-ng -s$VOICE_SPEED -v$VOICE_GENDER -a$VOICE_VOLUME -p$VOICE_PITCH --stdin --punct -k 2 &
				# FIXME
				#echo -e "$SCALE_HELP" | sed -n "$pos,$(($pos+$number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng -s$VOICE_SPEED -v$VOICE_GENDER -a$VOICE_VOLUME -p$VOICE_PITCH --stdin --punct -k 2 & >/dev/null 2>/dev/null
			#fi
		#fi

		read -rsn1 updown
		#if [ "$updown" == "J" ]; then
		#	if [ "$VOICE_PITCH" -gt "0" ]; then
		#		VOICE_PITCH="$(($VOICE_PITCH-10))"
		#	fi
		#	espeak_say_natural "$VOICE_PITCH"
		#	flagged=true
		#elif [ "$updown" == "K" ]; then
		#	if [ "$VOICE_PITCH" -lt "100" ]; then
		#		VOICE_PITCH="$(($VOICE_PITCH+10))"
		#	fi
		#	espeak_say_natural "$VOICE_PITCH"
		#	flagged=true
		if [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
				pos="$(($QUEUE_HELP_LENGTH-$number_per_page-1))"
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$updown" == "d" ]; then
			echo -e "$QUEUE_HELP" | sed -n "$pos,$(($pos+$number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -k 2 & >/dev/null 2>/dev/null
		else
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "closed"
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			draw_pitch
			draw_position
			redraw_buffer
			empty_pane $(($number_per_page+2))
			return
		fi
	done
}

scale_screen() {
	#VOICE_ENABLED=true
	espeak_say_natural "scale controls"
	local flagged=false
	original_number_per_page="$number_per_page"
	number_per_page="$(($LINES-4))"

	FLAGGED=false
	if [ "$SCALE_HELP_LENGTH" -le "$number_per_page" ]; then
		number_per_page="$SCALE_HELP_LENGTH"
		FLAGGED=true
	fi

	pos=1
	while [ "$pos" -le "$SCALE_HELP_LENGTH" ]; do
		buf=""
		tput cup 0
		if [ "$(($SCALE_HELP_LENGTH-$pos))" -lt $number_per_page ]; then
			number_per_page=$(($SCALE_HELP_LENGTH-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$SCALE_HELP_LENGTH" ]; then
			return
		fi
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$SCALE_HELP\" | sed -n ${i}p`"
			if [ "`echo \"$line\" | cut -b2`" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
			else
				tmp1="$BLUE `echo \"$line\" | cut -b1`"
				tmp2="$WHITE`echo \"$line\" | cut -d' ' -f2-`"
			fi

			buf="$buf$PADDING$tmp1 $tmp2`tput el`\n"
		done
		draw_banner "CONTROLS" false true

		tput cup 2
		echo -ne "$NOCOLOR$buf"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page + 2))"
		fi

		read -rsn1 updown
		if [ "$updown" == "J" ]; then
			if [ "$VOICE_PITCH" -gt "0" ]; then
				VOICE_PITCH="$(($VOICE_PITCH-10))"
			fi
			espeak_say_natural "$VOICE_PITCH"
			flagged=true
		elif [ "$updown" == "K" ]; then
			if [ "$VOICE_PITCH" -lt "100" ]; then
				VOICE_PITCH="$(($VOICE_PITCH+10))"
			fi
			espeak_say_natural "$VOICE_PITCH"
			flagged=true
		elif [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -gt "$SCALE_HELP_LENGTH" ]; then
				pos="$(($SCALE_HELP_LENGTH-$number_per_page-1))"
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$updown" == "d" ]; then
			echo -e "$SCALE_HELP" | sed -n "$pos,$(($pos+$number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -k 2 & >/dev/null 2>/dev/null
		else
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "closed"
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			draw_pitch
			draw_position
			redraw_buffer
			empty_pane $(($number_per_page+2))
			return
		fi
	done
}

add_downloaded() {
	#unset queue_array
	IFS=$'\n'
	index=0
	list=`find "$MUSICDIR" -cnewer $SCRIPTPATH -iname "*.mp3" -o -cnewer $SCRIPTPATH -iname "*.flac"`
	if [ "$list" != "" ]; then
		for i in $list; do
			queue_array[$(($index+$TOTAL_QUEUE))]="$i"
			index=$(($index+1))
		done
		unset IFS
		DOWNLOAD_POSITION="$(($TOTAL_QUEUE+1))"
		TOTAL_QUEUE="$(($index+$TOTAL_QUEUE))"
		#qbuf="`find \"$MUSICDIR\" -cnewer $SCRIPTPATH -iname \"*.mp3\" -o -cnewer $SCRIPTPATH -iname \"*.flac\" | sed '/^$/d'`"
		#if [ "$qbuf" != "" ]; then
		#QBUFFER="$QBUFFER\n$qbuf"
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		if [ "$1" == false ] || [ "$1" == "" ]; then
			espeak_say_natural "queued downloads"
		fi
		if [ "$1" != "noposition" ]; then
			draw_position
		fi
		reset_buffer
		redraw_buffer
	else
		unset IFS
		if [ "$1" == false ] || [ "$1" == "" ]; then
			espeak_say_natural "nothing downloaded"
			draw_banner "NONE"
		fi
		sleep 0.25
		draw_pitch
		draw_position
	fi
	touch -m $SCRIPTPATH
}

say_status() {
	draw_banner "STATUS" false false true
	espeak_say_natural "which corner?"
	read -n1 x
	if [ "$x" == "u" ]; then
		#if [ "$VOICE_ENABLED" == true ]; then
			tmp="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
			tmp2="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
			tmp3="`echo $VOLUME | cut -d'%' -f1`"
			#if [ "$tmp" != "$tmp2" ]; then
				#espeak_say " $tmp3, $tmp and $tmp2" true
				espeak_say_natural "$tmp3" true
				espeak_say_natural "$tmp" true
				espeak_say_natural "$tmp2" true
			#else
				#espeak_say " $tmp3, $tmp" true
			#	espeak_say_natural "$tmp3" true
			#	espeak_say_natural "$tmp" true
			#fi
		#fi
	elif [ "$x" == "i" ]; then
		#if [ "$VOICE_ENABLED" == true ]; then
			res="`echo -ne \"$equal\" | sed -e \"s/:/, /g\"`"
			if [ "$res" == "0, 0, 0" ]; then
				espeak_say_natural "0" true
				espeak_say_natural "0" true
				espeak_say_natural "0" true
				#espeak_say_natural "0" true
			else
				espeak_say_natural " $bass" true
				espeak_say_natural " $mid" true
				espeak_say_natural " $treble" true
			fi
		#fi
	elif [ "$x" == "j" ]; then
		#if [ "$VOICE_ENABLED" == true ]; then
			if [ "$LOCKED" == true ]; then 
				tmp_int="`cat \"$FILENAME.locked\" | cut -d'/' -f1`"
				#espeak_say_natural " $INTERVAL of $EDO. Locked." true
				#espeak_say " $INTERVAL of $EDO. Locked."
				espeak_say_natural "$INTERVAL" true
				espeak_say_natural "$EDO" true
				espeak_say_natural "locked" true
				espeak_say_natural "$tmp_int" true
				if [ "$SCALETEMPO" == true ]; then
					espeak_say_natural "tempo" true
				fi
			else
				#espeak_say " $INTERVAL of $EDO" true
				espeak_say_natural "$INTERVAL" true
				espeak_say_natural "$EDO" true
				if [ "$SCALETEMPO" == true ]; then
					espeak_say_natural "tempo" true
				fi
			fi
			#if [ "$SCALETEMPO" == true ]; then
			#	espeak_say_natural " scale tempo on." true
			#fi
		#fi
	elif [ "$x" == "k" ]; then
		espeak_say_natural "$POSITION" true
		espeak_say_natural "of" true
		espeak_say_natural "$TOTAL_QUEUE" true
		if [ "$LOOP" == true ]; then
			espeak_say_natural "loop enabled" true
		elif [ "$LOOP_ARTIST" == true ]; then
			espeak_say_natural "playing" true
			espeak_say_natural "$TITLE" true
		elif [ "$RANDOM_MODE" == true ]; then
			espeak_say_natural "random mode" true
		elif [ "$ONLY_LOCKED" == true ]; then
			espeak_say_natural "only locked" true
		fi
			
	elif [ "$x" == "I" ]; then
		espeak_say_natural "closed"
	fi
	draw_pitch
}

sort_queue() {
	espeak_say_natural "sorted"

	#QBUFFER="`echo -ne \"$QBUFFER\" | sort`"
	#queue_array=$(echo -ne "${queue_array[@]}" | sort)
	#tmp="`echo -ne \"$QBUFFER\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"

	#sorted_list=$(printf '%s\n' "${queue_array[@]}" | sort)
	IFS=$'\n'
	#index=1
	#unset queue_array
	#for i in $sorted_list; do
	#	queue_array[$index]="$i"
	#	index=$(($index+1))
	#done
	queue_array=($(sort <<<"${queue_array[*]}"))	
	#queue_array=("${new_queue_array[@]}")
	
	#queue_array=$(printf '%s\n' "${queue_array[@]}" | sort)
	#tmp="`echo -ne \"${queue_array[@]}\" | grep -ni \"$FILENAME\$\" | cut -d':' -f1`"
	unset IFS
	#if [ "$tmp" == "" ]; then
		escaped_filename=$(printf '%s\n' "$FILENAME" | sed 's/[][\\\/^$.*]/\\&/g')
		#escaped_filename="`echo -n \"$FILENAME\"`"
		#tmp=$(echo -ne "$sorted_list" | grep -n "" | sed -n "/$escaped_filename/p" | cut -d':' -f1)
		#tmp=$(printf '%s\n' "${queue_array[@]}" | grep -n "" | sed -n "/$escaped_filename/p" | cut -d':' -f1 | head -1)
		#if [ "$tmp" == "" ]; then
		tmp=$(printf '%s\n' "${queue_array[@]}" | grep -n "$escaped_filename" | cut -d':' -f1 | head -1)

		#fi
	#fi
	POSITION="$tmp"
	tmp_func

	#if [ "$WEB_CLIENT" == "0" ]; then
		reset_buffer
		redraw_buffer
	#fi
}

shuffle_queue() {
	espeak_say_natural "shuffled"


	IFS=$'\n'
	#escaped_filename=$(printf '%s\n' "$FILENAME" | sed 's/[][\\\/^$.*]/\\&/g')
	escaped_filename=$(printf '%s\n' "$FILENAME" | sed 's/[][\\\/^$*]/\\&/g')
	#shuffled_list="$escaped_filename$IFS`printf "%s\n" \"${queue_array[@]}\" | shuf`"
	queue_array=("$FILENAME" $(shuf <<<"${queue_array[*]}" | grep -v "$escaped_filename"))	
	#shuffled_list="$FILENAME$IFS"
	#new_list=""
	#for i in `seq 1 $TOTAL_QUEUE`; do
		#if [ "$i" != "$POSITION" ]; then
		#	new_list="$new_list${queue_array[$i]}$IFS"
		#fi
	#done
	#new_list="`echo -ne \"$new_list\" | shuf`"
	#shuffled_list="$shuffled_list$new_list"
	#unset queue_array
	#index=1
	#for i in $shuffled_list; do
	#	queue_array[$index]="$i"
	#	index=$(($index+1))
	#done
	unset IFS
	#tmp=$(printf '%s\n' "${queue_array[@]}" | grep -n "" | sed -n "/$escaped_filename/p" | head -1 | cut -d':' -f1)
	#QBUFFER="$FILENAME\n`echo -ne \"$QBUFFER\" | sed \"${POSITION}d\" | shuf`"
	#POSITION=`echo -ne "$shuffled_list" | grep -n "$FILENAME$" | cut -d':' -f1`
	#POSITION=$tmp
	POSITION=1
	TRACK_RANDOM=false

	tmp_func
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
	#draw_pitch
	#draw_position
	#if [ "$WEB_CLIENT" == "0" ]; then
		reset_buffer
		redraw_buffer
	#fi
}

render_voice_settings_screen() {
	render $(($VOICE_HELP_LENGTH+1)) "`echo -ne \"$VOICE_HELP\" | wc -L`" "$VOICE_HELP"
	VOICEHELPBUFFER=("${TMPBUFFER[@]}")
}

voice_settings_screen() {
	espeak_say_natural "voice settings"
	flagged=false
	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#VOICEHELPBUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page
		draw_banner "VOICE"
		tput cup 2
		echo -ne "$NOCOLOR${VOICEHELPBUFFER[$page]}"

		helpbuflines=`echo -ne \"${VOICEHELPBUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$(($number_per_page*2))
			else
				first=$((($page*$number_per_page*2)+1))
				last=$((($page*number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 updown <&1
		if [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$(($page+1))" -lt "${#VOICEHELPBUFFER[@]}" ]; then
				page=$(($page+1))
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
			fi
		elif [ "$updown" == "J" ]; then
			if [ "$VOICE_PITCH" -gt "-30" ]; then
				VOICE_PITCH="$(($VOICE_PITCH-1))"
			fi
			if [ ! -e "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" ]; then
				gtts-cli " $VOICE_PITCH" -o /tmp/x${VOICE_PITCH}-pitch.mp3
				sox "/tmp/x${VOICE_PITCH}-pitch.mp3" "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" speed `calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-`
				rm -f "/tmp/x${VOICE_PITCH}-pitch.mp3"
			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" >/dev/null 2>/dev/null &
			flagged=true
		elif [ "$updown" == "K" ]; then
			if [ "$VOICE_PITCH" -lt "30" ]; then
				VOICE_PITCH="$(($VOICE_PITCH+1))"
			fi
			if [ ! -e "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" ]; then
				gtts-cli " $VOICE_PITCH" -o /tmp/x${VOICE_PITCH}-pitch.mp3
				sox "/tmp/x${VOICE_PITCH}-pitch.mp3" "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" speed `calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-`
				rm -f "/tmp/x${VOICE_PITCH}-pitch.mp3"

			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/x${VOICE_PITCH}-pitch.mp3" >/dev/null 2>/dev/null &
			flagged=true
		elif [ "$updown" == "8" ]; then
			if [ "`echo -e \"$VOICE_VOLUME > 0.05\" | bc`" == "1" ]; then
				#VOICE_VOLUME="$(($VOICE_VOLUME-10))"
				VOICE_VOLUME="`calc \"$VOICE_VOLUME-0.05\"`"
			fi
			espeak_say_natural "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$updown" == "9" ]; then
			if [ "`echo -e \"$VOICE_VOLUME < 1.0\" | bc`" == "1" ]; then
				#VOICE_VOLUME="$(($VOICE_VOLUME+10))"
				VOICE_VOLUME="`calc \"$VOICE_VOLUME+0.05\"`"
			fi
			espeak_say_natural "$VOICE_VOLUME" false false true
			flagged=true
		#elif [ "$updown" == "1" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+m1"
		#	espeak_say_natural "male1" true
		#	flagged=true
		#elif [ "$updown" == "2" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+m2"
		#	espeak_say_natural "male2" true
		#	flagged=true
		#elif [ "$updown" == "3" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+m3"
		#	espeak_say_natural "male3" true
		#	flagged=true
		#elif [ "$updown" == "4" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+f1"
		#	espeak_say_natural "female1" true
		#	flagged=true
		#elif [ "$updown" == "5" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+f2"
		#	espeak_say_natural "female2" true
		#	flagged=true
		#elif [ "$updown" == "6" ]; then
		#	DIGITAL_VOICE=true
		#	VOICE_GENDER="en-us+f3"
		#	espeak_say_natural "female3" true
		#	flagged=true
		#elif [ "$updown" == "h" ]; then
		#	if [ "$VOICE_SPEED" -gt "60" ]; then
		#		VOICE_SPEED=$(($VOICE_SPEED-10))
		#	fi
		#	espeak_say_natural "$VOICE_SPEED" true
		#	flagged=true
		#elif [ "$updown" == "l" ]; then
		#	if [ "$VOICE_SPEED" -lt "220" ]; then
		#		VOICE_SPEED=$(($VOICE_SPEED+10))
		#	fi
		#	espeak_say_natural "$VOICE_SPEED" true
		#	flagged=true
		elif [ "$updown" == "d" ]; then
			echo "$VOICE_HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/PCM/p,c,m/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -k 2 & >/dev/null 2>/dev/null
		elif [ "$updown" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			#empty_pane
			draw_volume
			draw_equalizer
			draw_banner "VOICE"
			draw_position
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
			#if [ "$DIMENSIONS_RESET" == true ]; then
			#	render_help_screen
			#	render_voice_settings_screen
			#fi
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#VOICEHELPBUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				#if [ "$switchback" == false ]; then
					#espeak_say_natural "closed" true
				#fi
				if [ "$switchback" == true ]; then
					VOICE_ENABLED=false
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					redraw_screen
				else
					empty_pane
				fi
				return
				;;
			esac
		else
			killall espeak-ng >/dev/null 2>/dev/null
			#if [ "$switchback" == false ]; then
			if [ "$1" == true ]; then
				empty_pane
			fi
			#espeak_say_natural "closed" true
			#fi
			if [ "$switchback" == true ]; then
				VOICE_ENABLED=false
			fi
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				redraw_screen
			#else
			#	empty_pane
			fi
			return
		fi
	done
}

render() {
	TMPBUFFER=()
	local length="$1"
	local width="$2"
	local text="$3"
	loading_chars=0
	number_per_page="$(($LINES-4))"
	original_number_per_page="$number_per_page"

	FLAGGED=false

	if [ "$length" -le "$number_per_page" ]; then
		number_per_page="$length"
		FLAGGED=true
	fi
	
	if [ "$COLS" -ge "$((($width*2)+3))" ]; then
		if [ "$FLAGGED" == true ]; then
			TWO_COLUMN=false
			d=1
		else
			TWO_COLUMN=true
			d=2
		fi
	else
		TWO_COLUMN=false
		d=1
	fi

	pos=1
	while [ "$pos" -lt "$length" ]; do
		buf=""
		#tput cup 0
		if [ "$(($length-$pos))" -lt $number_per_page ]; then
			number_per_page=$(($length-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$length" ]; then
			return
		fi
		x=0
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$text\" | sed -n ${i}p`"
			if [ "$TWO_COLUMN" == false ]; then
				pmt_line=""
			else
				pmt_line="`echo -e \"$text\" | sed -n $(($i+$number_per_page))p`"
			fi
			if [ "`echo \"$line\" | cut -b3`" != " " ]; then
				#modified_string=$(echo "$string" | sed -E "s/([A-Z])/$a\1$b/g")

				tmp1="$BLUE$line"
				tmp2=""

				if [ "$TWO_COLUMN" == true ]; then
					if [ "$(($i+$number_per_page-2))" -lt "`echo -n \"$text\" | wc -l`" ]; then
						if [ "`echo \"$pmt_line\" | cut -b3`" != " " ]; then
							pmt1="$BLUE$pmt_line"
							pmt2=""
						else
							pmt1="$BLUE `echo \"$pmt_line\" | cut -b1-2`"
							pmt2="$WHITE`echo \"$pmt_line\" | cut -d' ' -f3-`"
							pmt_line=" $BLUE$pmt1 $WHITE$pmt2"
						fi
					else
						pmt_line=""
					fi
				else
					pmt_line=""
				fi
			else
				tmp1="$BLUE `echo \"$line\" | cut -b1-2`"
				tmp2="$WHITE`echo \"$line\" | cut -d' ' -f3-`"

				if [ "$TWO_COLUMN" == true ]; then
					if [ "$(($i+$number_per_page-2))" -lt "`echo -n \"$text\" | wc -l`" ]; then
						pmt1="$BLUE `echo \"$pmt_line\" | cut -b1-2`"
						pmt2="$WHITE`echo \"$pmt_line\" | cut -d' ' -f3-`"
					else
						pmt_line=""
					fi
				else
					pmt_line=""
				fi

				if [ "`echo \"$pmt_line\" | cut -b3`" != " " ]; then
					pmt1="$BLUE$pmt_line"
					pmt2=""
				fi

			fi

			if [ "$TWO_COLUMN" == true ]; then
				difference=$(( (($COLS/2) - $width + 2) / 2))
			else
				difference=$(( (($COLS - $width + 2) / 2 ) ))
				#difference="$((1*2))"
			fi

			if [ "$pmt_line" != "" ] && [ "$line" != "" ]; then
				#buf="$buf`printf '%*s' $difference`$tmp1 $tmp2`tput el``tput cup $(($x+2)) $((($COLS/2+1)))``printf '%*s' $difference`$pmt1 $pmt2`tput el`\n"
				buf="$buf`printf '%*s' $difference`$tmp1 $tmp2`tput el``tput cup $(($x+2)) $((($COLS/2+1)))``printf '%*s' $(($difference-1))`$pmt1 $pmt2`tput el`\n"
				#buf="$buf$PADDING$tmp1 $tmp2`tput el``tput cup $(($x+2)) $((($COLS/2)))`$PADDING$PADDING$pmt1 $pmt2`tput el`\n"
			else
				buf="$buf`printf '%*s' $difference`$tmp1 $tmp2`tput el`\n"
				#buf="$buf$PADDING$tmp1 $tmp2`tput el`\n"
			fi

			x=$(($x+1))

		done

		#if [ "$loading" == true ]; then
		#	if [ "$loading_chars" -lt "4" ]; then
		#		loading_chars=$(($loading_chars+1))
		#		#echo -ne "="
		#	else
		#		loading=false
		#	fi
		#fi

		TMPBUFFER+=("$buf")

		#if [ "$FLAGGED" == true ]; then
		#	continue
		#fi

		if [ "$TWO_COLUMN" == false ]; then
			pos="$(($pos+$number_per_page))"
		else
			if [ "$(($pos+($number_per_page*2)))" -lt "$length" ]; then
				pos="$(($pos+($number_per_page*2)))"
			else
				return
			fi
		fi
	done
}

render_repeat_help_screen() {
	render $(($REPEAT_HELP_LENGTH+1)) "`echo -ne \"$REPEAT_HELP\" | wc -L`" "$REPEAT_HELP"
	REPEATHELPBUFFER=("${TMPBUFFER[@]}")
}

loop_help_screen() {
	espeak_say_natural "loop controls"
	flagged=false
	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#REPEATHELPBUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page

		#draw_banner "HELP"
		tput cup 2
		echo -ne "$NOCOLOR${REPEATHELPBUFFER[$page]}"

		helpbuflines=`echo -ne \"${REPEATHELPBUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$(($number_per_page*2))
			else
				first=$((($page*$number_per_page*2)+1))
				last=$((($page*number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 updown <&1
		if [ "$updown" = "j" ]; then
			if [ "$(($page+1))" -lt "${#VOICEHELPBUFFER[@]}" ]; then
				page=$(($page+1))
			fi
		elif [ "$updown" = "k" ]; then
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
			fi
		elif [ "$updown" == "d" ]; then
			echo "$REPEAT_HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/PCM/p,c,m/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed "s/-/minus /g" | sed "s/\./ point /g" | sed "s/^\^/control /g" | espeak-ng --stdin --punct -k 2 & >/dev/null 2>/dev/null
		elif [ "$updown" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
			draw_position
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#REPEATHELPBUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				if [ "$switchback" == false ]; then
					espeak_say_natural "closed"
				fi
				if [ "$switchback" == true ]; then
					VOICE_ENABLED=false
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					#redraw_screen
					redraw_buffer
				fi
				return
				;;
			esac
		else
			if [ "$switchback" == false ]; then
				espeak_say_natural "closed"
			fi
			if [ "$switchback" == true ]; then
				VOICE_ENABLED=false
			fi
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				#redraw_screen
				redraw_buffer
			fi
			return
		fi
	done
}

render_help_screen() {
	render $(($HELP_LENGTH+1)) "`echo -ne \"$HELP\" | wc -L`" "$HELP"
	tput rc
	if [ "$loading" == true ]; then
		#if [ "$loading_chars" -lt "4" ]; then
			i=5
			while [ "$i" -gt "0" ]; do
				echo -ne "$WHITE="
				sleep 0.1
				i=$(($i-1))
			done
			#diff=$((10-$loading_chars))
			#printf '%*s' $diff | tr ' ' '='
		#fi
	fi
	if [ "$loading" == true ]; then
		echo -ne "$WHITE="
	fi
	loading=false
	HELPBUFFER=("${TMPBUFFER[@]}")
}

help_screen() {
	espeak_say_natural "key controls!"
	local initial_screen=$1

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#HELPBUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page

		tput cup 0
		echo -ne "$BLUE_BLACK${PADDING}PCM${WHITE_BLACK}:${BLUE_BLACK}LEF${WHITE_BLACK}:${BLUE_BLACK}RIG"
		printf '%*s' $(($COLS - 2 - 22))
		echo -ne "${BLUE_BLACK}BAS${WHITE_BLACK}:${BLUE_BLACK}MID${WHITE_BLACK}:${BLUE_BLACK}TRE$RIGHTPADDING$NOCOLOR"

		tput cup $LINES
		echo -ne "${BLUE_BLACK}${PADDING}INT${WHITE_BLACK}:${BLUE_BLACK}EDO${WHITE_BLACK}:${BLUE_BLACK}TOG"
		printf '%*s' $(($COLS - 2 - 22))
		echo -ne "${BLUE_BLACK}POS${WHITE_BLACK}:${BLUE_BLACK}QUE${WHITE_BLACK}:${BLUE_BLACK}TOG$RIGHTPADDING$NOCOLOR"

		tput cup 2
		echo -ne "$NOCOLOR${HELPBUFFER[$page]}"

		helpbuflines=`echo -ne \"${HELPBUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			else
				first=$((($page*$number_per_page*2)+1))
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$((($page*$number_per_page)+$number_per_page))
			else
				first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 updown <&1
		if [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page down"
			if [ "$(($page+1))" -lt "${#HELPBUFFER[@]}" ]; then
				page=$(($page+1))
				espeak_say_natural "page down"
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page up"
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
				espeak_say_natural "page up"
			fi
		elif [ "$updown" == "d" ]; then
			killall espeak-ng play >/dev/null 2>/dev/null
			echo "$HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/|/vertical slash/g" | sed "s/?/question mark/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed "s/^\^/control /g" | espeak-ng --stdin --punct -k 2 & >/dev/null 2>/dev/null
		#elif [ "$updown" == "/" ]; then
		#	#killall espeak-ng >/dev/null 2>/dev/null
		#	killall play >/dev/null 2>/dev/null
		#	#espeak_say_natural "Welcome to Aletheia"
		#	play -v "$VOICE_VOLUME" "$ALETHEIA/voices/Welcome to Aletheia-${VOICE_PITCH}int.mp3" >/dev/null 2>/dev/null &
		elif [ "$updown" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			empty_pane
		elif [ "$updown" == "q" ] || [ "$updown" == "i" ] || [ "$updown" == "?" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			espeak_say_natural "closed"
			number_per_page="$original_number_per_page"
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				#draw_pitch
				draw_banner "MENU"
				draw_position
			fi
			return
		elif [ "$updown" == "m" ]; then
			man aletheia
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#HELPBUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				espeak_say_natural "closed"
				number_per_page="$original_number_per_page"
				if [ "$initial_screen" == false ]; then
					draw_volume
					draw_equalizer
					#draw_pitch
					draw_banner "MENU"
					draw_position
				fi
				return
				;;
			esac
		else
			espeak_say_natural "closed"
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

start_search() {
	draw_banner "SEARCH"
	echo -ne "$WHITE_BLACK"
	printf '%*s' $(($COLS - 13 - 1))
	tput rc
	echo -ne "$BLUE_BLACK"
	espeak_say_natural "search"
	if [ "$WEB_CLIENT" == "0" ]; then
		local jump="`read_line`"
	else
		read -t 0.1 jump <$ALETHEIA/input_fifo
		if [ "$jump" == "" ]; then
			local jump="`read_line`"
		fi
	fi
	if [ "$jump" != "" ]; then
		if [ "`isnum \"$jump\"`" != "0" ]; then
			jump="${jump#"${jump%%[!0]*}"}"
			if [ "$jump" -lt "1" ]; then
				redraw_buffer
			elif [ "$jump" -le "$TOTAL_QUEUE" ]; then
				if [ "$jump" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jump"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					redraw_buffer
					draw_pitch
					draw_position
				fi
			else
				redraw_buffer
				draw_pitch
				draw_position
			fi
		else
			#SEARCHBUFFER="`echo -ne \"$QBUFFER\" | grep -ni \"$jump\"`\n"
			SEARCHBUFFER="$(printf '%s\n' "${queue_array[@]}" | grep -ni "$jump")\n"
			#tmp=`echo -ne "$sorted_list" | grep -n "$FILENAME$" | cut -d':' -f1`
			length="`echo -ne \"$SEARCHBUFFER\" | wc -l`"
			if [ "$length" == "1" ]; then
				if [ "`echo $SEARCHBUFFER | grep \":\"`" != "" ]; then
					LOOP_ARTIST=false
					JUMP="$(echo -e $SEARCHBUFFER | cut -d':' -f1)"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
				fi
			elif [ "$length" == "0" ]; then
				draw_pitch
				draw_position
				redraw_buffer
			else
				search_queue
				if [ "$?" == "$RETURN_JUMP" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				#elif [ "$?" == "-1" ]; then
				#	draw_pitch
				#	draw_position
				#	#reset_buffer
				#	#redraw_buffer
				#	return -1
				#else
				#	draw_pitch
				#	draw_position
				#	redraw_buffer
				fi
			fi
		fi
	else
		espeak_say_natural "closed"
		draw_pitch
		draw_position
		redraw_buffer
	fi
}

new_playlist() {
	local initial_screen=$1
	KEYWORD=""
	espeak_say_natural "search"
	draw_banner "SEARCH"
	tmp="`read_line`"
	if [ "$tmp" == "" ]; then
		if [ "$initial_screen" == true ]; then
			empty_pane
		else
			draw_pitch
		fi
	else
		for i in "$tmp"; do
			KEYWORD="$KEYWORD$i.*"
		done
		if [ "$2" == "true" ]; then
			#unset queue_array

			IFS=$'\n'
			index=$(($TOTAL_QUEUE+1))
			for i in `find "$MUSICDIR" -iregex ".*${KEYWORD}.*mp3" -o -iregex ".*${KEYWORD}.*flac"`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			#QBUFFER="$QBUFFER\n`find \"$MUSICDIR\" \"$HOME/Sounds\" \"$HOME/Videos/\" -iregex \".*${KEYWORD}mp3\" -o -iregex \".*${KEYWORD}flac\" | sort`"
		else
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$MUSICDIR" -iregex ".*${KEYWORD}.*mp3" -o -iregex ".*${KEYWORD}.*flac"`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS

			#QBUFFER="`find \"$MUSICDIR\" \"$HOME/Sounds\" \"$HOME/Videos/\" -iregex \".*${KEYWORD}mp3\" -o -iregex \".*${KEYWORD}flac\" | sort`"
		fi
		#if [ "$QBUFFER" == "" ]; then
		if [ "$index" == "1" ]; then
			#draw_banner "NONE"
			#sleep 0.75
			#draw_pitch
			#draw_position
			espeak_say_natural "nothing found" true
			return
		fi
		VIDEO=false
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		TOTAL_QUEUE="$(($index-1))"
		echo -ne "$NOCOLOR"
		#if [ "$2" == false ] || [ "$2" == "" ]; then
		if [ "$2" == true ]; then
			reset_buffer
		else
			JUMP="1"
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			return $RETURN_JUMP
		fi
	fi
}

search_queue() {
	local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
	local number_per_page="$(($LINES-4))"
	local original_number_per_page="$number_per_page"

	local FLAGGED=false
	local REDRAWN=false
	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$pos" -le "$total" ] || [ "$FLAGGED" == false ]; do
		BUFFER=""
		tput cup 0
		if [ "$(($total-$pos))" -lt "$number_per_page" ]; then
			number_per_page=$(($total-$pos))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		_last=$(($pos+$number_per_page-1))
		_lines="`echo -e \"$SEARCHBUFFER\" | sed -n \"$pos,${_last}p\"`"
		diff=$(($_last-$pos+1))
		#for i in `seq $pos $(($pos + $end))`; do
		for i in `seq 1 $diff`; do
			truepos=$(($i))
		#for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			#line="`echo -e \"$SEARCHBUFFER\" | sed -n ${i}p`"
			line="`echo -e \"$_lines\" | sed -n \"${truepos}p\"`"
			m="`echo -ne \"$line\" | cut -d':' -f1`"
			if [ "$m" == "" ]; then
				break
			fi

			line="`echo \"$line\" | cut -d':' -f2 | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev`"
			if [ "$ONLY_DISPLAY_SONG" == false ]; then
				if [ "`echo -ne \"$line\" | grep \" - \"`" != "" ]; then
					artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
					song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
					line="$artist - $song"
				fi
				tmp_buf="$tmp_buf. $m. $line. "
			else
				artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
				song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
				tmp_buf="$tmp_buf, $m, $artist - $song"
			fi

			if [ "$m" -lt "$POSITION" ]; then
				COLOR="$WHITE"
			elif [ "$m" -gt "$POSITION" ]; then
				COLOR="$WHITE"
			else
				COLOR="$BLUE"
			fi

			if [ "$m" -lt "10" ]; then
				pad=" "
			#elif [ "$m" -lt "100" ]; then
			#	pad=" "
			else
				pad=""
			fi

			offset="$(($COLS - ${#m} - 1 - ${#pad} - 1 - 2 ))"


			line="`echo \"$line\" | cut -b 1-$offset`"
			BUFFER="$BUFFER$BLUE$PADDING ${m} $COLOR$line$(tput el)\n"
		done
		tput cup 2
		echo -ne "$NOCOLOR$BUFFER"
		
		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page+2))"
		fi
		draw_banner "SEARCH"
		printf '%*s' $(($COLS - 13 - 1))
		#tput el
		tput rc
		#espeak_say " $tmp_buf"

		if [ "$WEB_CLIENT" == "0" ]; then
			read -rsn1 updown <&1
		else
			read -rsn1 -t 0.1 updown <$ALETHEIA/input_fifo
			if [ "$updown" == "" ]; then
				read -rsn1 updown <&1
			fi
		fi

		if [ "$updown" = "j" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page down"
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -ge "$total" ]; then
				#pos="$(($total-$number_per_page))"
				pos="$(($pos-$number_per_page))"
			fi
		elif [ "$updown" = "k" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page down"
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "`isnum \"$updown\"`" != "0" ]; then
			#echo -ne "$updown"
			espeak_say_natural " $updown"
			up_down="`read_line $updown`"
			#jumpto="$updown$up_down"
			jumpto="$up_down"
			if [ "$jumpto" -le "$TOTAL_QUEUE" ]; then
				if [ "$jumpto" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jumpto"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					return
				fi
			fi
			return
		elif [ "$updown" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			#elif [ "$?" == "-1" ]; then
			else
				BUFFER="$BUFFER_BACKUP"
				#redraw_buffer
				espeak_say_natural "closed"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				return
			fi
		elif [ "$updown" == "" ]; then
			if [ "$VOICE_ENABLED" == true ]; then
				killall espeak-ng >/dev/null 2>/dev/null
			fi
			LOOP_ARTIST=false
			JUMP="`echo \"$SEARCHBUFFER\" | head -1 | cut -d':' -f1`"
			return $RETURN_JUMP
		elif [ "$updown" == "T" ]; then
			set_only_display_song true
			FLAGGED=false
		elif [ "$updown" == "d" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say " $tmp_buf"
			#toggle_voice
			#draw_banner "SEARCH"
			FLAGGED=false
		#elif [ "$updown" == "A" ]; then
		#	sort_queue
		#	draw_banner "SEARCH"
		#	FLAGGED=false
		elif [ "$updown" == "q" ]; then #|| [ "$updown" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			#if [ "$1" == false ] || [ "$1" == "" ]; then
				espeak_say_natural "closed"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				#redraw_buffer
			#fi
			return
		elif [ "$updown" == "z" ]; then
			draw_wait
			reset_dimensions
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "SEARCH"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$(($pos+$number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$(($total-$number_per_page-1))"
				fi
				;;
			'[A')
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				espeak_say_natural "closed"
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position

				return
				;;
			esac
	#	elif [ "$updown" == "" ]; then
	#		espeak_say_natural "closed"
	#		if [ "$REDRAWN" == false ]; then
	#			BUFFER="$BUFFER_BACKUP"
	#		fi
	#		number_per_page="$original_number_per_page"
	#		draw_volume
	#		draw_equalizer
	#		draw_pitch
	#		draw_position
	#
	#		return
		fi
		
	done
}

queue_controls() {
	espeak_say_natural "queue"
	SEARCHBUFFER="`ls -1 \"$ALETHEIA/playlists/\"`"
	local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
	local number_per_page="$(($LINES-4))"
	local original_number_per_page="$number_per_page"

	local FLAGGED=false
	local REDRAWN=false

	#if [ "$SEARCHBUFFER" == "" ]; then
	#	espeak_say_natural "no playlists available" false true 
	#	if [ "$1" == false ] || [ "$1" == "" ]; then
	#		espeak_say_natural "closed"
	#		draw_volume
	#		draw_equalizer
	#		draw_pitch
	#		draw_position
	#	fi
	#	return
	#fi
	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$(($pos-1))" -le "$total" ]; do
		if [ "$total" == "0" ]; then
			SEARCHBUFFER="\n"
			local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
		else
			SEARCHBUFFER="`ls -1 \"$ALETHEIA/playlists/\"`"
			local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
		fi
		#if [ "$SEARCHBUFFER" == "" ]; then
		#	draw_banner "NO QUEUES"
		#	espeak_say_natural "no queues" true
		#	#sleep 0.25
		#	#draw_pitch
		#	draw_position
		#	#redraw_screen
		#	reset_buffer
		#	#redraw_buffer
		#	tmp_flag=true
		#	#no_queue_flag=true
		#	return
		#else
		#	no_queue_flag=false
		#fi
		BUFFER=""
		tput cup 0
		if [ "$(($total-$pos))" -lt "$number_per_page" ]; then
			number_per_page=$(($total-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$SEARCHBUFFER\" | sed -n ${i}p`"

			if [ "$i" -lt "10" ]; then
				pad=" "
			else
				pad=""
			fi

			offset="$(($COLS-${#i} - 2 -1))"

			line="`echo \"$line\" | cut -b 1-$offset`"

			tmp_buf="$tmp_buf. $i. $line, "
			if [ "$line" == "" ]; then
				BUFFER="$BUFFER$BLUE ${i} $WHITE(none)$(tput el)\n"
			else
				BUFFER="$BUFFER$BLUE ${i} $WHITE$line$(tput el)\n"
			fi
		done
		tput cup 2
		echo -ne "$NOCOLOR$BUFFER"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page+2))"
		fi
		#tput cup $(($LINES-2))
		#echo -ne "$BLUE\033(0`printf '%*s' $COLS | tr ' ' 'q'`\033(B"

		#if [ "$1" == false ] || [ "$1" == "" ]; then
			draw_banner "QUEUE"
		#fi
		#espeak_say " $tmp_buf"

		read -rsn1 updown <&1

		if [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -gt "$total" ]; then
				pos="$(($total-$number_per_page-1))"
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "`isnum \"$updown\"`" != "0" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			#echo -ne "$updown"
			#espeak_say_natural " $updown"
			up_down="`read_line \"$updown\"`"
			jumpto="$up_down"
			if [ "$jumpto" -le "$total" ]; then
				if [ "$jumpto" -gt "0" ]; then
					#LOOP_ARTIST=false
					#JUMP="$jumpto"
					#kill $MPLAYER_PID >/dev/null 2>/dev/null
					#return $RETURN_JUMP
					pick="`echo -ne \"$SEARCHBUFFER\" | sed -n ${jumpto}p`"
					if [ "$pick" == "" ]; then
						#QBUFFER=""
						espeak_say_natural "number not valid"
					else
						#QBUFFER="`cat \"$ALETHEIA/playlists/$pick\"`"
						unset queue_array

						IFS=$'\n'
						index=0
						for i in `cat "$ALETHEIA/playlists/$pick"`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						TOTAL_QUEUE=$(($index-1))
						JUMP="1"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
					#espeak_say_natural "`echo -ne \"$jumpto\" | sed \"s/\-/negative /g\"`" true
					continue
				else
					continue
				fi
			else
				#espeak_say_natural "`echo -ne \"$jumpto\" | sed \"s/\-/negative /g\"`" true
				espeak_say_natural "number not valid"
				continue
			fi
			return
		#elif [ "$updown" == "s" ]; then
		#	start_search
		#	if [ "$?" == "$RETURN_JUMP" ]; then
		#		return $RETURN_JUMP
		#	elif [ "$?" == "-1" ]; then
		#		return -1
		#	fi
		elif [ "$updown" == "D" ]; then
			draw_banner "DELETE"
			#espeak_say_natural "te queue?"
			espeak_say_natural "number to delete?"
			#read -rsn1 c
			c="`read_line`"
			#if [ "$c" -gt "0" ] && [ "`isnum \"$c\"`" != "0" ] && [ "$c" -lt "$total" ]; then
			#fi
			#if [ "$c" == "y" ] || [ "$c" == "Y" ]; then
				#draw_banner "INDEX"
				#draw_position
				if [ "`isnum \"$c\"`" != "0" ]; then
					if [ "$c" -gt "0" ] && [ "$c" -le "$total" ]; then
						draw_banner "DELETE" true

						espeak_say_natural "delete $c?"
						read -rsn1 z
						if [ "$z" == "y" ] || [ "$z" == "Y" ]; then
							pmt_pick="`echo -ne \"$SEARCHBUFFER\" | sed -n ${c}p`"
							rm "$ALETHEIA/playlists/$pmt_pick"
							espeak_say_natural "deleted"
						else
							espeak_say_natural "delete canceled"
						fi
					fi
				fi
			#fi

#		elif [ "$updown" == "u" ]; then
#			killall espeak-ng >/dev/null 2>/dev/null
#			draw_banner "UPDATE" true
#			espeak_say_natural "update queue?"
#			read -rsn1 c
#			if [ "$c" == "y" ] || [ "$c" == "Y" ]; then
#				draw_banner "INDEX"
#				draw_position
#				espeak_say_natural "which queue?"
#				read -rsn1 c
#				if [ "`isnum \"$c\"`" != "0" ]; then
#					tmp_pick="`echo -ne \"$SEARCHBUFFER\" | sed -n ${c}p`"
#				else
#					tmp_pick=""
#				fi
#				if [ "$tmp_pick" != "" ]; then
#					tmp_playlist="`cat \"$ALETHEIA/playlists/$tmp_pick\" | shuf`"
#					IFS=$'\n'
#					for i in $tmp_playlist; do
#						if [ ! -e "$i" ]; then
#							index="`echo -ne \"$tmp_playlist\" | grep -n \"$i\" | cut -d':' -f1`"
#							tmp_playlist="`echo -ne \"$tmp_playlist\" | sed -n \"${index}d\"`"
##							sed -ni "${index}d" "$ALETHEIA/playlists/$tmp_pick"
#						fi
#					done
#				else
#					draw_banner "QUEUE"
#				fi
#			fi
		elif [ "$updown" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$VOICE_ENABLED" == true ]; then
				killall espeak-ng >/dev/null 2>/dev/null
			fi
			#pick="`echo -ne \"$SEARCHBUFFER\" | sed -n 1p`"
			pick="`echo -ne \"$SEARCHBUFFER\" | head -1`"
			if [ "$pick" == "" ]; then
				#QBUFFER=""
				espeak_say_natural "no queues"
			else
				unset queue_array

				IFS=$'\n'
				index=0
				for i in `cat "$ALETHEIA/playlists/$pick"`; do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				unset IFS
				TOTAL_QUEUE=$(($index-1))
				#QBUFFER="`cat \"$ALETHEIA/playlists/$pick\"`"
				JUMP="1"
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				return $RETURN_JUMP
			fi
			#LOOP_ARTIST=false
			#JUMP="`echo \"$SEARCHBUFFER\" | head -1 | cut -d':' -f1`"
			#return $RETURN_JUMP
		elif [ "$updown" == "d" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say " $tmp_buf" true
			#toggle_voice
			#draw_banner "QUEUE"
		elif [ "$updown" == "Z" ]; then
			if [ "$initial_screen" == true ]; then
				continue
			fi
			espeak_say_natural "save queue as?"
			draw_banner "SAVE QUEUE"
			tmp="`read_line`"
			if [ "$tmp" != "" ]; then
				if [ ! -e "$ALETHEIA/playlists/" ]; then
					mkdir "$ALETHEIA/playlists"
				fi
				echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
				#echo -ne "$QBUFFER" >"$ALETHEIA/playlists/$tmp"
				espeak_say_natural "saved"
			else
				espeak_say_natural "canceled"
			fi
			#draw_pitch
			draw_banner "QUEUE"
			draw_position
		elif [ "$updown" == "q" ] || [ "$updown" == "i" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			#espeak_say_natural "closed" true
			if [ "$1" == false ] || [ "$1" == "" ]; then
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
			fi
			return -1
		elif [ "$updown" == "z" ]; then
			draw_wait
			reset_dimensions
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "QUEUE"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$(($pos+$number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$(($total-$number_per_page-1))"
				fi
				;;
			'[A')
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				#espeak_say_natural "closed" true
				if [ "$1" == false ] || [ "$1" == "" ]; then
					draw_volume
					draw_equalizer
					draw_pitch
					draw_position
				fi
				return -1
				;;
			esac
		fi
		
	done
}

set_equalizer() {
	draw_banner "EQUALIZER"

	empty_pane

	tput cup $(($LINES-5))
	echo -ne "$PADDING${WHITE}Bass$BLUE? "
	espeak_say_natural "bass"
	bass="`read_number`"
	if [ "$bass" == "" ]; then
		espeak_say_natural "closed"
		if [ "$2" == false ] || [ "$2" == "" ]; then
			redraw_buffer
		fi
		#if [ "$LOCKED" == true ]; then
		#	if [ "$ONLY_DISPLAY_SONG" == false ]; then
		#		tput cup $(($LOCKING_POS+2)) $((1))
		#		if [ -e "$FILENAME.repeats" ]; then
		#			echo -ne "$BLUE_BLACK#"
		#		else
		#			echo -ne "${GREEN_BLACK}$"
		#		fi
		#	fi
		#fi
		return
	fi
	tput cup $(($LINES-4))
	echo -ne "$PADDING${WHITE}Mid$BLUE? "
	espeak_say_natural "mid"
	mid="`read_number`"
	if [ "$mid" == "" ]; then
		espeak_say_natural "closed"
		if [ "$2" == false ] || [ "$2" == "" ]; then
			redraw_buffer
		fi
		#if [ "$LOCKED" == true ]; then
		#	if [ "$ONLY_DISPLAY_SONG" == false ]; then
		#		tput cup $(($LOCKING_POS+2)) $((1))
		#		if [ -e "$FILENAME.repeats" ]; then
		#			echo -ne "$BLUE_BLACK#"
		#		else
		#			echo -ne "${GREEN_BLACK}$"
		#		fi
		#	fi
		#fi
		return
	fi
	tput cup $(($LINES-3))
	echo -ne "$PADDING${WHITE}Treble$BLUE? "
	espeak_say_natural "treble"
	treble="`read_number`"
	if [ "$treble" == "" ]; then
		espeak_say_natural "closed"
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
			redraw_buffer
		fi
		#if [ "$LOCKED" == true ]; then
		#	if [ "$ONLY_DISPLAY_SONG" == false ]; then
		#		tput cup $(($LOCKING_POS+2)) $((1))
		#		if [ -e "$FILENAME.repeats" ]; then
		#			echo -ne "$BLUE_BLACK#"
		#		else
		#			echo -ne "${GREEN_BLACK}$"
		#		fi
		#	fi
		#fi
		return
	fi

	#espeak_say "$bass, $mid, $treble"
	if [ "$bass" == "0" ] && [ "$mid" == "0" ] && [ "$treble" == "0" ]; then
		espeak_say_natural "equalizer off"
	else
		espeak_say_natural "equalizer on"
	fi

	bass="$bass:$bass:$bass"
	mid="$mid:$mid:$mid:$mid"
	treble="$treble:$treble:$treble"

	EQUALIZER="$bass:$mid:$treble"
	if [ "$1" == false ] || [ "$1" == "" ]; then
		echo -e "af_cmdline equalizer $EQUALIZER" >"$ALETHEIA/pipe$$" &
	fi

	equal="`echo $EQUALIZER | cut -d':' -f1`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"

	draw_volume
	draw_equalizer
	if [ "$2" == false ] || [ "$2" == "" ]; then
		if [ "$1" == false ] || [ "$1" == "" ]; then
			draw_pitch
			draw_position
			redraw_buffer
		fi
	fi
	#if [ "$LOCKED" == true ]; then
	#	if [ "$ONLY_DISPLAY_SONG" == false ]; then
	#		tput cup $(($LOCKING_POS+2)) $((1))
	#		if [ -e "$FILENAME.repeats" ]; then
	#			echo -ne "$BLUE_BLACK#"
	#		else
	#			echo -ne "${GREEN_BLACK}$"
	#		fi
	#	fi
	#fi
}

print_queue() {
	espeak_say_natural "queue"
	current=$POSITION
	BUFFER_BACKUP="$BUFFER"

	number_per_page="$(($LINES-4))"

	original_number_per_page="$number_per_page"

	FLAGGED=false
	REDRAWN=false

	tput cup 2

	CHANGED=false

	stty -echo
	HALF="$(($POSITION % $number_per_page + ($number_per_page/2) + 1))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
			HALF="1"
		else
			HALF="1"
		fi
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
			number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$(($original_number_per_page*2 - 1))" ]; then
		HALF="$(($POSITION-($original_number_per_page/2)))"
	fi

	if [ "$(($TOTAL_QUEUE-$POSITION))" -lt "$number_per_page" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page+3))"
	fi
	if [ "$(($HALF+$original_number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page))"
		number_per_page="$original_number_per_page"
	fi

	half_page="$(($number_per_page/2))"
	if [ "$POSITION" -gt "$half_page" ]; then
		result="$(($POSITION-$half_page))"
		if [ "$(($number_per_page % 2))" != "" ]; then
			HALF="$result"
		else
			HALF=$((1+$result))
		fi

		if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
		fi
	fi

	if [ "$HALF" -gt "$(($TOTAL_QUEUE-$number_per_page))" ]; then
		HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
	fi
	if [ "$HALF" -lt "1" ]; then
		HALF=1
	fi

	pos=$HALF
	while [ "$pos" -le "$TOTAL_QUEUE" ]; do
		QUEUE_BUFFER=""
		stty -echo
		tput cup 2
		if [ "$(($TOTAL_QUEUE-$pos))" -lt $number_per_page ] && [ "$pos" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi
		if [ "$(($pos+$number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
			number_per_page="$original_number_per_page"
		fi
		if [ "$pos" -gt "$TOTAL_QUEUE" ]; then
			return 200
		fi
		if [ "$number_per_page" -gt "$TOTAL_QUEUE" ]; then
			number_per_page="$TOTAL_QUEUE"
		fi
		flaggy=false
		tmpbuf=""
		if [ "$pos" -le $POSITION ] && [ "$(($pos + $(($number_per_page-1))))" -ge "$POSITION" ] || [ $CHANGED == true ] ; then
			if [ "$pos" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" != "1" ]; then
				number_per_page="$original_number_per_page"
				pos="$(($pos-$number_per_page))"
			fi
			x=0
			end=$(($number_per_page-1))
			_last=$(($pos+$end))
			#lines="`echo -e \"$QBUFFER\" | sed -n \"$pos,${_last}p\"`"
			diff=$(($_last-$pos+1))
			#for i in `seq $pos $(($pos + $end))`; do
			truepos=$(($i-1+$pos))
			#for i in `seq 1 $diff`; do
			while [ true == false ]; do
				truepos=$(($i-1+$pos))
				if [ "$TOTAL_QUEUE" -gt "9" ]; then
					if [ "$truepos" -lt "10" ]; then
						pad="0"
						display_pad="`tput dim`${LIGHTBLACK}0$NOCOLOR"
					#elif [ "$truepos" -lt "100" ]; then
					#	pad=" "
					else
						pad=""
						display_pad=""
					fi
				fi
				
				offset="$(($COLS-${#truepos}-1-${#pad}-1-1-2))"
				line="`echo -e \"$lines\" | sed -n ${i}p | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
				if [ "$ONLY_DISPLAY_SONG" == false ]; then
					if [ "`echo -ne \"$line\" | grep \" - \"`" != "" ]; then
						artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
						song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
						line="$artist - $song"
					fi
					tmpbuf="$tmpbuf, $truepos, $line"
				else
					artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
					song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
					tmpbuf="$tmpbuf, $truepos, $artist - $song"
				fi

				#line="`echo -e \"$QBUFFER\" | sed -n ${i}p | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | cut -b 1-$offset`"
				line="`echo -ne \"$line\" | cut -b 1-$offset`"
				if [ "$truepos" -lt "$POSITION" ]; then
					COLOR="$WHITE"
					COLOR2="$BLUE"
				elif [ "$truepos" -gt "$POSITION" ]; then
					COLOR="$WHITE"
					COLOR2="$BLUE"
				else
					flaggy=$x
					COLOR="$BLUE"
					COLOR2="$BLUE"
				fi
				x=$(($x+1))

				COL=""
				if [ "$truepos" == "$TOTAL_QUEUE" ] || [ "$truepos" == "1" ]; then
					COL="$GREEN"
				fi
				#if [ "$PANELS_ENABLED" == "1" ] && [ "$truepos" == "$POSITION" ]; then
				#	QUEUE_BUFFER="$QUEUE_BUFFER`tput setab 0`$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$COLOR$line`printf '%*s' $(($COLS - 1 - 1 - ${#line} - ${#truepos} - ${#pad} - 2))``tput sgr0`\n"
				#elif [ "$PANELS_ENABLED" == "1" ] && [ "$truepos" != "$POSITION" ]; then
				#	QUEUE_BUFFER="$QUEUE_BUFFER$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$COLOR$line`printf '%*s' $(($COLS - 1 - 1 - ${#line} - ${#truepos} - ${#pad} - 2))``tput sgr0`\n"
				if [ "$PANELS_ENABLED" == true ]; then
					if [ "$truepos" == "$current" ]; then
						QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR`tput setab 0`$PADDING$BLUE$BAR$COLOR2$COL$display_pad$truepos $BLUE$line$(tput el)\n"
					elif [ "$truepos" == "$POSITION" ]; then
						QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE$BAR$COLOR2$COL$display_pad$truepos $BLUE$line$(tput el)\n"
					fi
				else
					if [ "$truepos" == "$current" ]; then
						QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE$BAR $COLOR2$COL$display_pad$truepos $GREEN$line$(tput el)\n"
					elif [ "$truepos" == "$POSITION" ]; then
						QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE$BAR $COLOR2$COL$display_pad$truepos $BLUE$line$(tput el)\n"
					else
						QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE$BAR $COLOR2$COL$display_pad$truepos $WHITE$line$(tput el)\n"
					fi
				fi
					

				#if [ "$PANELS_ENABLED" == true ] && [ "$truepos" == "$current" ]; then 
				#	QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR`tput setab 0`$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$BLUE$line$(tput el)\n"
				#elif [ "$PANELS_ENABLED" == true ] && [ "$truepos" == "$POSITION" ]; then
				#	QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$BLUE$line$(tput el)\n"
				#elif [ "$PANELS_ENABLED" == true ] && [ "$truepos" == "$current" ]; then
				#	QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$PURPLE$line$(tput el)\n"
				#else
				#	QUEUE_BUFFER="$QUEUE_BUFFER$NOCOLOR$PADDING$BLUE`echo -ne \"\033(0\"`x `echo -ne \"\033(B\"`$COLOR2$COL$truepos $pad$COLOR$line$(tput el)\n"
				#fi
			done
			tput cup 2
			#echo -e "$QUEUE_BUFFER"
			m=$pos
			new_buf=""
			for i in `seq 1 $number_per_page`; do
				if [ -e "${queue_array[$(($m-1))]}.locked" ]; then
					if [ -e "${queue_array[$(($m-1))]}.repeats" ]; then
						FLAGGY="$BLUE$REPLACE${WHITE}#"
					else
						FLAGGY="$BLUE${REPLACE}${WHITE}$"
					fi
				else
					if [ -e "${queue_array[$(($m-1))]}.repeats" ]; then
						FLAGGY="$BLUE$REPLACE${WHITE}&"
					else
						FLAGGY="${BLUE} "
					fi
				fi
				if [ "$TOTAL_QUEUE" -gt "9" ]; then
					if [ "$m" -lt "10" ]; then
						pad="0"
					else
						pad=""
					fi
					display_pad="$pad"
				fi
				if [ "$current" == "$m" ] || [ "$position" == "$m" ]; then
					#echo -e "$(echo -ne "${queue_array[$m]}" | sed "s/<start>/\\$GREEN/g")$(tput el)"
					new_buf="$new_buf${PADDING}$BLUE$FLAGGY$BLUE $display_pad$BLUE$m $GREEN`echo -ne \"${queue_array[$(($m-1))]}\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | cut -c 1-$(($COLS-(${#PADDING}*2)-3-${#m}))``tput el`\n"
				else
					new_buf="$new_buf${PADDING}$BLUE$FLAGGY$BLUE $display_pad$BLUE$m $WHITE`echo -ne \"${queue_array[$(($m-1))]}\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | cut -c 1-$(($COLS-(${#PADDING}*2)-3-${#m}))``tput el`\n"
					#echo -e "$(echo -ne "${queue_array[$m]}" | sed "s/<start>/\\$WHITE/g")$(tput el)"
				fi
				m=$(($m+1))
			done

			echo -ne "$new_buf"

			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				empty_pane "$(($number_per_page+2))"
			fi
		else
			pos="$(($pos+$number_per_page))"
			continue
		fi


		draw_banner "QUEUE"
		#tput el
		tput rc
		
		read -rsn1 updown
		tput civis
		if [ "$updown" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page down"
			CHANGED=true
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
				if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
					pos="$(($TOTAL_QUEUE-$number_per_page+1))"
				else
					pos="$(($pos+$number_per_page))"
				fi
			fi
			if [ "$current" -le "$truepos" ]; then
				current=$pos
			fi
		elif [ "$updown" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say_natural "page up"
			CHANGED=true
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
			#if [ "$current" -gt "$pos" ]; then
				current=$(($pos+$number_per_page-1))
			#fi
		elif [ "$updown" = "h" ]; then
			if [ "$current" == "$TOTAL_QUEUE" ]; then
				continue
			fi
			#CHANGED=true
			#if [ "$FLAGGED" == true ]; then
			#	continue
			#fi
			#pos="$(($pos+1))"
			#if [ "$(($pos+$original_number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			#	pos="$(($TOTAL_QUEUE-$original_number_per_page+1))"
			#	number_per_page="$original_number_per_page"
			#fi
			current=$(($current+1))
			if [ "$current" -gt "$truepos" ]; then
				killall espeak-ng >/dev/null 2>/dev/null
				espeak_say_natural "page down"
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$(($TOTAL_QUEUE-$number_per_page+1))"
					else
						pos="$(($pos+$number_per_page))"
					fi
				fi
			fi

			skip=true
		elif [ "$updown" = "l" ]; then
			if [ "$current" == "1" ]; then
				continue
			fi
			#CHANGED=true
			#if [ "$pos" == "1" ]; then
			#	continue
			#else
			#	FLAGGED=false
			#fi
			#if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			#	number_per_page="$original_number_per_page"
			#fi
			#pos="$(($pos-1))"
			#if [ "$pos" -le "0" ]; then
			#	pos=1
			#fi
			current=$(($current-1))
			if [ "$current" -lt "$(($truepos-$number_per_page+1))" ]; then
				killall espeak-ng >/dev/null 2>/dev/null
				espeak_say_natural "page up"
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			fi

			skip=true
		elif [ "`isnum \"$updown\"`" != "0" ]; then
			up_down="`read_line \"$updown\"`"
			if [ "`isnum \"$up_down\"`" != "0" ]; then
				up_down="${up_down#"${up_down%%[!0]*}"}"
				if [ "$up_down" -lt "1" ]; then
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				elif [ "$up_down" -le "$TOTAL_QUEUE" ]; then
					JUMP="$up_down"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				fi
			fi
		elif [ "$updown" == "D" ]; then
			QBUFFER="`echo -ne \"$QBUFFER\" | sed \"${current}d\"`"
			TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		elif [ "$updown" == "T" ]; then
			set_only_display_song true
		elif [ "$updown" == "b" ]; then
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM_BACK
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST_BACK
			elif [ "$ONLY_LOCKED" == true ]; then
				return $RETURN_ONLY_LOCKED_BACK
			else
				return $RETURN_BACK
			fi
		elif [ "$updown" == "n" ]; then
			ps -p $MPLAYER_PID >/dev/null
			if [ "$?" != "1" ]; then
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						JUMP="1"
						POSITION="1"
						draw_position
						return $RETURN_JUMP
					else
						return 0
					fi
				fi
			fi
		elif [ "$updown" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			elif [ "$?" == "-1" ]; then
				return -1 
			fi
		elif [ "$updown" == "z" ]; then
			draw_wait
			CHANGED=true
			REDRAWN=true
			pos=1
			clear
			reset_dimensions
			number_per_page=$(($LINES-4))
			original_number_per_page=$number_per_page
			draw_volume
			draw_equalizer
			draw_banner "QUEUE"
			draw_position
			reset_buffer
			continue
		elif [ "$updown" == "?" ]; then
			queue_help_screen
			continue
		elif [ "$updown" == "p" ]; then
			if [ "$PAUSE" == true ]; then
				draw_position
				espeak_say_natural "unpaused"
			else
				espeak_say_natural "paused"
			fi
			toggle_pause true
			continue
		elif [ "$updown" == "d" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$CHANGED" != false ]; then
				#echo -e "$QUEUE_BUFFER"
				#espeak_say_natural " $pos of $(($pos+$number_per_page-1)). `echo -ne \"$QUEUE_BUFFER\" | sed -e \"s/\n/. ./g\" | ansi2txt`."
				espeak_say " $pos of $(($pos+$number_per_page-1)). $tmpbuf."
			else
				#echo -e "$QUEUE_BUFFER"
				#espeak_say_natural " $pos of $(($pos+$number_per_page-1)). `echo -ne \"$QUEUE_BUFFER\" | sed -e \"s/\n/. ./g\" | ansi2txt`."
				espeak_say " $pos of $(($pos+$number_per_page-1)). $tmpbuf."
			fi
			#toggle_voice
			#draw_banner "QUEUE"
		elif [ "$updown" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$(($TOTAL_QUEUE-$number_per_page+1))"
					else
						pos="$(($pos+$number_per_page))"
					fi
				fi
				;;
			'[A')
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				#reset_buffer
				echo -ne "$NOCOLOR"
				draw_equalizer
				draw_volume
				draw_pitch
				draw_position
				redraw_buffer
				#stty echo
				return 200
				;;
			esac
		elif [ "$updown" == "q" ] || [ "$updown" == ";" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			#if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			#fi
			#reset_buffer
			echo -ne "$NOCOLOR"
			reset_buffer
			draw_volume
			draw_equalizer
			redraw_buffer
			draw_pitch
			draw_position
			#redraw_buffer
			#stty echo
			return 200
		elif [ "$updown" == "" ]; then
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			JUMP="$current"
			draw_position
			return $RETURN_JUMP
		fi

	
	done
	redraw_screen true
}

_save_setting() {
	if [ "`echo \"$CONFIG\" | grep -i $1`" == "" ]; then
		CONFIG="$CONFIG\n$1=$2"
	else
		CONFIG="`echo -ne \"$CONFIG\" | sed -e \"/$1/s/.*/$1=$2/g\"`"
	fi
}

save_settings() {
	draw_banner "SAVE" true
	espeak_say_natural "save settings?"
	while [ true ]; do
		read -rsn1 yesno
		if [ "$yesno" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "SAVE" true
			redraw_screen false 1 1 0 0
		else
			break
		fi
	done
	if [ "$yesno" == "y" ]; then
		_save_setting "VOICE_PITCH" "$VOICE_PITCH"
		_save_setting "VOICE_GENDER" "$VOICE_GENDER"
		_save_setting "DEFAULT_VOLUME" "$DEFAULT_VOLUME"
		_save_setting "VOICE_VOLUME" "$VOICE_VOLUME"
		_save_setting "VOICE_SPEED" "$VOICE_SPEED"
		_save_setting "PANELS_ENABLED" "$PANELS_ENABLED"
		_save_setting "BLACK_BACKGROUND" "$BLACK_BACKGROUND"
		_save_setting "ONLY_VOICE_TITLES" "$ONLY_VOICE_TITLES"
		_save_setting "COLORS_ENABLED" "$COLORS_ENABLED"
		_save_setting "DEFAULT_EQUALIZER" "$DEFAULT_EQUALIZER"
		clean_sequence=${BLUE#*\033}
		clean_sequence=${clean_sequence%m}
		IFS=';' read -ra color_values <<< "$clean_sequence"
		r=$(printf "%02x" "${color_values[3]}")
		g=$(printf "%02x" "${color_values[4]}")
		b=$(printf "%02x" "${color_values[5]}")
		hex_color="#$r$g$b"
		_save_setting "COLOR_HIGHLIGHT" "$hex_color"
		clean_sequence=${WHITE#*\033}
		clean_sequence=${clean_sequence%m}
		IFS=';' read -ra color_values <<< "$clean_sequence"
		r=$(printf "%02x" "${color_values[3]}")
		g=$(printf "%02x" "${color_values[4]}")
		b=$(printf "%02x" "${color_values[5]}")
		hex_color="#$r$g$b"
		_save_setting "COLOR_UNSELECTED" "$hex_color"

		if [ "$VOICE_ENABLED" == true ]; then
			_save_setting "VOICE_ENABLED" "true"
		else
			_save_setting "VOICE_ENABLED" "false"
		fi
		echo -e "$CONFIG" >"$ALETHEIA/config"
		espeak_say_natural "saved" true
	else
		espeak_say_natural "canceled" true
	fi
	draw_pitch
	draw_position
}

#master_resized() {
#	tput civis
#	draw_wait
#	reset_dimensions true
#	reset_buffer
#	#redraw_screen false
#	draw_volume
#	draw_equalizer
#	redraw_buffer
#	draw_pitch
#	draw_position
#	if [ "$MUTE" == true ]; then
#		draw_banner "MUTE"
#	elif [ "$PAUSE" == true ]; then
#		draw_banner "PAUSE"
#	else
#		draw_pitch
#	fi
#	draw_position
#}

master() {
	#trap master_resized WINCH
	PAUSE=false
	MUTE=false
	LOCKED=false
	SCALETEMPO=false
	FLAGS=""
	CURRENT_TIME="0.0"
	END_TIME=""
	space=0
	SAVED_INTERVAL=""
	SAVED_POSITION=""
	CURRENT_POSITION=""
	SAVED_TOTAL=""

	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	#VOLUME="$DEFAULT_VOLUME"
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	#INTERVAL_LIMIT=$(($EDO * 3))
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
	#if [ "$EQUALIZER" == "" ]; then
		#EQUALIZER="$DEFAULT_EQUALIZER"
	#fi

	if [ -e "$FILENAME.locked" ]; then
		LOCKED=true

		CONTENTS="`cat \"$FILENAME\".locked`"
		IFS='/'
		read _int _edo _volume_offset _equal_offset SCALETEMPO_FLAG <<< "$CONTENTS"
		unset IFS

		if [ "$LOCKED_OFF" == false ]; then
			#INTERVAL="`echo \"$CONTENTS\" | cut -d'/' -f1`"
			#EDO="`echo \"$CONTENTS\" | cut -d'/' -f2`"
			INTERVAL="$_int"
			EDO="$_edo"
			INTERVAL_LIMIT=`calc "$EDO * 2.6"`
			INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
		fi
		#VOLUME="`echo \"$CONTENTS\" | cut -d'/' -f3`"
		#EQUALIZER="`echo \"$CONTENTS\" | cut -d'/' -f4`"
		#SCALETEMPO_FLAG="`echo \"$CONTENTS\" | cut -d'/' -f5`"

		if [ "$EDO" != "$DEFAULT_EDO" ]; then
			tmp=$EDO
			until [ "$(($tmp % 2))" != "0" ]; do
				tmp=$(($tmp/2))
			done
		fi

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		#if [ "$EQUALIZER" == "" ]; then
		#	EQUALIZER="$DEFAULT_EQUALIZER"
		#fi

		FLAGS="-speed `calc \"2^($INTERVAL/$EDO)\"` -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"

		if [ "$SCALETEMPO_FLAG" == "1" ]; then
			FLAGS="$FLAGS,scaletempo=speed=tempo"
			SCALETEMPO=true
		elif [ "$SCALETEMPO_FLAG" == "2" ]; then
			FLAGS="$FLAGS,scaletempo=speed=pitch"
			SCALETEMPO=true
			ONLY_PITCH=true
		else
			SCALETEMPO=false
		fi
	else
		FLAGS="-speed `calc \"2^($DEFAULT_INTERVAL/$DEFAULT_EDO)\"` -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"
	fi

	if [ -e "$FILENAME.repeats" ]; then
		REPEATS="`cat \"$FILENAME.repeats\"`"
		REPEAT_CURRENT=1
		REPEAT_TOTAL="`echo \"$REPEATS\" | wc -l`"
	else
		REPEATS=""
		REPEAT_CURRENT=0
		REPEAT_TOTAL=0
	fi

	#if [ "$KEEP_LOOP" == false ]; then
		LOOP=false
	#fi

	#if [ "$WEB_CLIENT" == "0" ]; then
		reset_buffer

		redraw_buffer
	#fi
	draw_equalizer
	draw_volume

	if [ "`echo -ne \"$TITLE\" | grep \" - \"`" != "" ]; then
		artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //\" | cut -d'' -f1`"
		ARTISTSONG="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1` - `echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | rev | cut -d'' -f1 | rev`"
	else
		ARTISTSONG=$TITLE
	fi
	#NATURAL_VOICE=1
	#if [ "$NATURAL_VOICE" == "1" ]; then
		espeak_say_natural "$ARTISTSONG" false false true
		#if [ "$LOCKED" == true ] && [ "`echo -ne \"$REPEATS\" | wc -l`" -gt 0 ]; then
		#	say_locked_and_loops
		#elif [ "$LOCKED" == false ] && [ "`echo -ne \"$REPEATS\" | wc -l`" -gt 0 ]; then
		#	say_unlocked_and_loops
		#elif [ "$LOCKED" == true ] && [  "`echo -ne \"$REPEATS\" | wc -l`" -lt 1 ]; then
		#	say_locked_and_no_loops
		#elif [ "$LOCKED" == false ] && [  "`echo -ne \"$REPEATS\" | wc -l`" -lt 1 ]; then
		#	say_unlocked_and_no_loops
		#fi

	#else
	#	if [ "$LOCKED" == true ] && [ "$REPEAT_CURRENT" != "0" ]; then
	#		if [ "$REPEAT_CURRENT" == "0" ]; then
	#			espeak_say_natural " $ARTISTSONG. Locked."
	#		else
	#			if [ "$REPEAT_TOTAL" == "1" ]; then
	#				text="loop"
	#			else
	#				text="loops"
	#			fi
	#			espeak_say_natural " $ARTISTSONG. Locked. $REPEAT_TOTAL $text."
	#		fi
	#	elif [ "$LOCKED" == true ] && [ "$REPEAT_CURRENT" == "0" ]; then
	#		if [ "$REPEAT_CURRENT" == "0" ]; then
	#			espeak_say_natural " $ARTISTSONG. Locked."
	#		else
	#			if [ "$REPEAT_TOTAL" == "1" ]; then
	#				text="loop"
	#			else
	#				text="loops"
	#			fi
	#			espeak_say_natural " $ARTISTSONG. Locked. $REPEAT_TOTAL $text."
	#		fi
	#	else
	#		if [ "$REPEAT_CURRENT" != "0" ]; then
	#			if [ "$REPEAT_TOTAL" == "1" ]; then
	#				text="loop"
	#			else
	#				text="loops"
	#			fi
	#			espeak_say_natural " $ARTISTSONG. $REPEAT_TOTAL $text."
	#		else
	#			espeak_say_natural " $ARTISTSONG"
	#		fi
	#	fi
	#fi
	
	LOCKED_EDO="$EDO"

	if [ "$VIDEO" == false ]; then
		flag="-novideo"
	else
		flag=""
	fi

	if [ "$FULLSCREEN" == true ]; then
		flag="$flag -fs"
	fi

	if [ "$ALWAYS_ON_TOP" == true ]; then
		flag="$flag -ontop"
	fi

	#if [ "$LOOP" == true ]; then
	#	flag="$flag -loop 0"
	#fi
	
	if [ "$REPEAT_ONLY" == true ]; then
		FLAGS="$FLAGS -volume 0"
	fi

	rm -f "$ALETHEIA/mplayer_output" >/dev/null 2>/dev/null

	#if [ -e "$HOME/bin/mplayer" ]; then
	#	CUSTOM_MPLAYER_PATH="$HOME/bin/"
	#else
	#	CUSTOM_MPLAYER_PATH=""
	#fi

	#${CUSTOM_MPLAYER_PATH}mplayer -slave -osdlevel 0 -ao pulse -softvol -softvol-max 100 $flag -hr-mp3-seek -quiet -input file="$ALETHEIA/pipe$$" -noconfig all $FLAGS "$FILENAME" >$ALETHEIA/mplayer_output 2>/dev/null &
	
	if [ "$SELECT_REPEAT_FILE" == true ]; then
		ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
		var1="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`.repeat.$ext"
		if [ ! -e "$var1" ]; then
			var1="$FILENAME"
		fi
	else
		var1="$FILENAME"
	fi
	mplayer -slave -osdlevel 0 -ao pulse -softvol -softvol-max 100 $flag -hr-mp3-seek -quiet -input file="$ALETHEIA/pipe$$" -noconfig all $FLAGS "$var1" >$ALETHEIA/mplayer_output 2>/dev/null &

	MPLAYER_PID="$!"

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		#echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
		#LOOP=true
		SELECT_REPEAT_FILE=false
	fi
	
	if [ "$REPEAT_ONLY" == true ]; then
		repeat
		repeat_tmp=$?
		if [ "$repeat_tmp" != "200" ]; then
			#if [ "$?" == "$RETURN_QUIT" ]; then
			#	if [ "$TRACK_RANDOM" == true ]; then
			#		return $RETURN_TRACK_RANDOM_BACK
			#	elif [ "$LOOP_ARTIST" == true ]; then
			#		return $RETURN_LOOP_ARTIST_BACK
			#	elif [ "$ONLY_LOCKED" == true ]; then
			#		return $RETURN_ONLY_LOCKED_BACK
			#	else
			#		return $RETURN_BACK
			#	fi
			#fi
			return $repeat_tmp
			#draw_pitch
			#draw_position
		fi
	else
		draw_pitch
		draw_position
	fi

	stty -echo
	#IFS=$'\n'
	#ticker=1
	while true; do
		new_LINES=`tput lines`
		new_COLS=`tput cols`
		if [ "$new_LINES" != "$LINES" ] || [ "$new_COLS" != "$COLS" ]; then
			COLS=$new_COLS
			LINES=$new_LINES
			draw_wait
			reset_dimensions
			redraw_screen false
			if [ "$MUTE" == true ]; then
				draw_banner "MUTE"
			elif [ "$PAUSE" == true ]; then
				draw_banner "PAUSE"
			fi
			espeak_say_natural "screen redrawn"
		fi
		#ticker=$(($ticker+1))
		#if [ "$(($ticker%6))" == "0" ] && [ "$input" != "j" ] && [ "$input" != "k" ] && [ "$input" != "J" ] && [ "$input" != "K" ] && [ "$input" != "v" ]; then
		#	draw_volume
		#	draw_pitch
		#fi
		if [ "$WEB_CLIENT" == "0" ]; then
			#read -rsn1 -t 0.1 _input <$ALETHEIA/input_fifo
			#if [ "$_input" == "" ]; then
				read -rsn1 -t 0.2 input
			#else
			#	input=$_input
			#fi
		else
			read -rsn1 -t 0.1 input
			if [ "$input" == "" ]; then
				read -rsn1 -t 0.3 input <$ALETHEIA/input_fifo
			fi
		fi

		#orig_left=$MASTER_VOLUME_LEFT
		#orig_right=$MASTER_VOLUME_RIGHT
		#MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
		#MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
		#MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
		#if [ "$MASTER_VOLUME_LEFT" != "$orig_left" ] || [ "$MASTER_VOLUME_RIGHT" != "$orig_right" ]; then
		#	draw_volume
		#fi
		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					JUMP="1"
					return $RETURN_JUMP
				else
					return 0
				fi
			fi
		fi

		case "$input" in
			'j')
				pitch_down
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'k')
				pitch_up
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'o')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				double_precise
				;;
			'm')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				half_precise
				;;
			'i')
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				#if [ "$?" != "200" ]; then
				#	return $?
				#fi
				;;
			'p')
				toggle_pause
				;;
			'n')
				#echo "quit 0" >"$ALETHEIA/pipe$$" &
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				killall play >/dev/null 2>/dev/null
				#ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				#if [ "$?" != "1" ]; then
					#kill $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						JUMP="1"
						POSITION="1"
						draw_position
						return $RETURN_JUMP
					else
						return 0
					fi
				fi
				#fi
				;;
			'b')
				if [ "$POSITION" == "0" ]; then
					POSITION=1
				fi
				#ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				#if [ "$?" != "1" ]; then
				#	kill $MPLAYER_PID >/dev/null 2>/dev/null
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				killall play >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM_BACK
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST_BACK
				elif [ "$ONLY_LOCKED" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					return $RETURN_BACK
				fi
				#fi
				;;
			'8')
				master_volume_change "-3% -3%"
				;;
			'9')
				master_volume_change "+3% +3%"
				;;
			'y')
				#PAUSE=false
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#new_edo="$DEFAULT_EDO"
				#if [ "$new_edo" -gt "$EDO" ]; then
				#	temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
				#	INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
				#elif [ "$new_edo" -lt "$EDO" ]; then
				#	temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2`"
				#	INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 |  cut -d'.' -f1`"
				#fi
				#EDO="$new_edo"
				##INTERVAL_LIMIT=$(($EDO * 3))
				#INTERVAL_LIMIT=`calc "$EDO * 2.6"`
				#INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
				#espeak_say_natural " $INTERVAL of $EDO"
				#echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				#LOCKED=false
				#draw_pitch
				set_default_edo
				;;
			'h')
				#espeak_say_natural "backward"
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_position
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				echo "seek -5%" >"$ALETHEIA/pipe$$" &
				;;
			'l')
				#espeak_say_natural "forward"
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				ps -p $MPLAYER_PID >/dev/null
				if [ "$?" == "1" ]; then
					#throwaway2="x"
					#until [ "$throwaway2" == "" ]; do
					#	read -n1 -t 0.5 throwaway2
					#done
					#sleep 1
					#kill $MPLAYER_PID >/dev/null 2>/dev/null
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
							JUMP="1"
							return $RETURN_JUMP
						else
							return 0
						fi
					fi
					#kill $MPLAYER_PID >/dev/null 2>/dev/null
					#return 0
				fi
				#echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
				#sleep 0.25
				#if [ "$old_percent" == "" ]; then
				#	old_percent=-1
				#else
				#	old_percent=$percent
				#fi
				#percent="`tail -3 \"$ALETHEIA/mplayer_output\" | grep ANS | tail -1 | cut -d'=' -f2`"
				##percent=`calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1`
				#if [ "$old_percent" -gt "$percent" ]; then
				##if [ "`isnum \"$percent\"`" != "1" ] || [ "$old_percent" == "$percent" ]; then
				#	#sleep 1
				#	kill $MPLAYER_PID >/dev/null 2>/dev/null
				#	if [ "$TRACK_RANDOM" == true ]; then
				#		return $RETURN_TRACK_RANDOM
				#	elif [ "$LOOP_ARTIST" == true ]; then
				#		return $RETURN_LOOP_ARTIST
				#	else
				#		if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				#			JUMP="1"
				#			return $RETURN_JUMP
				#		else
				#			return 0
				#		fi
				#	fi
				#fi

				echo "seek +5%" >"$ALETHEIA/pipe$$" &
				;;
			';')
				#print_queue_display
				BUFFER_BACKUP="$BUFFER"
				print_queue
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				#reset_buffer
				#redraw_buffer
				#repeat_tmp=$?
				#if [ "$repeat_tmp" != "200" ] && [ "$repeat_tmp" != "-1" ]; then
					#if [ "$?" == "$RETURN_QUIT" ]; then
					#	if [ "$TRACK_RANDOM" == true ]; then
					#		return $RETURN_TRACK_RANDOM_BACK
					#	elif [ "$LOOP_ARTIST" == true ]; then
					#		return $RETURN_LOOP_ARTIST_BACK
					#	elif [ "$ONLY_LOCKED" == true ]; then
					#		return $RETURN_ONLY_LOCKED_BACK
					#	else
					#		return $RETURN_BACK
					#	fi
					#fi
				#	return $repeat_tmp
					#draw_pitch
					#draw_position
				#fi


				espeak_say_natural "closed"
				;;
			'?')
				help_screen
				#redraw_screen true
				draw_volume
				draw_equalizer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'q')
				read -rsn1 -t 0.1 _input <$ALETHEIA/input_fifo
				if [ "$_input" != "" ]; then
					#input=$_input
					if [ "$_input" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					fi
				fi
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					espeak_say_natural "quit?"
				fi
				throwaway=""
				until [ "$throwaway" == "n" ] || [ "$throwaway" == "q" ]; do
					read -n1 throwaway
					if [ "$throwaway" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					elif [ "$throwaway" == "q" ]; then
						draw_pitch
						draw_position
						break
					elif [ "$throwaway" == "n" ]; then
						draw_pitch
						draw_position
					fi
				done
				;;
			'P')
				sleeper() {
					sleep 1
				}
				old_percent=0
				percentbreak=false
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" != "1" ]; then
					echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
					sleep 0.15
					percent="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
					if [ "`isnum \"$percent\"`" == "0" ]; then
						percent=1
					fi
					#total_=$(($COLS-1-1-2-12))
					total_=$(($COLS-(${#PADDING}*2)-14))
					PAUSE=false
					tput cup $LINES
					echo -ne "${PADDING}${BLUE}00$WHITE:${BLUE}00 "
					echo -ne "$BLUE_BLACK[$WHITE_BLACK"
					percent=`calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1`
					if [ "$percent" -gt "$total_" ]; then
						percent="$total_"
					fi
					#espeak_say_natural "$percent percent"
					espeak_say_natural "progress bar"
					printf '%*s' $percent | tr " " "="
					printf '%*s' $(($total_ - $percent))
					tt="`cat \"$FILENAME.time\"`"
					echo -ne "$BLUE_BLACK] "
					echo -ne "$BLUE`echo -ne \"$tt\" | cut -d':' -f1`$WHITE:$BLUE`echo -ne \"$tt\" | cut -d':' -f2`$PADDING"
					#IFS=":" read minutes seconds <<< "$tt"
					minutes="`echo -ne \"$tt\" | cut -d':' -f1`"
					seconds="`echo -ne \"$tt\" | cut -d':' -f2`"
					if [ "`echo -ne \"$minutes\" | cut -c 1`" == "0" ]; then
						minutes="`echo -ne \"$minutes\" | cut -c 2`"
					fi
					if [ "`echo -ne \"$seconds\" | cut -c 1`" == "0" ]; then
						seconds="`echo -ne \"$seconds\" | cut -c 2`"
					fi
					total_seconds_tt=$(($minutes * 60 + $seconds))
					#tput cup $LINES $((1+1))
					tput cup $LINES $((1+7))
					l=0
					throwaway=""
					until [ "$throwaway" != "" ]; do
						ps -p $MPLAYER_PID >/dev/null 2>/dev/null
						if [ "$?" == "1" ]; then
							#sleep 1
							#until [ "$throwaway2" != "" ]; do
							#	read -n1 -t 0.01 throwaway2
							#done
							#kill $MPLAYER_PID >/dev/null 2>/dev/null
							#return 0
							if [ "$TRACK_RANDOM" == true ]; then
								return $RETURN_TRACK_RANDOM
							elif [ "$LOOP_ARTIST" == true ]; then
								return $RETURN_LOOP_ARTIST
							else
								if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
									JUMP="1"
									return $RETURN_JUMP
								else
									return 0
								fi
							fi
							#break
						fi
						if [ "`jobs | grep \"sleeper\" | grep \"Running\"`" == "" ] && [ "$old_throwaway" != "l" ] && [ "$old_throwaway" != "h" ] && [ "$old_throwaway" != "j" ] && [ "$old_throwaway" != "k" ]; then
							sleeper &
							echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
							sleep 0.15
							percent="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
							echo "get_time_pos" >"$ALETHEIA/pipe$$" &
							sleep 0.15
							tmpq="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2 | cut -d'.' -f1`"
							tput cup $LINES 1
							if [ "`isnum \"$tmpq\"`" == "1" ]; then
								dateo="`date -u -d @$tmpq +%M:%S`"
								skip2=false
							else
								dateo="00:00"
								percent=$total_
								skip2=true
							fi
							echo -ne "$BLUE`echo -ne \"$dateo\" | cut -d':' -f1`$WHITE:$BLUE`echo -ne \"$dateo\" | cut -d':' -f2`"
							if [ "$skip2" == false ]; then
								tput cup $LINES $(($COLS-1-5))
								#IFS=":" read minutes seconds <<< "$dateo"
								#total_seconds_dateo="$total_seconds_tt"
								#total_seconds_dateo=$(($total_seconds_tt * (2 * $INTERVAL / $EDO)))
								#total_seconds_dateo="`calc \"$total_seconds_tt * (2 * $INTERVAL / $EDO)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
								if [ "$INTERVAL" -lt "0" ]; then
									int="`echo -ne \"$INTERVAL\" | cut -c 2-`"
									neg=true
									skip=false
								elif [ "$INTERVAL" -gt "0" ]; then
									int="$INTERVAL"
									neg=false
									skip=false
								else
									skip=true
								fi
								if [ "$skip" == false ]; then
									if [ "$neg" == true ]; then
										total_seconds_dateo="`calc \"$total_seconds_tt * (2 * $int / $EDO)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
										#n=$(($total_seconds_tt-$total_seconds_dateo))
										#total_seconds_dateo=$(($total_seconds_tt+$n))
										#total_seconds_dateo="`echo -ne \"$total_seconds_dateo\" | cut -c 2-`"
									else
										#total_seconds_dateo="`calc \"$total_seconds_tt * (0.5 * -$int / $EDO)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
										total_seconds_dateo="`calc \"$total_seconds_tt * (($int / $EDO)/2)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
										total_seconds_dateo=$(($total_seconds_tt-$total_seconds_dateo))
										#total_seconds_dateo="`echo -ne \"$total_seconds_dateo\" | cut -c 2-`"
									fi
									#calc "$total_seconds_tt * (2 * $int / $EDO)"
									#diff_seconds=$(($total_seconds_tt-$total_seconds_dateo))
									#new_minutes=$(($diff_seconds / 60))
									new_minutes=$(($total_seconds_dateo / 60))
									new_seconds=$(($total_seconds_dateo % 60))
									#if [ "`echo -ne \"$new_minutes\" | cut -c 1`" == "0" ]; then
									#	new_minutes="`echo -ne \"$new_minutes\" | rev | cut -c 1 | rev`"
									#fi
									#if [ "`echo -ne \"$new_seconds\" | cut -c 1`" == "0" ]; then
									#	new_seconds="`echo -ne \"$new_seconds\" | rev | cut -c 1 | rev`"
									#fi
									#new_seconds=$(($diff_seconds % 60))
								else
									new_minutes=$minutes
									new_seconds=$seconds
								fi
								tput cup $LINES $(($COLS-1-5))
								new_minutes="`printf '%02d' $new_minutes`"
								new_seconds="`printf '%02d' $new_seconds`"
								echo -ne "$BLUE$new_minutes$WHITE:$BLUE$new_seconds"
								if [ "`isnum \"$percent\"`" == "0" ]; then
									percent=$total_
								fi
								percent=`calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1`
								if [ "$percent" -gt "$total_" ]; then
									percent="$total_"
								fi
								
								#tput cup $LINES $((1+1))
								tput cup $LINES $((1+7))
								echo -ne "$WHITE_BLACK"
								printf '%*s' $percent | tr " " "="
								printf '%*s' $(($total_ - $percent))
							fi
						fi
						#if [ "`jobs | grep \"Running\"`" == "" ]; then
						#fi
						read -n1 -t 1 throwaway
						if [ "$throwaway" == "l" ]; then
							if [ "$old_percent" -gt "$percent" ]; then
								percentbreak=true
								break
							fi
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							ps -p $MPLAYER_PID >/dev/null
							if [ "$?" == "1" ]; then
								#sleep 1
								#throwaway2=""
								#until [ "$throwaway2" != "" ]; do
								#	read -n1 -t 0.01 throwaway2
								#done
								#kill $MPLAYER_PID >/dev/null 2>/dev/null
								#return 0
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
										JUMP="1"
										return $RETURN_JUMP
									else
										return 0
									fi
								fi
								#break
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							old_throwaway="$throwaway"
							throwaway=""
						elif [ "$throwaway" == "h" ]; then
							#if [ "$old_percent" -lt "$percent" ]; then
							#	percentbreak=true
							#	break
							#fi
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_position
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							old_throwaway="$throwaway"
							throwaway=""
						elif [ "$throwaway" == "j" ]; then
							pitch_down false true
							old_throwaway="$throwaway"
							throwaway=""
						elif [ "$throwaway" == "k" ]; then
							pitch_up false true
							old_throwaway="$throwaway"
							throwaway=""
						else
							old_throwaway=""
						fi
						l=0
						old_percent=$percent
					done
					if [ "$percentbreak" == true ]; then
						#throwaway2="x"
						#until [ "$throwaway2" == "" ]; do
						#	read -n1 -t 0.01 throwaway2
						#done
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST
						else
							if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
								JUMP="1"
								return $RETURN_JUMP
							else
								return 0
							fi
						fi
						#break
					fi
					if [ "$MUTE" == true ]; then
						draw_banner "MUTE"
					else
						draw_pitch
					fi
					draw_position
					espeak_say_natural "closed"
				fi
				;;
			#'|')
			#	about

			#	draw_volume
			#	draw_equalizer
			#	draw_pitch
			#	draw_position
			#	redraw_buffer
			#	;;
			'$')
				espeak_say_natural "position saved"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.05
				draw_banner "POS SAVED"
				sleep 0.25
				if [ "$SAVED_POSITION" == "" ]; then
					SAVED_TOTAL=1
					SAVED_POSITION[1]="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
					CURRENT_POSITION=1
				else
					SAVED_TOTAL=$(($SAVED_TOTAL+1))
					SAVED_POSITION[$SAVED_TOTAL]="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				fi
					
				draw_pitch
				draw_position
				;;
			'|')
				vanish
				;;
#				feedback_enabled=false
#				inputnew=""
#				display=""
#				escape_pressed=false
#				char_count=0
#				line_count=1
#				word_count=0
#				width=$(($COLS-((${#char_count}+2+${#word_count}+${#line_count})*2)-(${#PADDING}*2)-8))
#				#if [ "$width" -gt "$(($COLS-((${#char_count}-2-${#word_count}-${#line_count}-2)*2)))" ]; then
#				#	echo -ne "$RED OK"
#				#	width="$(($COLS-((${#char_count}-2-${#word_count}-${#line_count}-2)*2)))"
#				#fi
#				#if [ "$width" -gt "$(($COLS-(${#char_count}-2-${#word_count}-${#line_count}-2)/2))" ]; then
#				#	width="$(($COLS-(${#char_count}-2-${#word_count}-${#line_count}-2)/2))"
#				#fi
#				tput cup $LINES
#				#echo -ne "$PADDING"
#				tput el
#				tput cup $LINES
#				echo -ne "${PADDING}$WHITE- ${BLUE}INS$WHITE -"
#				tput cup $LINES $(($COLS/2))
#				echo -ne "${BLUE}_"
#				tput sc
#				visible=true
#				char=""
#				draw_indicator() {
#					tput cup $LINES $(($COLS-${#char_count}-2-${#word_count}-${#line_count}-${#PADDING}))
#					echo -ne "$BLUE${char_count}$WHITE:$BLUE${word_count}$WHITE:$BLUE${line_count}$RIGHTPADDING"
#				}
#				draw_indicator
#				tput rc
#				until [ "$char" != "" ]; do
#					read -rsn1 -t 1 char
#					tput cub1
#					if [ "$visible" == true ]; then
#						echo -ne "${BLUE} "
#					else
#						echo -ne "${BLUE}_"
#					fi
#				done
#				tmpflag=true
#				quit=false
#				while true; do
#					#tput cup $LINES
#					#tput el
#					#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#					tput cup $LINES
#					echo -ne "${PADDING}$WHITE- ${BLUE}INS$WHITE - "
#					draw_indicator
#					#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#					#if [ "$cursor_visible" == true ]; then
#					#	cursor_visible=false
#					#	tput cup $LINES $(($COLS/2))
#					#	echo -ne " "
#					#else
#					#	cursor_visible=true
#					#	tput cup $LINES $(($COLS/2))
#					#	echo -ne "${BLUE}_"
#					#fi
#					if [ "$tmpflag" == false ]; then
#						#if [ "$char" == "" ]; then
#						read -rsn1 char
#					else
#						tmpflag=false
#					fi
#					# Exit loop on Escape : q key combination
#					preword=false
#					#if [ true == false ]; then
#					if [[ $char == $'\e' ]]; then
#						#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#						tput cup $LINES
#						echo -ne "$PADDING$WHITE- ${BLUE}ESC$WHITE -"
#						#if [ "$VOICE_ENABLED" == true ]; then
#						#	espeak-ng "Command?" &
#						#fi
#						#tput cup $LINES 1
#						#echo -ne "\033[36m-- \033[34m~ \033[36m--"
#						#tput el
#						#echo -ne "     "
#						#escape_pressed=true
#						while true; do
#							read -rsn1 newchar
#							if [ "$newchar" == "q" ]; then
#								#if [ "$VOICE_ENABLED" == true ]; then
#								#	espeak-ng "Quit" &
#								#fi
#								#clear
#								#stty echo
#								#tput cnorm
#								#exit 0
#								draw_pitch
#								draw_position
#								quit=true
#								break
#							elif [ "$newchar" == "h" ]; then
#								if [ "$width" -gt "$((($COLS*5)/8))" ]; then
#									continue
#									#			width="$(($COLS-1))"
#									#		elif [ "$width" == "$COLS" ]; then
#									#			width="$(($COLS-1))"
#								fi
#								width="$(($width+2))"
#								newdisplay="`echo -ne \"$display\" | tail -c $width`"
#								if [ "${char_count}" -le "$(($width))" ]; then
#									#tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))))
#									tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
#								else
#									#tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
#									tput cup $LINES $((($COLS/2)-($width/2)))
#								fi
#
#							    #tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
#							    #printf "%s" "\033[36m$newdisplay" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[32m\2\o033[36m\3/g'
#							    echo -ne "$WHITE${newdisplay}${BLUE}_"
#							    tput el
#							    draw_indicator
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #	echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#						    elif [ "$newchar" == "l" ]; then
#							    width="$(($width-2))"
#							    if [ "$width" -lt "0" ]; then
#								    width=0
#							    fi
#							    newdisplay="`echo -ne \"$display\" | tail -c $width`"
#							    if [ "${char_count}" -le "$(($width))" ]; then
#								    tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
#							    else
#								    tput cup $LINES $((($COLS/2)-($width/2)))
#							    fi
#							    #tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
#							    tput cub1
#							    echo -ne " "
#							    #printf "%s" "$newdisplay" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[32m\2\o033[36m\3/g'
#							    echo -ne "$WHITE${newdisplay}${BLUE}_"
#							    tput el
#							    draw_indicator
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    #tput el
#						    elif [ "$newchar" == "w" ]; then
#							    #if [ "$VOICE_ENABLED" == true ]; then
#							    espeak_say_natural "saved"
#							    #fi
#							    #echo -ne "$inputnew" >journal-"`date`"
#							    inputnew=$(fold -w 80 -s <<< "$inputnew")
#							    echo -ne "\n\n`date`\n\n$inputnew\n" >>"$HOME/Documents/journal"
#							    tput cup $LINES
#							    #echo -ne "\033[36m-- \033[34mWRITTEN \033[36m--"
#							    echo -ne "$PADDING$WHITE- ${BLUE}SAVE$WHITE -"
#							    #tput el
#							    sleep 1.6
#							    tput cup $LINES
#							    #echo -ne "\033[36m-- \033[34m~ \033[36m--"
#							    echo -ne "$PADDING$WHITE- ${BLUE}ESC$WHITE - "
#							    #tput el
#							    printf '%*s' 9
#						    elif [ "$newchar" == "n" ]; then
#							    #if [ "$VOICE_ENABLED" == true ]; then
#							    espeak_say_natural "new entry"
#							    #fi
#							    inputnew=""
#							    display=""
#							    char_count=0
#							    #tput cup $(($LINES/2))
#							    #tput el
#							    tput cup $LINES
#							    tput el
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    draw_indicator
#							    break
#							    #elif [ "$newchar" == "o" ]; then
#							    #	    #if [ "$VOICE_ENABLED" == true ]; then
#							    #		    espeak_say_natural "editing journal"
#							    #	    #fi
#							    #	    vim $HOME/Documents/txt +$
#							    #	    stty -echo
#							    #	    tput civis
#							    #	    #if [ "$VOICE_ENABLED" == true ]; then
#							    #		    espeak_say_natural "insert mode"
#							    #	    #fi
#							    #	    tput cup $LINES 1
#							    #	    echo -ne "\033[36m-\033[34mINS\033[36m-"
#							    #	    tput el
#							    #	tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #	echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    #	    break
#						    elif [ "$newchar" == "d" ]; then
#							    if [ "$VOICE_ENABLED" == true ]; then
#								    espeak_say_natural "off"
#								    VOICE_ENABLED=false
#								    feedback_enabled=false
#							    else
#								    VOICE_ENABLED=true
#								    espeak_say_natural "on"
#								    feedback_enabled=true
#							    fi
#
#							    #if [ "$VOICE_ENABLED" == true ]; then
#							    #	    VOICE_ENABLED=false
#							    #	    espeak-ng "Off" &
#							    #    else
#							    #	    VOICE_ENABLED=true
#							    #	    espeak-ng "On" &
#							    #    fi
#						    elif [ "$newchar" == "v" ]; then
#							    fold -w $COLS -s <<< "$inputnew" | less
#							    #echo -ne "$inputnew" | less
#							    #if [ "$VOICE_ENABLED" == true ]; then
#							    espeak_say_natural "insert mode"
#							    #fi
#							    tput cup $LINES 1
#							    echo -ne "\033[36m-\033[34mINS\033[36m-"
#							    tput el
#							    draw_indicator
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    break
#						    elif [ "$newchar" == "i" ]; then
#							    draw_indicator
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    #if [ "$VOICE_ENABLED" == true ]; then
#							    espeak_say_natural "insert mode"
#							    #fi
#							    #tput cup $LINES 1
#							    #echo -ne "\033[36m-\033[34mINS\033[36m-"
#							    #tput el
#							    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#							    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#							    break
#							fi
#						done
#						if [ "$quit" == true ]; then
#							break
#						fi
#						#while [ "$newchar" != "q" ] || [ "$newchar" != "i" ]; do
#						#	if [ "$newchar" == "q" ]; then
#						#		break
#						#	elif [ "$newchar" == "i" ]; then
#						#		escape_pressed=false
#						#		break
#						#	else
#						#		continue
#						#	fi
#						#	read -rsn1 newchar
#						#done
#					elif [ "$char" == $'' ]; then
#						if [ "$char_count" -gt "0" ]; then
#							newchar="`echo -ne \"$inputnew\" | rev | cut -c 1`"
#							if [ "$newchar" == " " ]; then
#								if [ "$inword" == true ]; then
#									inword=false
#									word_count=$(($word_count-1))
#									draw_indicator
#									#else
#								fi
#								preword=true
#								#fi
#							elif [ "$newchar" != " " ]; then
#								inword=true
#							elif [ "$preword" == true ]; then
#								inword=true
#								preword=false
#						fi
#						inputnew="`echo -ne \"$inputnew\" | rev | cut -c2- | rev`"
#						display="`echo -ne \"$display\" | rev | cut -c2- | rev`"
#						char_count=$(($char_count-1))
#						draw_indicator
#						#tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#						#echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#						if [ "$word" != "" ]; then
#							word="`echo -ne \"$word\" | rev | cut -c2- | rev`"
#						fi
#						#newdisplay="`echo -ne \"$display\" | tail -c $width`"
#						#tput sc
#						if [ "${char_count}" -lt "$(($width))" ]; then
#							#tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))-1))
#							tput cup $LINES $((($COLS/2)-$((${char_count}/2))-1))
#							#else
#							#	    tput cup $(($LINES/2)) $((($COLS/2)-($width/2)-1))
#							echo -ne " "
#						fi
#						#    printf "%s" " ${newdisplay}_" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[37m\2\o033[36m\3/g'
#						#    tput el
#						#    tput rc
#						#else
#						#	if [ "$VOICE_ENABLED" == true ]; then
#						#		espeak-ng "Beginning" &
#						#		sleep 1
#						#	fi
#						fi
#					elif [ "$char" == "" ]; then
#						killall espeak-ng >/dev/null 2>/dev/null
#						killall play >/dev/null 2>/dev/null
#						espeak-ng " $inputnew" &
#					elif [ "$char" == "" ]; then
#						killall espeak-ng >/dev/null 2>/dev/null
#						killall play >/dev/null 2>/dev/null
#					else
#
#				    #elif [[ $char == ':' && $escape_pressed == true ]]; then
#				    #    escape_pressed=false
#				    #    display=""
#				    #    continue
#				    #elif [[ $char == 'q' && $escape_pressed == true ]]; then
#				    #    break
#				    #else
#				    #    escape_pressed=false
#				    #fi
#				    char_count=$(($char_count+1))
#				    if [ "$char" == "" ]; then
#					    preword=false
#					    inputnew="${inputnew} "
#					    display="${display} "
#					    #if [ "$VOICE_ENABLED" == true ]; then
#					    if [ "$feedback_enabled" == true ]; then
#						    espeak-ng "$word" &
#					    fi
#					    if [ "$inspace" == false ]; then
#						    word_count=$(($word_count+1))
#					    fi
#					    inspace=true
#					    #fi
#					    word=""
#				    else
#					    preword=false
#					    inputnew="${inputnew}${char}"
#					    display="${display}${char}"
#					    if [ "$inspace" == true ]; then
#						    inspace=false
#						    inword=true
#					    fi
#					    if [ "$char" == "." ] || [ "$char" == "?" ] || [ "$char" == "," ] || [ "$char" == "!" ]; then
#						    #if [ "$VOICE_ENABLED" == true ]; then
#						    if [ "$feedback_enabled" == true ]; then
#							    espeak-ng "$word" &
#						    fi
#						    word_count=$(($word_count+1))
#						    inword=false
#						    #fi
#						    word=""
#					    else
#						    word="$word$char"
#					    fi
#				    fi
#				    fi
#				    #tput el
#				    #display="${display: -80}"
#				    newdisplay="`echo -ne \"$display\" | tail -c $width`"
#				    tput sc
#				    if [ "${char_count}" -le "$(($width))" ]; then
#					    #tput cup $(($LINES/2)) $((($COLS/2)-$((${char_count}/2))))
#					    tput cup $LINES $((($COLS/2)-$((${char_count}/2))))
#				    else
#					    #tput cup $(($LINES/2)) $((($COLS/2)-($width/2)))
#					    tput cup $LINES $((($COLS/2)-($width/2)))
#				    fi
#				    #printf "%s" "${newdisplay}_" | sed 's/^\(.\)\(.*\)\(.\)$/\o033[36m\1\o033[37m\2\o033[36m\3/g'
#				    echo -ne "$WHITE${newdisplay}${BLUE}_ \b"
#				    #tput el
#				    #tput cup $LINES $(($COLS-${#char_count}-1-4-${#line_count}))
#				    #echo -ne "${BLUE}INS$WHITE:$BLUE${char_count}$WHITE:$BLUE${line_count}"
#				    draw_indicator
#				    tput rc
#			    done
#			    ;;
			'`')
				draw_banner "COMMAND"
				command="`read_line`"
				if [ "$command" != "" ]; then
					echo -e "$command" >"$ALETHEIA/pipe$$" &
					sleep 0.7
					empty_pane
					tput cup $(($LINES-3))
					echo -ne "$PADDING$CYAN`tail -1 \"$ALETHEIA/mplayer_output\"`"
					tput el
					read -n1 throwaway
				fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			#'[')
			#	master_volume_change "-1% +0%"
			#	;;
			#']')
			#	master_volume_change "+0% -1%"
			#	;;
			#'{')
			#	master_volume_change "+1% +0%"
			#	;;
			#'}')
			#	master_volume_change "+0% +1%"
			#	;;
			'\')
				SAVED_POSITION=""
				CURRENT_POSITION=""
				if [ "$VIDEO" == true ] || [ "$VIDEO_FLAGGED" == true ]; then
					JUMP="$POSITION"
					kill $MPLAYER_PID 2>/dev/null >/dev/null
					if [ "$VIDEO" == false ]; then
						VIDEO_FLAGGED=false
					fi
					return $RETURN_JUMP
				else
					echo "seek 0 2" >"$ALETHEIA/pipe$$" &
					if [ "$PAUSE" == true ]; then
						PAUSE=false
						draw_pitch
						draw_position
					fi
				fi
				#echo "quit 0" >"$ALETHEIA/pipe$$" &
				#kill $MPLAYER_PID >/dev/null 2>/dev/null
				#return $RETURN_RESTART
				;;
			'5')
				draw_banner "START"
				espeak_say_natural "start"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.7
				CURRENT_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				draw_pitch
				draw_position
				;;
			'%')
				#if [ "$CURRENT_TIME" != "" ]; then
				#	espeak_say_natural "Replay"
				#	echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
				#fi
				rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
				espeak_say_natural "unlocked"
				tput cup $(($LOCKING_POS+2)) $((1))
				#if [ -e "$FILENAME.locked" ]; then
				#	echo -ne "${BLUE}#"
				#else
				#	echo -ne "$NOCOLOR "
				#fi
				if [ "$ONLY_DISPLAY_SONG" == false ]; then
					if [ -e "$FILENAME.locked" ]; then
						#if [ -e "$FILENAME.repeats" ]; then
						#	FLAGGY="$BLUE#"
						#else
							FLAGGY="${WHITE_BLACK}&"
						#fi
					else
						#if [ -e "$line.repeats" ]; then
						#	FLAGGY="$CYAN#"
						#else
							FLAGGY="$BLUE_BLACK "
						#fi
					fi
					echo -ne "$FLAGGY"
				fi
				;;
			'7')
				draw_banner "END"
				espeak_say_natural "end"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.7
				END_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				etime=$END_TIME
				space=0
				draw_pitch
				draw_position
				#time="`calc \"$END_TIME-$CURRENT_TIME\" | sed -e \"s/\t//g\"`"
				#read -n1 -t 0.5 throwaway
				#until [ "$throwaway" == "q" ]; do
				#	echo "seek $CURRENT_TIME 2" >"$ALETHEIA/pipe$$" &
				#	read -n1 -t $time throwaway
				#	#sleep $time
				#done
				;;
			#'^')
			#	#if [ -e "$FILENAME.repeats" ]; then
			#	#	repeats="`cat \"$FILENAME.repeats\"`"
			#	#	CURRENT_TIME="`echo -ne \"$repeats\" | cut -d '/' -f1`"
			#	#	END_TIME="`echo -ne \"$repeats\" | cut -d '/' -f2`"
			#	#	space="`echo -ne \"$repeats\" | cut -d '/' -f3`"
			#	#fi
			#	CURRENT_TIME=0.0
			#	END_TIME=5.0
			#	space=0
			#	;;
			'&')
				ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
				filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
				#tmp=$(printf '%s\n' ${queue_array[@]} | grep -n "$filename_without_ext.repeat.$ext" | cut -d':' -f1 | head -1)
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					SELECT_REPEAT_FILE=true
					JUMP="$POSITION"
					kill $MPLAYER_PID
					return $RETURN_JUMP
				else
					espeak_say_natural "none"
					draw_banner "NONE"
					sleep 0.25
					draw_pitch
					draw_position
				fi
				;;
			#'&')
			#	if [ -e "$FILENAME.repeats" ]; then
			#		espeak_say_natural "Unlocked"
			#		rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
			#		tput cup $(($LOCKING_POS+2)) $((1))
			#		if [ -e "$FILENAME.locked" ]; then
			#			FLAGGY="$BLUE$"
			#		else
			#			FLAGGY="$NOCOLOR "
			#		fi
			#		echo -ne "$FLAGGY"
			#	else
			#		echo "$CURRENT_TIME/$END_TIME/$space" >"$FILENAME.repeats"
			#		espeak_say_natural "Locked"
			#		tput cup $(($LOCKING_POS+2)) $((1))
			#		if [ -e "$FILENAME.locked" ]; then
			#			#if [ -e "$FILENAME.repeats" ]; then
			#				FLAGGY="$BLUE#"
			#			#else
			#			#	FLAGGY="$CYAN#"
			#			#fi
			#		else
			#			#if [ -e "$line.repeats" ]; then
			#				FLAGGY="$BLUE&"
			#			#else
			#			#	FLAGGY="$NOCOLOR "
			#			#fi
			#		fi
			#		echo -ne "$FLAGGY"
			#	fi
			#	;;
			'6')
				repeat
				repeat_tmp="$?"
				if [ "$repeat_tmp" != "200" ] && [ "$repeat_tmp" != "300" ]; then
					return $repeat_tmp
				#elif [ "$repeat_tmp" == "300" ]; then
				#	add_downloaded
				#	ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
				#	filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
				#	tmp=$(printf '%s\n' "${queue_array[@]}" | grep -n "$filename_without_ext.repeat.$ext" | cut -d':' -f1 | head -1)
				#	JUMP="$tmp"
				#	#KEEP_LOOP=true
				#	kill $MPLAYER_PID >/dev/null 2>/dev/null
				#	return $RETURN_JUMP
				fi
				;;
			'0')
				MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
				MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
				MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
				#MIXER_OUTPUT="`amixer sset Master - | grep \"Front\" | grep \"\[\"`"
				#MASTER_VOLUME_LEFT="`echo \"$MIXER_OUTPUT\" | grep Left | cut -d'[' -f2 | cut -d']' -f1`"
				#MASTER_VOLUME_RIGHT="`echo \"$MIXER_OUTPUT\" | grep Right | cut -d'[' -f2 | cut -d']' -f1`"

				tmp_volume_left="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
				tmp_volume_right="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					total="$tmp_volume_left"
					right=true
				elif [ "$tmp_volume_right" -gt "$tmp_volume_left" ]; then
					total="$tmp_volume_right"
					right=false
				else
					continue
				fi

				espeak_say_natural "balancing volume"

				draw_banner "BALANCING"

				flaggy=false
				while [ "$tmp_volume_left" != "$tmp_volume_right" ]; do
					if [ "$tmp_volume_left" -lt "$total" ]; then
						tmp_volume_left=$(($tmp_volume_left+1))
					elif [ "$tmp_volume_left" -gt "$total" ]; then
						tmp_volume_left=$(($tmp_volume_left-1))
					fi

					if [ "$tmp_volume_right" -lt "$total" ]; then
						tmp_volume_right=$(($tmp_volume_right+1))
					elif [ "$tmp_volume_right" -gt "$total" ]; then
						tmp_volume_right=$(($tmp_volume_right-1))
					fi

					MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
					MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
					MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
					pactl set-sink-volume @DEFAULT_SINK@ ${tmp_volume_left}% ${tmp_volume_right}%
					#MIXER_OUTPUT="`amixer sset Master ${tmp_volume_left}%,${tmp_volume_right}% | grep \"Front\" | grep \"\[\"`"
					#MASTER_VOLUME_LEFT="`echo \"$MIXER_OUTPUT\" | grep Left | cut -d'[' -f2 | cut -d']' -f1`"
					#MASTER_VOLUME_RIGHT="`echo \"$MIXER_OUTPUT\" | grep Right | cut -d'[' -f2 | cut -d']' -f1`"
					draw_volume 2 3
					read -rsn1 -t 0.08 c
					ps -p $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "0" ]; then
						flaggy=true
						break
					elif [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 0 1
						draw_banner "BALANCING"
					fi
				done
				draw_pitch
				if [ "$flaggy" == true ]; then
					MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
					MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
					MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
					#MASTER_VOLUME_LEFT="`amixer sset Master - | grep \"Front Left\" | tail -1 | cut -d'[' -f2 | cut -d']' -f1`"
					#MASTER_VOLUME_RIGHT="`amixer sset Master - | grep \"Front Right\" | tail -1 | cut -d'[' -f2 | cut -d']' -f1`"
					#espeak_say " $MASTER_VOLUME_LEFT $MASTER_VOLUME_RIGHT"
					continue
				fi
				#espeak_say " ${tmp_volume_left}"
				;;
			')')
				MIXER_OUTPUT="`pactl get-sink-volume @DEFAULT_SINK@ | sed -e \"s/ /\n/g\" | sed -e \"/^$/d\" | grep \"%\"`"
				MASTER_VOLUME_LEFT="`echo -ne \"$MIXER_OUTPUT\" | head -1`"
				MASTER_VOLUME_RIGHT="`echo -ne \"$MIXER_OUTPUT\" | tail -1`"
				tmp_volume_left="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
				tmp_volume_right="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					MASTER_VOLUME_RIGHT="${tmp_volume_left}%"
				else
					MASTER_VOLUME_LEFT="${tmp_volume_right}%"
					tmp_volume_left=$tmp_volume_right
				fi

				pactl set-sink-volume @DEFAULT_SINK@ $MASTER_VOLUME_LEFT $MASTER_VOLUME_RIGHT
				draw_volume
				espeak_say " $tmp_volume_left"
				;;
			'G')
				oscillate
				;;
			'g')
				if [ "$PAUSE" == true ]; then
					echo -e "pause" >$ALETHEIA/pipe$$ &
					PAUSE=false
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
				fi
				draw_banner "INVERT" false true
				old_int="$INTERVAL"
				INTERVAL="$((-($INTERVAL)))"
				espeak_say_natural "scaling"
				if [ "$INTERVAL" -lt "0" ]; then
					result="$old_int"
				else
					result="$INTERVAL"
				fi
				result="$(($result*2))"
				x=0
				if [ "$old_int" -gt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				while [ "$x" -lt "$result" ]; do
					read -rsn1 -t $SCALE_SPEED c
					ps -p $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					secondary_scale_func "$c" "INVERT"
					if [ "$c" == "c" ]; then
						#x=$(($result-$x-2))
						x=$(($result-$x))
						if [ "$NEGATIVE" == true ]; then
							NEGATIVE=false
						else
							NEGATIVE=true
						fi
					#FIXME
					elif [ "$c" == "o" ]; then
						old_int=$(($old_int*2))
					elif [ "$c" == "m" ]; then
						old_int=$INTERVAL
					elif [ "$c" == "z" ]; then
						x2=$x
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "INVERT" false true
						x=$x2
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
						draw_banner "INVERT" false true
					elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "m" ]; then
						#espeak_say_natural " $INTERVAL of $EDO"
						break
					elif [ "$c" == "" ]; then
						if [ "$NEGATIVE" == false ]; then
							INTERVAL="$(($old_int-1))"
							old_int="$(($old_int-1))"
						else
							INTERVAL="$(($old_int+1))"
							old_int="$(($old_int+1))"
						fi
						echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						draw_pitch
						x="$(($x+1))"
					fi

				done
				espeak_say " $INTERVAL $EDO"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'M')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
				fi
				INTERVAL="$((-($INTERVAL)))"
				echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				espeak_say " $INTERVAL $EDO"
				#if [ "$INTERVAL" -lt "0" ]; then
				#	if [ "$SCALETEMPO" == true ] && [ "$ONLY_PITCH" == false ]; then
				#		SCALETEMPO=false
				#		echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
				#	fi
				#fi
				draw_pitch
				;;
			'f')
				tmux_attach
				;;
			'F')
				yt_search
				;;
			'C')
				yt_artist
				;;
			'W')
				add_downloaded
				;;
			#'$')
			#	if [ "$ONLY_LOCKED" == true ]; then
			#		set_only_locked false true
			#	else
			#		set_only_locked true
			#	fi
			#	;;
			'J')
				#if [ "$VOICE_ENABLED" == true ]; then
				#	if [ "$LOCKED" == true ]; then 
				#		espeak_say_natural " $INTERVAL of $EDO. Locked."
				#	else
				#		espeak_say_natural " $INTERVAL of $EDO"
				#	fi
				#	if [ "$SCALETEMPO" == true ]; then
				#		espeak_say_natural " Scale tempo on."
				#	fi
				#fi
				edo_down
				;;
		#	'I')
		#		if [ "$VOICE_ENABLED" == true ]; then
		#			res="`echo -ne \"$equal\" | sed -e \"s/:/, /g\"`"
		#			if [ "$res" == "0, 0, 0" ]; then
		#				espeak_say_natural "0"
		#			else
		#				espeak_say " $res"
		#			fi
		#		fi
		#		;;
			'I')
				#draw_banner "STATUS"
				#espeak_say_natural "Status"
				#read -n1 x
				#if [ "$x" == "1" ]; then
				#	#if [ "$VOICE_ENABLED" == true ]; then
				#		tmp="`echo $MASTER_VOLUME_LEFT | cut -d'%' -f1`"
				#		tmp2="`echo $MASTER_VOLUME_RIGHT | cut -d'%' -f1`"
				#		tmp3="`echo $VOLUME | cut -d'%' -f1`"
				#		if [ "$tmp" != "$tmp2" ]; then
				#			espeak_say_natural " $tmp3, $tmp and $tmp2" true
				#		else
				#			espeak_say_natural " $tmp3, $tmp" true
				#		fi
				#	#fi
				#elif [ "$x" == "2" ]; then
				#	#if [ "$VOICE_ENABLED" == true ]; then
				#		res="`echo -ne \"$equal\" | sed -e \"s/:/, /g\"`"
				#		if [ "$res" == "0, 0, 0" ]; then
				#			espeak_say_natural "0" true
				#		else
				#			espeak_say_natural " $res" true
				#		fi
				#	#fi
				#elif [ "$x" == "3" ]; then
				#	#if [ "$VOICE_ENABLED" == true ]; then
				#		if [ "$LOCKED" == true ]; then 
				#			espeak_say_natural " $INTERVAL of $EDO. Locked." true
				#		else
				#			espeak_say_natural " $INTERVAL of $EDO" true
				#		fi
				#		if [ "$SCALETEMPO" == true ]; then
				#			espeak_say_natural " Scale tempo on." true
				#		fi
				#	#fi
				#elif [ "$x" == "4" ]; then
				#	espeak_say_natural " $POSITION of $TOTAL_QUEUE." true
				#fi
				#draw_pitch
				say_status
				;;
			'K')
				#espeak_say_natural " $POSITION of $TOTAL_QUEUE."
				edo_up
				;;
			'<')
				if [ "$VIDEO" == true ]; then
					espeak_say_natural "video disabled"
					VIDEO=false
					draw_banner "OFF"
				else
					espeak_say_natural "video enabled"
					VIDEO=true
					VIDEO_FLAGGED=true
					draw_banner "VIDEO ON"
					#sleep 0.25
				fi
				#stty -echo
				#sleep 0.25
				#stty echo
				#RIGHT_BANNER_WIDTH=0
				#draw_pitch
				#draw_position
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				JUMP="$POSITION"
				return "$RETURN_JUMP"
				;;
			'>')
				if [ "$FULLSCREEN" == false ]; then
					echo "pausing_keep vo_fullscreen 1" >$ALETHEIA/pipe$$ &
					FULLSCREEN=true
					espeak_say_natural "video fullscreen"
					draw_banner "FULLSCREEN"
				else
					espeak_say_natural "video normal"
					echo "pausing_keep vo_fullscreen 0" >$ALETHEIA/pipe$$ &
					FULLSCREEN=false
					draw_banner "OFF"
				fi
				stty -echo
				sleep 0.25
				stty echo
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'U')
				scale_edo
				;;
			'Z')
				espeak_say_natural "save queue as?"
				draw_banner "SAVE QUEUE"
				tmp="`read_line`"
				if [ "$tmp" != "" ]; then
					if [ ! -e "$ALETHEIA/playlists/" ]; then
						mkdir "$ALETHEIA/playlists"
					fi
					#echo -ne "$QBUFFER" >"$ALETHEIA/playlists/$tmp"
					echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
					espeak_say_natural "saved"
				else
					espeak_say_natural "canceled"
				fi
				draw_pitch
				draw_position
				;;
#			'Z')
#				draw_banner "WAIT"
#				espeak_say_natural "reversing"
#				new_file="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev` - reversed.mp3"
#				ffmpeg -i "$FILENAME" -af areverse "$new_file" >/dev/null 2>/dev/null
#				espeak_say_natural "finished"
#				QBUFFER="$QBUFFER\n$new_file"
#
#				JUMP="$(($TOTAL_QUEUE+1))"
#				echo "quit 0" >"$ALETHEIA/pipe$$" &
#				kill $MPLAYER_PID >/dev/null 2>/dev/null
#				return $RETURN_JUMP
#
#				TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
#				draw_pitch
#				;;
			'c')
				toggle_mute
				;;
			't')
				zero_interval
				if [ "$?" == "$RETURN_QUIT" ]; then
					return $RETURN_QUIT
				fi
				;;
			'H')
				less_precise
				;;
			'L')
				more_precise
				;;
			'Y')
				#PAUSE=false
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#if [ "$INTERVAL" != "0" ]; then
				#	SAVED_INTERVAL="$INTERVAL"
				#	SAVED_EDO="$EDO"
				#	INTERVAL="$DEFAULT_INTERVAL"
				#	#FIXME
				#	#EDO="$DEFAULT_EDO"
				#	EDO="$SAVED_EDO"
				#	echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				#	espeak_say_natural " $INTERVAL of $EDO"
				#else
				#	if [ "$SAVED_INTERVAL" != "" ]; then
				#		INTERVAL="$SAVED_INTERVAL"
				#		EDO="$SAVED_EDO"
				#		echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
				#		espeak_say_natural " $INTERVAL of $EDO"
				#	else
				#		continue
				#	fi
				#fi
				##INTERVAL_LIMIT=$(($EDO * 3))
				#INTERVAL_LIMIT=`calc "$EDO * 2.6"`
				#INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.0"`
				#draw_pitch
				zero_interval_jump
				;;
			'x')
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					espeak_say_natural "unlocked"
					if [ "$ONLY_DISPLAY_SONG" == false ]; then
						if [ -e "$FILENAME.repeats" ]; then
							echo -ne "${WHITE_BLACK}&"
						else
							echo -ne "$BLUE_BLACK "
						fi
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						#echo "$INTERVAL/$EDO/$VOLUME/$EQUALIZER/1" >"$FILENAME".locked
						if [ "$ONLY_PITCH" == true ]; then
							echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/2" >"$FILENAME".locked
						else
							echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/1" >"$FILENAME".locked
						fi
					else
						#echo "$INTERVAL/$EDO/$VOLUME/$EQUALIZER/0" >"$FILENAME".locked
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/0" >"$FILENAME".locked
					fi
					LOCKED=true
					espeak_say_natural "locked"
					if [ "$ONLY_DISPLAY_SONG" == false ]; then
						if [ -e "$FILENAME.repeats" ]; then
							echo -ne "${WHITE_BLACK}#"
						else
							echo -ne "${WHITE_BLACK}$"
						fi
					fi
				fi
				;;
			'a')
				PAUSE=false
				set_equalizer
				draw_pitch
				;;
			'')
				if [ "$CURRENT_POSITION" != "" ]; then
					CURRENT_POSITION=$(($CURRENT_POSITION+1))
					if [ "$CURRENT_POSITION" -gt "$SAVED_TOTAL" ]; then
						CURRENT_POSITION=1
					fi
					echo "seek ${SAVED_POSITION[$CURRENT_POSITION]} 2" >"$ALETHEIA/pipe$$" &
				fi
				;;
			#'')
			#	if [ "$CENTER_BAR_POSITION" -gt "-7" ]; then
			#		CENTER_BAR_POSITION=$(($CENTER_BAR_POSITION-1))
			#		reset_buffer
			#		redraw_buffer
			#	fi
			#	;;
			#'')
			#	if [ "$CENTER_BAR_POSITION" -lt "7" ]; then
			#		CENTER_BAR_POSITION=$(($CENTER_BAR_POSITION+1))
			#		reset_buffer
			#		redraw_buffer
			#	fi
			#	;;
			'v')
				toggle_scale_tempo
				;;
			'')
				old_blue=$BLUE
				espeak_say_natural "color randomized"
				BLUE=$(generate_random_color)
				color="${BLUE#"#"}"
				red=$((16#${color:0:2}))
				green=$((16#${color:2:2}))
				blue=$((16#${color:4:2}))
				BLUE="\033[1;38;2;${red};${green};${blue}m"
				BLUE_BLACK="\033[1;38;2;${red};${green};${blue}m"

				WHITE=$(generate_random_color)
				color="${WHITE#"#"}"
				red=$((16#${color:0:2}))
				green=$((16#${color:2:2}))
				blue=$((16#${color:4:2}))
				WHITE="\033[1;38;2;${red};${green};${blue}m"
				WHITE_BLACK="\033[1;38;2;${red};${green};${blue}m"
				#render_help_screen
				#render_voice_settings_screen
				#render_repeat_help_screen
				redraw_screen
				;;
			'')
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					#espeak_say_natural "Playing downloads"
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					espeak_say_natural "nothing downloaded"
					draw_banner "NONE"
					sleep 0.25
					draw_pitch
					draw_position
				fi
				;;
			'')
				#if [ "$VIDEO" == true ]; then
					if [ "$ALWAYS_ON_TOP" == true ]; then
						espeak_say_natural "always on top"
						draw_banner "OFF"
						ALWAYS_ON_TOP=false
						#echo "set_property ontop 0" >"$ALETHEIA/pipe$$" &
						echo "vo_ontop 0" >"$ALETHEIA/pipe$$" &
					else
						espeak_say_natural "off"
						draw_banner "ON TOP"
						ALWAYS_ON_TOP=true
						#echo "set_property ontop 1" >"$ALETHEIA/pipe$$" &
						echo "vo_ontop 1" >"$ALETHEIA/pipe$$" &
					fi
					sleep 0.25
					draw_pitch
					draw_position
				#fi
				;;
			'')
				add_downloaded true
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					#espeak_say_natural "Playing downloads"
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					espeak_say_natural "nothing downloaded"
					draw_banner "NONE"
					sleep 0.25
					draw_pitch
					draw_position
				fi
				;;
			'd')
				toggle_voice
				draw_pitch
				;;
			':')
				if [ "$DIMENSIONS_RESET" == true ]; then
					render_help_screen
					render_voice_settings_screen
					DIMENSIONS_RESET=false
				fi
				voice_settings_screen
				;;
			'/')
				set_custom_edo
				;;
			'4')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				reset_all_tuning
				;;
			'w')
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				reset_to_locked
				;;
			#'T')
			#	PAUSE=false
			#	if [ "$MUTE" == true ]; then
			#		echo "mute" >$ALETHEIA/pipe$$ &
			#		MUTE=false
			#		draw_pitch
			#	fi
			#	interval_to_zero
			#	;;
			'T')
				#set_only_display_song
				#redraw_buffer
				if [ "$ONLY_VOICE_TITLES" == true ]; then
					ONLY_VOICE_TITLES=false
					if [ "$VOICE_ENABLED" == true ]; then
						prev_true=true
					else
						prev_true=false
					fi
					VOICE_ENABLED=true
					if [ "$prev_true" == true ]; then
						espeak_say_natural "voice on"
						draw_banner "VOICE ALL"
					else
						espeak_say_natural "off"
						draw_banner "VOICE OFF"
						VOICE_ENABLED=false
					fi
					sleep 0.75
					draw_pitch
					draw_position
				else
					ONLY_VOICE_TITLES=true
					if [ "$VOICE_ENABLED" == true ]; then
						prev_true=true
					else
						prev_true=false
					fi
					VOICE_ENABLED=true
					if [ "$prev_true" == true ]; then
						VOICE_ENABLED=true
						espeak_say_natural "voice on"
						draw_banner "VOICE ALL"
					else
						espeak_say_natural "$TITLE"
						VOICE_ENABLED=false
						draw_banner "ONLY TITLES"
					fi
					sleep 0.75
					draw_pitch
					draw_position
				fi
				;;
			'z')
				tput civis
				draw_wait
				reset_dimensions
				redraw_screen false
				if [ "$MUTE" == true ]; then
					draw_banner "MUTE"
				elif [ "$PAUSE" == true ]; then
					draw_banner "PAUSE"
				fi
				espeak_say_natural "screen redrawn"
				;;
			'O')
				espeak_say_natural "edit playlist"
				#echo -e "$QBUFFER" >"$ALETHEIA/queue"
				echo -e "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/queue"
				cp "$ALETHEIA/queue" "$ALETHEIA/queue.old"
				vim +"$POSITION" "$ALETHEIA/queue"
				diff $ALETHEIA/queue $ALETHEIA/queue.old >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					unset queue_array

					IFS=$'\n'
					index=0
					for i in `cat "$ALETHEIA/queue"`; do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					#QBUFFER="`cat \"$ALETHEIA/queue\"`"
					#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
					#TOTAL_QUEUE="$(($index-1))"
					TOTAL_QUEUE=$index
					espeak_say_natural "saved"
					#res="`echo -ne \"$QBUFFER\" | sed -n ${POSITION}p | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev`" 
					# FIXME
					new="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
					if [ "$new" == "" ]; then
						#res="`echo -ne \"${queue_array[$POSITION]}\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev`"
						res="${queue_array[$POSITION]}"
						if [ "$res" != "$FILENAME" ]; then
							tput civis
							#clear
							#JUMP="1"
							#if [ "$POSITION" -le "$TOTAL_QUEUE" ]; then
							#	JUMP=$POSITION
							#else
							#FIXME
								#JUMP=1
								JUMP="$POSITION"
							#fi
							kill $MPLAYER_PID >/dev/null 2>/dev/null
							return $RETURN_JUMP
						fi
					else
						POSITION="$new"
					fi
					reset_buffer
				else
					espeak_say_natural "closed"
				fi
				tput civis
				redraw_buffer
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				;;
			',')
				espeak_say_natural "$TITLE" true
				;;
			'D')
				yesno=""
				read -rsn1 -t 0.1 _input <$ALETHEIA/input_fifo
				if [ "$_input" != "" ]; then
					#input=$_input
					#if [ "$_input" == "y" ]; then
					#	echo -ne "$NOCOLOR"
					#	kill $MPLAYER_PID >/dev/null 2>/dev/null
					#	clear
					#	stty echo
					#	return $RETURN_QUIT
					#fi
					yesno="$_input"
				else
					draw_banner "DELETE" true
					espeak_say_natural "delete?"
				fi

				if [ "$yesno" == "" ]; then
					read -rsn1 yesno
				fi
				if [ "$yesno" == "y" ] || [ "$yesno" == "Y" ]; then
					if [ ! -d "$ALETHEIA/deleted" ] || [ ! -d "$ALETHEIA/deleted/voices" ]; then
						mkdir "$ALETHEIA/deleted"
						mkdir "$ALETHEIA/deleted/voices"
					fi
					mv "$FILENAME" "$ALETHEIA/deleted"
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "$ALETHEIA/deleted"
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "$ALETHEIA/deleted"
					fi
					if [ -e "$FILENAME.time" ]; then
						mv "$FILENAME.time" "$ALETHEIA/deleted"
					fi
					path="`echo -ne \"$FILENAME\" | rev | cut -d'/' -f2- | rev`"
					if [ "`ls -1 \"$path\"`" == "" ]; then
						rmdir "$path"
					fi
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						#rm -f "$ALETHEIA/voices/$TITLE.mp3"
						mv "$ALETHEIA/voices/$TITLE.mp3" "$ALETHEIA/deleted/voices/"
					fi
					draw_pitch
				else
					draw_pitch
					draw_position
					espeak_say_natural "canceled"
					continue
				fi
				tput el
				draw_position
				if [ "$POSITION" = "" ]; then
					return 0
				fi

				#QBUFFER="`echo -e \"$QBUFFER\" | sed \"${POSITION}d\"`"
				for i in `seq $POSITION $(($TOTAL_QUEUE-1))`; do
					queue_array[$(($i-1))]=${queue_array[$i]}
				done

				kill $MPLAYER_PID >/dev/null 2>/dev/null
				#espeak_say_natural "Deleted"
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					JUMP="1"
					POSITION="1"
					draw_position
					TOTAL_QUEUE="$(($TOTAL_QUEUE-1))"
					return $RETURN_JUMP
				else
					TOTAL_QUEUE="$(($TOTAL_QUEUE-1))"
					return $RETURN_RESTART
				fi
				;;
			"'")
				#artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
				#JUMP="`echo -ne \"$QBUFFER\" | grep -ne \"/$artist -\" | head -1 | cut -d':' -f1`"
				#kill $MPLAYER_PID >/dev/null 2>/dev/null
				#return $RETURN_JUMP
				jump_to_first_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'"')
				#artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
				#JUMP="`echo -ne \"$QBUFFER\" | grep -ne \"/$artist -\" | tail -1 | cut -d':' -f1`"
				#kill $MPLAYER_PID >/dev/null 2>/dev/null
				#return $RETURN_JUMP
				jump_to_last_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'N')
				if [ "$SHUFFLED" == false ]; then
					#artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
					#last="`echo -ne \"$QBUFFER\" | tail -1 | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e \"s/ - //g\" | cut -d'' -f1`"
					last="$(echo -ne "${queue_array[$(($TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/ - //" | cut -d'' -f1)"
					if [ "$artist" != "$last" ]; then
						IFS=$'\n'
						tmpq="`printf '%s\n' ${queue_array[@]} | grep -n "\/$artist \- " | tail -1 | cut -d':' -f1`"
						unset IFS
						JUMP="$(($tmpq+1))"
						unset tmpq
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				fi
				;;
			'B')
				if [ "$SHUFFLED" == false ]; then
					IFS=$'\n'
					tmpq="`printf '%s\n' ${queue_array[@]} | grep -n "\/$artist \- " | head -1 | cut -d':' -f1`"
					if [ "$tmpq" -gt "1" ]; then
					#if [ "$JUMP" != "1" ]; then
						#JUMP="`echo -ne \"${queue_array[*]}\" | grep -n \"\" | grep -e \"^$(($JUMP-1)):\" | cut -d':' -f2- | rev | cut -d'.' -f2-| cut -d'/' -f1 | rev | sed -e \"s/ - //g\" | cut -d'' -f1`"
						#JUMP="`echo -ne \"${queue_array[*]}\" | grep -ne \"/$JUMP -\" | head -1 | cut -d':' -f1`"
					#fi
						last_artist="`echo -ne \"${queue_array[$(($tmpq-2))]}\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev | sed -e \"s/ - //\" | cut -d'' -f1`"
						JUMP="`printf '%s\n' ${queue_array[@]} | grep -n "\/$last_artist \- " | head -1 | cut -d':' -f1`"
					fi
					unset IFS
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			's')
				start_search
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'S')
				new_playlist false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			#'|')
				#draw_banner "YOUTUBE"
				#tput rc
				#tmp="`read_line`"
				#if [ "$tmp" == "." ]; then
					#tmux new-session -s "youtube" youtube_similar "$TITLE"
			#		tmux new-session -s "vanish" $HOME/bin/vanish
				#else
				#	tmux new-session -s "youtube" youtube_similar ""
				#fi

				#list="`yt_similar \"$TITLE\"`"
				#clear
				#echo -e "$list"
				#read -n1 tmp
				#if [ "$tmp" == "y" ]; then
				#	echo -e "-\n$list\n" | youtube_search
				#else
				#	redraw_screen
				#fi
			#	redraw_screen
			#	;;
			'')
				new_playlist false true
				#if [ "$?" == "$RETURN_JUMP" ]; then
				#	return $RETURN_JUMP
				#fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'Q')
				queue_controls false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'#')
				save_settings
				;;
			'r')
				draw_banner "RENAME" true
				espeak_say_natural "rename?"
				read -rsn1 yesno
				if [ "$yesno" == "y" ]; then
					ext="`echo "$FILENAME" | rev | cut -d'.' -f1 | rev`"
					path="`echo "$FILENAME" | rev | cut -d'/' -f2- | rev`"
					if [ "`echo \"$path\" | grep '/'`" = "" ]; then
						path="."
					fi
					espeak_say_natural "rename as what?"
					tput rc
					echo -ne "$WHITE_BLACK"
					printf '%*s' $(($PANE_WIDTH - 12))
					tput rc
					echo -ne "$WHITE_BLACK"
					newname="`read_line`"
					if [ "$newname" == "" ]; then
						redraw_buffer
						draw_pitch
						draw_position
						espeak_say_natural "canceled"
						continue
					fi
					mv "$FILENAME" "${path}/$newname.$ext" >/dev/null 2>/dev/null
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						rm -f "$ALETHEIA/voices/$TITLE.mp3"
					fi
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "${path}/$newname.$ext.locked" >/dev/null 2>/dev/null
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "${path}/$newname.$ext.repeats" >/dev/null 2>/dev/null
					fi
					if [ -e "$FILENAME.time" ]; then
						mv "$FILENAME.time" "${path}/$newname.$ext.time" >/dev/null 2>/dev/null
					fi
					#espeak_say_natural "$newname"
					espeak_say_natural "renamed" true
					if [ "$POSITION" = "" ]; then
						POSITION=1
					fi

					#queue_length="$TOTAL_QUEUE"
					#QUEUE_TMP=""
					#if [ "$POSITION" != "1" ]; then
					#	QUEUE_TMP="`echo -e \"$QBUFFER\" | head -$(($POSITION-1))`\n"
					#	QUEUE_TMP="$QUEUE_TMP${path}/$newname.$ext\n"
					#else
					#	QUEUE_TMP="$QUEUE_TMP${path}/$newname.$ext\n"
					#fi
					#QUEUE_TMP="$QUEUE_TMP`echo -e \"$QBUFFER\" | tail -$(($queue_length - $POSITION))`\n"
					#QBUFFER="`echo -e \"$QUEUE_TMP\"`"
					export TITLE="$newname"
					export FILENAME="${path}/$newname.$ext" >/dev/null 2>/dev/null
					queue_array[$(($POSITION-1))]="$FILENAME"

					reset_buffer
					draw_volume
					draw_equalizer
					redraw_buffer
					draw_pitch
					draw_position
					continue
				else
					espeak_say_natural "canceled"
				fi
				redraw_screen true
				;;
			'*')
				master_volume_change "-1% -1%"
				;;
			'(')
				master_volume_change "+1% +1%"
				;;
			'!')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >$ALETHEIA/pipe$$ &
					MUTE=false
					draw_pitch
				fi
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME="$(($VOLUME-1))"
					echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
					espeak_say_natural "$VOLUME"
					#LOCKED=false
					draw_equalizer
					draw_volume
				fi
				;;
			'1')
				#if [ "$PAUSE" == true ]; then
				#	PAUSE=false
				#	draw_pitch
				#fi
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#if [ "$VOLUME" -ge "5" ]; then
				#	VOLUME="$(($VOLUME-5))"
				#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
				#	espeak_say_natural " $VOLUME"
				#	#LOCKED=false
				#	draw_equalizer
				#	draw_volume
				#fi
				pcm_volume_change "$input"
				if [ "$?" != "200" ]; then
					return $?
				fi
				;;
			'2')
				#if [ "$PAUSE" == true ]; then
				#	PAUSE=false
				#	draw_pitch
				#fi
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#if [ "$VOLUME" -le "95" ]; then
				#	VOLUME="$(($VOLUME+5))"
				#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
				#	espeak_say_natural " $VOLUME"
				#	#LOCKED=false
				#	draw_equalizer
				#	draw_volume
				#fi
				pcm_volume_change "$input"
				;;
			'@')
				#if [ "$PAUSE" == true ]; then
				#	PAUSE=false
				#	draw_pitch
				#fi
				#if [ "$MUTE" == true ]; then
				#	echo "mute" >$ALETHEIA/pipe$$ &
				#	MUTE=false
				#	draw_pitch
				#fi
				#if [ "$VOLUME" -le "99" ]; then
				#	VOLUME="$(($VOLUME+1))"
				#	echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
				#	espeak_say_natural " $VOLUME"
				#	#LOCKED=false
				#	draw_equalizer
				#	draw_volume
				#fi
				pcm_volume_change "$input"
				;;
			'3')
				fade_volume
				;;
			'V')
				set_loop_artist
				;;
			'e')
				track_toggle
				if [ "$?" == 200 ]; then
					JUMP=1
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					killall play >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			'')
				toggle_colors
				;;
			'')
				invert_colors
				;;
			#'')
			#	if [ "$USE_ID_TAGS" == "1" ]; then
			#		USE_ID_TAGS=0
			#		draw_banner "TAGS OFF"
			#		sleep 0.25
			#		draw_wait
			#		reset_buffer
			#		draw_volume
			#		draw_equalizer
			#		redraw_buffer
			#		draw_pitch
			#		draw_position
			#		espeak_say_natural "ID tags off"
			#	else
			#		USE_ID_TAGS=1
			#		draw_banner "TAGS ON"
			#		sleep 0.25
			#		draw_wait
			#		reset_buffer
			#		draw_volume
			#		draw_equalizer
			#		redraw_buffer
			#		draw_pitch
			#		draw_position
			#		espeak_say_natural "ID tags on"
			#	fi
			#	;;
			'')
				enable_panels true
				;;
			#'')
			#	artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
			#	if [ ! -e "$HOME/old_music/$artist" ]; then
			#		mv "$MUSICDIR/$artist/" $HOME/old_music/
			#	else
			#		mv "$MUSICDIR/$artist/"* "$HOME/old_music/$artist/"
			#		rmdir "$MUSICDIR/$artist/"
			#	fi
			#	VIDEO=false
			#	QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
			#	SHUFFLED=true
			#	TOTAL_QUEUE="`echo -ne \"$QBUFFER\" | wc -l`"
			#	if [ "$TOTAL_QUEUE" == "0" ]; then
			#		draw_banner "NO MUSIC"
			#		espeak_say_natural "No Music"
			#		sleep 0.25
			#		tput cup $LINES
			#		echo -ne "$WHITE_BLACK"
			#		printf '%*s' $COLS
			#		echo -ne "$NOCOLOR"
			#		continue
			#		
			#	fi
			#	JUMP="1"
			#	echo -ne "$NOCOLOR"
			#	kill $MPLAYER_PID >/dev/null 2>/dev/null
			#	return $RETURN_JUMP
			#	;;
			'')
				if [ "$LOCKED_OFF" == true ]; then
					LOCKED_OFF=false
					espeak_say_natural "locked on"
					draw_banner "LOCK ON"
				else
					LOCKED_OFF=true
					espeak_say_natural "locked off"
					draw_banner "LOCK OFF"
				fi
				sleep 0.25
				draw_pitch
				draw_position
				;;
			#'')
			#	stty -echo
			#	orig_SCALE_SPEED="$SCALE_SPEED"
			#	draw_banner "SCALE SPEED"
			#	draw_position
			#	tput rc
			#	points="2"
			#	echo -ne "$BLUE`printf \"%0.${points}f\" $SCALE_SPEED`"
			#	t="1"
			#	read -n1 t
			#	until [ "$t" == "q" ] || [ "$t" == "" ] || [ "$t" == "" ] || [ "$t" == "u" ]; do
			#		if [ "$t" == "j" ]; then
			#			if [ "`echo \"$SCALE_SPEED > 0.01\" | bc`" == "1" ]; then
			#				SCALE_SPEED="`echo \"$SCALE_SPEED-0.01\" | bc`"
			#				if [ "`echo \"$SCALE_SPEED < 0.01\" | bc`" == "1" ]; then
			#					SCALE_SPEED=0.01
			#				fi
			#			fi
			#			tput rc
			#			echo -ne "$BLUE`printf \"%0.${points}f\" $SCALE_SPEED`"
			#			#echo -ne "$BLUE$SCALE_SPEED"
			#			#draw_banner "$SCALE_SPEED"
			#			draw_position
			#		elif [ "$t" == "k" ]; then
			#			SCALE_SPEED="`echo \"$SCALE_SPEED+0.01\" | bc`"
			#			tput rc
			#			echo -ne "$BLUE`printf \"%0.${points}f\" $SCALE_SPEED`"
			#			#echo -ne "$BLUE$SCALE_SPEED"
			#			#draw_banner "$SCALE_SPEED"
			#			draw_position
			#		elif [ "$t" == "J" ]; then
			#			if [ "`echo \"$SCALE_SPEED > 0.001\" | bc`" == "1" ]; then
			#				SCALE_SPEED="`echo \"$SCALE_SPEED-0.001\" | bc`"
			#				if [ "`echo \"$SCALE_SPEED < 0.001\" | bc`" == "1" ]; then
			#					SCALE_SPEED=0.001
			#				fi
			#			fi
			#			tput rc
			#			points="3"
			#			echo -ne "$BLUE`printf \"%0.${points}f\" $SCALE_SPEED`"
			#			draw_position
			#		elif [ "$t" == "K" ]; then
			#			SCALE_SPEED="`echo \"$SCALE_SPEED+0.001\" | bc`"
			#			tput rc
			#			points="3"
			#			echo -ne "$BLUE`printf \"%0.${points}f\" $SCALE_SPEED`"
			#			draw_position
			#		fi
			#		read -n1 t
			#	done
			#	if [ "$t" == "u" ]; then
			#		scale
			#	fi
			#	if [ "$t" == "q" ] || [ "$t" == "" ]; then
			#		SCALE_SPEED="$orig_SCALE_SPEED"
			#	fi
			#	draw_pitch
			#	draw_position
			#	;;
			#'$')
			#	#HARD_REPEAT_ONLY=false
			#	#if [ "$HARD_REPEAT_ONLY" == false ]; then
			#		#loops_flagged=true
			#		#REPEAT_ONLY=true
			#		#HARD_REPEAT_ONLY=true
			#		if [ "$ONLY_LOCKED" == true ]; then
			#			espeak_say_natural "only locked loops"
			#		else
			#			espeak_say_natural "loops"  true
			#		fi
			#		artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
			#		if [ "$LOOP_ARTIST" == true ]; then
			#			if [ "`find \"$MUSICDIR\" | grep -e \"^$artist - \" | grep -e \"\.repeat\.*\"`" == "" ]; then
			#				LOOP_ARTIST=false
			#			fi
			#		fi
			#		if [ "$ONLY_LOCKED" == true ]; then
			#			unset queue_array
			#			IFS=$'\n'
			#			index=0
			#			for i in `find "$MUSICDIR" -iname "*\.repeat\.*" | shuf`; do
			#				var2="`echo -ne \"$i\" | rev | cut -d'.' -f3- | rev`"
			#				ext="`echo -ne \"$i\" | rev | cut -d'.' -f1 | rev`"
			#				if [ -e "$var2.locked" ]; then
			#					queue_array[$index]="$var2.$ext"
			#					index=$(($index+1))
			#				fi
			#			done
			#			unset IFS
			#			new_QBUF=""
			#		else
			#			unset queue_array
			#			IFS=$'\n'
			#			index=0
			#			for i in `find "$MUSICDIR" -iname "*\.repeat\.*" -and -not -iname "*.time" | shuf`; do
			#				#queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
			#				queue_array[$index]="$i"
			#				index=$(($index+1))
			#			done
			#			unset IFS
			#		fi
			#		SHUFFLED=true
			#		TOTAL_QUEUE="$index"
			#		tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
			#		if [ "$tmp" != "" ]; then
			#			POSITION="$tmp"
			#		else
			#			POSITION=1
			#		fi
			#		JUMP="$POSITION"
			#		kill $MPLAYER_PID
			#		return $RETURN_JUMP
			#	#fi
			#	;;	
			'')
				if [ "$LOOP_ON" == false ]; then
					ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
					filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
					if [ -e "$filename_without_ext.repeat.$ext" ]; then
						echo "volume 0 1" >"$ALETHEIA/pipe$$" &
						draw_banner "LOOP ON"
						espeak_say_natural "loading loop"
						sleep 0.05
						if [ -e "$filename_without_ext.repeat.$ext.locked" ]; then
							CONTENTS="`cat \"$filename_without_ext.repeat.$ext\".locked`"
							IFS='/'
							read _int _edo _volume_offset _equal_offset SCALETEMPO_FLAG <<< "$CONTENTS"
							unset IFS
							INTERVAL=$_int
							EDO=$_edo
							if [ "$SCALETEMPO_FLAG" != "0" ]; then
								if [ "$SCALETEMPO_FLAG" == "1" ]; then
									SCALETEMPO=true
									ONLY_PITCH=false
								elif [ "$SCALETEMPO_FLAG" == "2" ]; then
									SCALETEMPO=true
									ONLY_PITCH=true
								fi
							else
								SCALETEMPO=false
								ONLY_PITCH=false
							fi
						fi
						sleep 0.05
						echo -e "loadfile '$filename_without_ext.repeat.$ext'" >"$ALETHEIA/pipe$$" &
						sleep 0.05
						echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						sleep 0.05
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						sleep 0.05
						echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
						LOOP=true
						draw_pitch
						draw_position
					fi
				else
					ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
					filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f3- | rev`"
					if [ -e "$filename_without_ext.$ext" ]; then
						echo "volume 0 1" >"$ALETHEIA/pipe$$" &
						draw_banner "LOOP OFF" 
						espeak_say_natural "loop disabled"
						if [ -e "$filename_without_ext.$ext.locked" ]; then
							CONTENTS="`cat \"$filename_without_ext.$ext\".locked`"
							IFS='/'
							read _int _edo _volume_offset _equal_offset SCALETEMPO_FLAG <<< "$CONTENTS"
							unset IFS
							INTERVAL=$_int
							EDO=$_edo
							if [ "$SCALETEMPO_FLAG" != "0" ]; then
								if [ "$SCALETEMPO_FLAG" == "1" ]; then
									SCALETEMPO=true
									ONLY_PITCH=false
								elif [ "$SCALETEMPO_FLAG" == "2" ]; then
									SCALETEMPO=true
									ONLY_PITCH=true
								fi
							else
								SCALETEMPO=false
								ONLY_PITCH=false
							fi
						fi
						sleep 0.05
						#FIXME needs to read .repeat. .locked file for draw_pitch
						echo -e "loadfile \"$filename_without_ext.repeat.$ext\"" >"$ALETHEIA/pipe$$" &
						sleep 0.05
						echo -e "speed_set `calc \"2^($INTERVAL/$EDO)\"`" >$ALETHEIA/pipe$$ &
						sleep 0.05
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						sleep 0.05
						echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
						LOOP=true
						draw_pitch
						draw_position
					fi
				fi
				;;
			'')
				#load_only_loops
				if [ "$REPEAT_ONLY" == false ]; then
					REPEAT_ONLY=true
					espeak_say_natural "playing all loops"
					JUMP="$POSITION"
					kill $MPLAYER_PID
					return $RETURN_JUMP
				else
					REPEAT_ONLY=false
					espeak_say_natural "off"
				fi
				;;
			'E')
				set_loop
				;;
			'~')
				set_sleep
				;;
			'R')
				#espeak_say_natural "Shuffling"

				#QBUFFER="$FILENAME\n`echo -ne \"$QBUFFER\" | sed \"${POSITION}d\" | shuf`"
				#POSITION=1
				#TRACK_RANDOM=false

				#POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
				#draw_pitch
				#draw_position
				#reset_buffer
				#redraw_buffer
				shuffle_queue
				SHUFFLED=true
				draw_pitch
				draw_position
				;;
			'A')
				#espeak_say_natural "Sorting"

				#QBUFFER="`echo -e \"$QBUFFER\" | sort`"
				#tmp="`echo -e \"$QBUFFER\" | grep -n \"$FILENAME\" | cut -d':' -f1`"
				#POSITION="$tmp"

				#draw_position
				#reset_buffer
				#redraw_buffer
				sort_queue
				SHUFFLED=false
				draw_position
				;;
			'.')
				set_custom_int
				;;
			'u')
				scale
				;;
			'X')
				set_scale_speed
				;;
			'')
				set_random
				;;
			#'')
			#	if [ "$WEB_CLIENT" == "1" ]; then
			#		WEB_CLIENT=0
			#		killall node >/dev/null 2>/dev/null
			#		render_help_screen
			#		render_voice_settings_screen
			#		render_repeat_help_screen
			#		reset_buffer
			#		redraw_buffer
			#	else
			#		WEB_CLIENT=1
			#		node $HOME/webserver.js >/dev/null 2>/dev/null &
			#	fi
			#	;;
#			'i')
#				draw_banner "MENU"
#
#				unset OPT
#				OPT[1]="Music"
#				OPT[2]="Sound"
#				OPT[3]="Video"
#				OPT[4]="Queue"
#				OPT[5]="Help "
#				#OPT[6]="About"
#				OPT[6]="Quit "
#				TOTAL_OPTS=${#OPT[@]}
#
#				SELECTION="1"
#				z=" "
#
#				pad_=1
#				empty_pane
#
#				until [ "$z" = "," ]; do
#					#tput cup $(( ($LINES/2) - 5 )) $((($COLS/2)-4))
#					#echo -ne "$WHITE_BLACK         "
#					#tput cup $(( ($LINES/2) - 4 )) $((($COLS/2)-4))
#					#echo -ne "$NOCOLOR$WHITE_BLACK $ALETHEIA_NAME$WHITE_BLACK "
#					#tput cup $(( ($LINES/2) - 3 )) $((($COLS/2)-4))
#					#echo -ne "$WHITE_BLACK         "
#					#tput cup $(( ($LINES/2) + 5 )) $((($COLS/2)-4))
#					#echo -ne "$WHITE_BLACK         "
#					for i in `seq 1 $TOTAL_OPTS`; do
#						pad="  "
#						temp="${#OPT[$i]}"
#						while [ "$temp" -le "$pad_" ]; do
#							pad="$pad "
#							temp="$(($temp+1))"
#						done
#						if [ "$i" = "$SELECTION" ]; then
#							COLOR="$WHITE"
#							tput cup $((($LINES/2)-3 +$i)) $((($COLS/2) - 2 - (${#OPT[$SELECTION]}/2)))
#							echo -ne "$BLUE_BLACK"
#							tput rev
#							echo -e "$pad${OPT[$i]}$pad"
#							tput sgr0
#							espeak_say_natural "${OPT[$i]}"
#						else
#							tput cup $((($LINES/2)-3+$i)) $((($COLS/2) - (${#OPT[1]} / 2) - 2 ))
#							echo -ne "$WHITE_BLACK"
#							echo -e "$pad${OPT[$i]}$pad"
#						fi
#					done
#						read -rsn1 z
#						if [ "$z" == "j" ]; then
#							if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
#								SELECTION="$(($SELECTION+1))"
#							fi
#						elif [ "$z" == "k" ]; then
#							if [ "$SELECTION" -gt "1" ]; then
#								SELECTION="$(($SELECTION-1))"
#							fi
#						elif [ "$z" == "i" ]; then
#							z=","
#						elif [ "$z" == "q" ]; then
#							z=","
#						elif [ "$z" == "z" ]; then
#							REDRAWN=true
#							reset_dimensions
#							empty_pane
#							draw_volume
#							draw_equalizer
#							draw_banner "MENU"
#							draw_position
#							render_help_screen
#							reset_buffer
#						elif [ "$z" == $'\e' ]; then
#							read -rsn2 key
#							case $key in
#							'[B')
#								if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
#									SELECTION="$(($SELECTION+1))"
#								fi
#								;;
#							'[A')
#								if [ "$SELECTION" -gt "1" ]; then
#									SELECTION="$(($SELECTION-1))"
#								fi
#								;;
#
#							esac
#						elif [ "$z" == "" ]; then
#							z=","
#						elif [ "$z" == "" ]; then
#							case $SELECTION in
#							*)
#								if [ "${OPT[$SELECTION]}" == "Music" ]; then
#									VIDEO=false
#									QBUFFER="`find \"$MUSICDIR\" -iname \"*.mp3\" -o -iname \"*.flac\" | shuf`"
#									TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
#									JUMP="1"
#									echo -ne "$NOCOLOR"
#									kill $MPLAYER_PID >/dev/null 2>/dev/null
#									return $RETURN_JUMP
#								elif [ "${OPT[$SELECTION]}" == "Sound" ]; then
#									VIDEO=false
#									QBUFFER="`find \"$MUSICDIR/../Sounds\" -iname \"*.mp3\" -o -iname \"*.flac\"`"
#									JUMP="1"
#									echo -ne "$NOCOLOR"
#									kill $MPLAYER_PID >/dev/null 2>/dev/null
#									return $RETURN_JUMP
#								elif [ "${OPT[$SELECTION]}" == "Video" ]; then
#									VIDEO=true
#									QBUFFER="`find "$HOME/Videos" -iname \"*.mkv\" -o -iname \"*.mp4\"`"
#									JUMP="1"
#									echo -ne "$NOCOLOR"
#									kill $MPLAYER_PID >/dev/null 2>/dev/null
#									return $RETURN_JUMP
#								elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
#									queue_controls
#									if [ "$?" == "$RETURN_JUMP" ]; then
#										JUMP=1
#										return $RETURN_JUMP
#									fi
#									z=","
#								elif [ "${OPT[$SELECTION]}" == "Help " ]; then
#									if [ "$DIMENSIONS_RESET" == true ]; then
#										render_help_screen
#										render_voice_settings_screen
#										DIMENSIONS_RESET=false
#									fi
#									help_screen
#									empty_pane
#								elif [ "${OPT[$SELECTION]}" == "About" ]; then
#									about
#									empty_pane
#								elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
#									queue_controls
#									break
#								elif [ "${OPT[$SELECTION]}" == "Quit " ]; then
#									exit 0
#								else
#									z=","
#								fi
#
#							esac
#						fi
#					if [ "$z" = "," ]; then
#						espeak_say_natural "closed"
#						redraw_buffer
#						draw_pitch
#						#if [ "$REDRAWN" == true ]; then
#						#	reset_buffer
#						#fi
#						z=","
#					fi
#				done
#				;;

			'-')
				scale_octave "-"
				;;
			'=')
				scale_octave "+"
				;;
			'_')
				scale_octave "-" true
				;;
			'+')
				scale_octave "+" true
				;;
			*)
				if [ "$input" == "" ]; then
					read -n2 -t 0.03 key >/dev/null 2>/dev/null
					case $key in
						'[B')
							pitch_down
							;;
						'[A')
							pitch_up
							;;
						'[D')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >$ALETHEIA/pipe$$ &
								MUTE=false
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							;;
						'[C')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >$ALETHEIA/pipe$$ &
								MUTE=false
								draw_pitch
							fi
							ps -p $MPLAYER_PID >/dev/null
							if [ "$?" == "1" ]; then
								#echo -e "exit 0" >$ALETHEIA/pipe$$ &
								#sleep 1
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
										JUMP="1"
										return $RETURN_JUMP
									else
										return 0
									fi
								fi
								#kill $MPLAYER_PID >/dev/null 2>/dev/null
								#return 0
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							;;
						*)
							continue
							;;
					esac
				else
					master_volume_secondary_func "$input"
				fi
				#continue
				;;
		esac
	done
}

trap cleanup EXIT
trap cleanup_sigint SIGINT

if [ ! -d "$ALETHEIA/" ]; then
	mkdir "$ALETHEIA"
fi

if [ ! -d "$ALETHEIA/voices/" ]; then
	mkdir "$ALETHEIA/voices/"
fi

if [ ! -d "$ALETHEIA/playlists/" ]; then
	mkdir "$ALETHEIA/playlists"
fi

if [ ! -p "$ALETHEIA/pipe$$" ]; then
	mkfifo "$ALETHEIA/pipe$$"
fi

if [ ! -p "$ALETHEIA/input_fifo" ]; then
	mkfifo "$ALETHEIA/input_fifo"
fi
exec 3<> "$ALETHEIA/input_fifo"

read_config() {
	result="`echo \"$CONFIG\" | grep -i "$1" | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
	if [ "$result" != "" ]; then
		#DEFAULT_VOLUME="$result"
		echo -ne "$result"
	fi
}

#if [ ! -e $ALETHEIA ]; then
#	mkdir $ALETHEIA
if [ -e "$ALETHEIA/config" ]; then
	CONFIG="`cat \"$ALETHEIA/config\"`"

	if [ "$CONFIG" != "" ]; then
		value="`read_config \"DEFAULT_VOLUME\"`"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i DEFAULT_VOLUME | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	DEFAULT_VOLUME="$result"
		#fi

		value="`read_config \"DEFAULT_INTERVAL\"`"
		if [ "$value" != "" ]; then
			DEFAULT_INTERVAL="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i DEFAULT_INTERVAL | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	DEFAULT_INTERVAL="$result"
		#fi

		#DEFAULT_EDO="`read_config \"DEFAULT_EDO\"`"
		value="`read_config \"DEFAULT_EDO\"`"
		if [ "$value" != "" ]; then
			DEFAULT_EDO="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i DEFAULT_EDO | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	DEFAULT_EDO="$result"
		#fi

		#DEFAULT_EQUALIZER="`read_config \"DEFAULT_EQUALIZER\"`"
		value="`read_config \"DEFAULT_EQUALIZER\"`"
		if [ "$value" != "" ]; then
			DEFAULT_EQUALIZER="$value"
		fi

		value="`read_config \"COLOR_OVERRIDE\"`"
		if [ "$value" != "" ]; then
			COLOR_OVERRIDE="$value"
		else
			COLOR_OVERRIDE=true
		fi
		#result="`echo \"$CONFIG\" | grep -i DEFAULT_EQUALIZER | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	DEFAULT_EQUALIZER="$result"
		#fi

		value="`read_config \"DEFAULT_VOLUME\"`"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i DEFAULT_VOLUME | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	DEFAULT_VOLUME="$result"
		#fi

		#DEFAULT_VOLUME="`read_config \"DEFAULT_VOLUME\"`"

		#VOICE_ENABLED="`read_config \"VOICE_ENABLED\"`"
		value="`read_config \"VOICE_ENABLED\"`"
		if [ "$value" != "" ]; then
			VOICE_ENABLED="$value"
		fi
#result="`echo \"$CONFIG\" | grep -i VOICE_ENABLED | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	VOICE_ENABLED=false
		#	if [ "$result" == "true" ]; then
		#		VOICE_ENABLED=true
		#	#elif [ "$result" == "false" ]; then
		#	#	VOICE_ENABLED=false
		#	fi
		#fi

		#ONLY_VOICE_TITLES="`read_config \"ONLY_VOICE_TITLES\"`"
		value="`read_config \"ONLY_VOICE_TITLES\"`"
		if [ "$value" != "" ]; then
			ONLY_VOICE_TITLES="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i ONLY_VOICE_TITLES | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	ONLY_VOICE_TITLES="$result"
		#fi

		#VOICE_PITCH="`read_config \"VOICE_PITCH\"`"
		value="`read_config \"VOICE_PITCH\"`"
		if [ "$value" != "" ]; then
			VOICE_PITCH="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i VOICE_PITCH | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	VOICE_PITCH="$result"
		#fi

		#VOICE_VOLUME="`read_config \"VOICE_VOLUME\"`"
		value="`read_config \"VOICE_VOLUME\"`"
		if [ "$value" != "" ]; then
			VOICE_VOLUME="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i VOICE_VOLUME | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	VOICE_VOLUME="$result"
		#fi

		#VOICE_GENDER="`read_config \"VOICE_GENDER\"`"
		value="`read_config \"VOICE_GENDER\"`"
		if [ "$value" != "" ]; then
			VOICE_GENDER="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i VOICE_GENDER | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	VOICE_GENDER="$result"
		#fi

		#VOICE_SPEED="`read_config \"VOICE_SPEED\"`"
		value="`read_config \"VOICE_SPEED\"`"
		if [ "$value" != "" ]; then
			VOICE_SPEED="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i VOICE_SPEED | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	VOICE_SPEED="$result"
		#fi

		#result="`read_config \"PANELS_ENABLED\"`"
		value="`read_config \"PANELS_ENABLED\"`"
		if [ "$value" != "" ]; then
			PANELS_ENABLED="$value"
		fi

		#result="`echo \"$CONFIG\" | grep -i PANELS_ENABLED | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	PANELS_ENABLED="$result"
		#fi
		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;32;1;40m'
			BLUE_BLACK='\033[1;34;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32m'
			BLUE_BLACK='\033[1;34m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			WHITE_BLACK='\033[1;37m'
		fi

		BLACK_BACKGROUND="`read_config \"BLACK_BACKGROUND\"`"

		#result="`echo \"$CONFIG\" | grep -i BLACK_BACKGROUND | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	BLACK_BACKGROUND="$result"
		#fi

		value="`read_config \"COLORS_ENABLED\"`"
		if [ "$value" != "" ]; then
			COLORS_ENABLED="$value"
		fi
		#COLORS_ENABLED="`read_config \"COLORS_ENABLED\"`"
		#if [ "$COLORS_ENABLED" != "1" ] || [ "$COLORS_ENABLED" != "0" ]; then
		#	COLORS_ENABLED=0
		#fi

		#result="`echo \"$CONFIG\" | grep -i COLORS_ENABLED | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
		#if [ "$result" != "" ]; then
		#	COLORS_ENABLED="$result"
		#fi
		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			RED='\033[1;37m'
			LIGHTRED='\033[0;37m'
			GREEN='\033[1;37m'
			BLUE='\033[1;37m'
			YELLOW='\033[1;37m'
			LIGHTBLUE='\033[1;37m'
			PURPLE='\033[1;37m'
			CYAN='\033[1;37m'
		else
			RED='\033[1;31m'
			LIGHTRED='\033[0;31m'
			GREEN='\033[1;32m'
			BLUE='\033[1;34m'
			YELLOW='\033[1;33m'
			LIGHTBLUE='\033[1;34m'
			PURPLE='\033[1;35m'
			CYAN='\033[1;36m'
			LIGHTCYAN='\033[0;36m'
			LIGHTRED='\033[0;31m'
			if [ "$PANELS_ENABLED" == true ]; then
				GREEN_BLACK='\033[1;32;1;40m'
				BLUE_BLACK='\033[1;34;1;40m'
				RED_BLACK='\033[1;31;1;40m'
				CYAN_BLACK='\033[1;36;1;40m'
				WHITE_BLACK='\033[1;37;1;40m'
			else
				GREEN_BLACK='\033[1;32m'
				BLUE_BLACK='\033[1;34m'
				RED_BLACK='\033[1;31m'
				CYAN_BLACK='\033[1;36m'
				WHITE_BLACK='\033[1;37m'
			fi
		fi
		if [ "$BLACK_BACKGROUND" == true ]; then
			WHITE='\033[1;37m'
			LIGHTWHITE='\033[0;37m'
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK='\033[1;37;1;40m'
			else
				WHITE_BLACK='\033[1;37m'
			fi
		else
			WHITE='\033[1;30m'
			LIGHTWHITE='\033[0;30m'
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK='\033[1;30;1;40m'
			else
				WHITE_BLACK='\033[1;30m'
			fi
		fi

		value="`read_config \"COLOR_HIGHLIGHT\"`"
		if [ "$value" != "" ]; then
			COLOR_HIGHLIGHT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			BLUE="\033[1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				BLUE_BLACK="\033[1;38;2;${red};${green};${blue};1;40m"
			else
				BLUE_BLACK="\033[1;38;2;${red};${green};${blue}m"
			fi
		fi

		value="`read_config \"COLOR_ACCENT\"`"
		if [ "$value" != "" ]; then
			COLOR_ACCENT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			PURPLE="\033[1;38;2;${red};${green};${blue}m"
		fi

		value="`read_config \"COLOR_UNSELECTED\"`"
		if [ "$value" != "" ]; then
			COLOR_UNSELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			WHITE="\033[1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="\033[1;38;2;${red};${green};${blue};1;40m"
			else
				WHITE_BLACK="\033[1;38;2;${red};${green};${blue}m"
			fi
		fi

		value="`read_config \"COLOR_SELECTED\"`"
		if [ "$value" != "" ]; then
			COLOR_SELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			GREEN="\033[1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				GREEN_BLACK="\033[1;38;2;${red};${green};${blue};1;40m"
			else
				GREEN_BLACK="\033[1;38;2;${red};${green};${blue}m"
			fi
		fi


	fi
fi

if [ "$COLOR_OVERRIDE" == false ]; then
	BLUE=$(generate_random_color)
	color="${BLUE#"#"}"
	red=$((16#${color:0:2}))
	green=$((16#${color:2:2}))
	blue=$((16#${color:4:2}))
	BLUE="\033[1;38;2;${red};${green};${blue}m"
	BLUE_BLACK="\033[1;38;2;${red};${green};${blue}m"

	WHITE=$(generate_random_color)
	color="${WHITE#"#"}"
	red=$((16#${color:0:2}))
	green=$((16#${color:2:2}))
	blue=$((16#${color:4:2}))
	WHITE="\033[1;38;2;${red};${green};${blue}m"
	WHITE_BLACK="\033[1;38;2;${red};${green};${blue}m"
fi

tput cup $(($LINES-2)) $(( ($COLS/2) - 5 ))
echo -ne "$BLUE["
#tput cup $(($LINES/2)) $(( ($COLS/2) + 5 ))
tput cup $(($LINES-2)) $(( ($COLS/2) + 5 ))
echo -ne "$BLUE]$WHITE"
#tput cup $(($LINES/2)) $(( ($COLS/2) - 4 ))
tput cup $(($LINES-2)) $(( ($COLS/2) - 4 ))

#if [ "$PANELS_ENABLED" == "1" ]; then
#	tput cup 0
#	echo -ne "$WHITE_BLACK"
#	printf '%*s' $COLS
#	echo -ne "$NOCOLOR"
#fi

#draw_wait true
if [ "$1" == "--server" ]; then
	WEB_CLIENT=1
fi

#if [ "$WEB_CLIENT" == "0" ]; then
	#draw_animation
	#espeak_say_natural "..." true
	echo -ne "$WHITE="
	tput sc
	if [ "$ONLY_VOICE_TITLES" == true ]; then
		espeak_say_natural "..." true
	else
		espeak_say_natural "..." true
	fi
#fi

#if [ "$PANELS_ENABLED" == "1" ]; then
#	tput cup $LINES
#	echo -ne "$WHITE_BLACK"
#	printf '%*s' $COLS
#	echo -ne "$NOCOLOR"
#fi

#if [ "$WEB_CLIENT" == "0" ]; then
#	loading=true
#	render_help_screen
#	render_voice_settings_screen
#	echo -ne "$WHITE="
#	render_repeat_help_screen
#	echo -ne "$WHITE="
#fi

#if [ "$VOICE_ENABLED" == true ]; then
#	espeak-ng -s$VOICE_SPEED -v$VOICE_GENDER -a$VOICE_VOLUME -p$VOICE_PITCH " " >/dev/null 2>/dev/null
#fi

echo "" >$ALETHEIA/error_log

stty -echo

if [ "$2" != "" ]; then
	KEYWORDS="`echo \"$@\" | cut -d' ' -f2-`"
fi

rendered=false

if [ "$1" == "--music" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" | shuf`; do
		#for i in $(find "$MUSICDIR" \( -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" \) -not -iname "*\.repeat\.*" | shuf); do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE=$index
		if [ "$index" -lt "1" ]; then
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
			exit 0
		fi
		#find "$MUSICDIR" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" | shuf >$ALETHEIA/queue
	else
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE=$index
		#find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf >$ALETHEIA/queue
		if [ "$index" -lt "1" ]; then
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}Nothing found in $MUSICDIR"
			exit 0
		fi
	fi
	SHUFFLED=true
	#if [ -e "$ALETHEIA/queue" ]; then
	#	QBUFFER="`cat \"$ALETHEIA/queue\"`"
	#fi
elif [ "$1" == "--sound" ] || [ "$WEB_CLIENT" == "1" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		if [ -e "$HOME/Sounds/" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			#for i in `find "$HOME/Sounds" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
			for i in `find "$HOME/Sounds" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=true
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$HOME/Sounds does not exist."
			exit 0
		fi
		#find "$HOME/Sounds" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" >$ALETHEIA/queue
	else
		if [ -e "$HOME/Sounds/" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$HOME/Sounds" -iname "*.mp3" -o -iname "*.flac" | sort`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=false
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$HOME/Sounds does not exist."
			exit 0
		fi
		#find "$HOME/Sounds" -iname "*.mp3" -o -iname "*.flac" | sort >$ALETHEIA/queue
	fi
	#if [ -e "$ALETHEIA/queue" ]; then
	#	QBUFFER="`cat \"$ALETHEIA/queue\"`"
	#fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
		exit 0
	fi
	TOTAL_QUEUE=$index
	if [ "$WEB_CLIENT" == "1" ]; then
		#kill %1 >/dev/null 2>/dev/null
		node $HOME/webserver.js >/dev/null 2>/dev/null &
	fi
elif [ "$1" == "--video" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		if [ -e "$HOME/Videos/" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$HOME/Videos" -iregex ".*${KEYWORD}mkv" -o -iregex ".*${KEYWORD}mp4" -o -iregex ".*${KEYWORD}webm" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$HOME/Videos does not exist."
			exit 0
		fi
			#QBUFFER="`find "$HOME/Videos" -iname \"*.mkv\" -o -iname \"*.mp4\" | sort`"
			#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
			TOTAL_QUEUE=$(($index))
		#find "$HOME/Videos" -iregex ".*${KEYWORD}mkv" -o -iregex ".*${KEYWORD}mp4" >$ALETHEIA/queue
	else
		if [ -e "$HOME/Videos/" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$HOME/Videos" -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.webm" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$HOME/Videos does not exist."
			exit 0
		fi
		#QBUFFER="`find "$HOME/Videos" -iname \"*.mkv\" -o -iname \"*.mp4\" | sort`"
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		#find "$HOME/Videos" -iname "*.mkv" -o -iname "*.mp4" >$ALETHEIA/queue
	fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
		exit 0
	fi
	TOTAL_QUEUE=$index
	VIDEO=false
	#if [ -e "$ALETHEIA/queue" ]; then
	#	QBUFFER="`cat \"$ALETHEIA/queue\"`"
	#fi
elif [ "$1" == "--directory" ]; then
	if [ "$2" != "" ]; then
		echo -ne "" >$ALETHEIA/queue
		if [ -d "$2" ]; then
			unset queue_array
			IFS=$'\n'
			index=0
			for i in `find "$2" -iname "*.mp3" -o -iname "*.flac" -o -iname "*.mkv" -o -iname "*.mp4" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=true
			TOTAL_QUEUE=$index
			#find "$2" -iname "*.mp3" -o -iname "*.flac" -o -iname "*.mkv" -o -iname "*.mp4" | shuf >>$ALETHEIA/queue
		else
			clear
			tput cup $LINES
			echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
			exit 0
		fi
	else
		clear
		tput cup $LINES
		echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
		exit 0
	fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found in $2"
		exit 0
	fi
	#if [ -e "$ALETHEIA/queue" ]; then
	#	QBUFFER="`cat \"$ALETHEIA/queue\"`"
	#fi
elif [ "$1" == "--file" ]; then
	#if [ -e "$2" ]; then
	#	QBUFFER="$2"
	#fi
	#ext="`echo -ne \"$2\" | rev | cut -d'.' -f1 | rev`"
	if [ "$2" == "" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}No file specified."
		exit 0
	fi
	if [ -e "$2" ]; then
		queue_array[0]="`realpath \"$2\"`"
		TOTAL_QUEUE=1
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}'$2' does not exist."
		exit 0
	fi
elif [ "$1" == "--playlist" ]; then
	if [ -e "$2" ]; then
		unset queue_array

		IFS=$'\n'
		index=0
		for i in `cat "$2"`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE="$index"
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Playlist file '$2' does not exist."
		exit 0
	fi
elif [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	#kill %1 >/dev/null 2>/dev/null
	node $HOME/webserver.js >/dev/null 2>/dev/null &

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" != "" ]; then
	for i in "$@"; do
		KEYWORD="$KEYWORD$i.*"
	done
	find "$MUSICDIR" "$HOME/Sounds" "$HOME/Videos/" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" >$ALETHEIA/queue
	if [ -e "$ALETHEIA/queue" ]; then
		QBUFFER="`cat \"$ALETHEIA/queue\"`"
	fi
else
	#kill %1
	if [ "$WEB_CLIENT" == "1" ]; then
		node $HOME/webserver.js >/dev/null 2>/dev/null &
	fi

	loading=true
	render_help_screen
	render_voice_settings_screen
	echo -ne "$WHITE="
	render_repeat_help_screen
	echo -ne "$WHITE="
	rendered=true

	if [ -e "$ALETHEIA/config" ]; then
		EQUALIZER="`cat $ALETHEIA/config | grep DEFAULT_EQUALIZER | cut -d'=' -f2`"
	fi
	draw_equalizer


	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
fi

if [ "$rendered" == false ]; then
	loading=true
	render_help_screen
	render_voice_settings_screen
	echo -ne "$WHITE="
	render_repeat_help_screen
	echo -ne "$WHITE="
fi

if [ "$start_at_pos" == "" ]; then
	start_at_pos=1
fi

#trap winch_window WINCH

POSITION=$start_at_pos
RUNTHROUGH=false

#html="`cat $HOME/index.html.spec`"

tput cup $(($LINES-2))
tput el

while [ "$POSITION" -le "$TOTAL_QUEUE" ] && [ "$POSITION" -ge "1" ]; do
	#FILENAME="`echo -ne \"$QBUFFER\" | sed -n ${POSITION}p`"
	FILENAME="${queue_array[$(($POSITION-1))]}"
	TITLE="`echo \"$FILENAME\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev`"
	line="`echo \"$FILENAME\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"
	#echo -ne "$TITLE" >"$ALETHEIA/current_song"
	#tmp_func
	if [ "$USE_ID_TAGS" == "1" ]; then
		op="`exiftool -Artist -Title \"$FILENAME\"`"
		if [ "$op" == "" ]; then
			ARTIST="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
			SONG="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
		else
			ARTIST="`echo -ne \"$op\" | head -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
			SONG="`echo -ne \"$op\" | tail -1 | cut -d':' -f2- | sed -e \"s/^ //g\"`"
			if [ "$ARTIST" == "" ] || [ "$SONG" == "" ]; then
				ARTIST="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
				SONG="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
			fi
		fi
	else
		ARTIST="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		SONG="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
	fi

	if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
		RUNTHROUGH=true
	fi

	if [ "$ONLY_LOCKED" == true ]; then
		if [ ! -e "$FILENAME.locked" ]; then
			if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					if [ "$RUNTHROUGH" == false ]; then
						JUMP="1"
						RETURN="$RETURN_JUMP"
						RUNTHROUGH=true
					else
						#JUMP="1"
						#RETURN="$RETURN_JUMP"
						tmp_func
						master
						RETURN="$?"
					fi
				else
					RETURN="0"
				fi
			fi
		else
			if [ "$REPEAT_ONLY" == true ]; then
				if [ ! -e "$FILENAME.repeats" ]; then
					if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
						RETURN="0"
					fi
				else
					tmp_func
					master
					RETURN="$?"
				fi
			else
				tmp_func
				master
				RETURN="$?"
			fi
		fi
	else
		if [ "$REPEAT_ONLY" == true ]; then
			if [ ! -e "$FILENAME.repeats" ]; then
				if [ "$LOOP_ARTIST" == true ]; then
					RETURN="$RETURN_LOOP_ARTIST"
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						if [ "$RUNTHROUGH" == false ]; then
							JUMP="1"
							RETURN="$RETURN_JUMP"
							RUNTHROUGH=true
						else
							tmp_func
							master
							RETURN="$?"
						fi
						#JUMP="1"
						#RETURN="$RETURN_JUMP"
					else
						if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
							RETURN="0"
						fi
					fi
				fi
			else
				tmp_func
				master
				RETURN="$?"
			fi
		else
			tmp_func
			master
			RETURN="$?"
		fi
	fi

	if [ "$RETURN" == "$RETURN_QUIT" ]; then
		echo -ne "$NOCOLOR"
		exit 0
	elif [ "$RETURN" == "$RETURN_BACK" ]; then
		if [ "$POSITION" == "1" ]; then
			POSITION=$TOTAL_QUEUE
		else
			POSITION=$(($POSITION - 1))
		fi
		TRACK_RANDOM=false
	elif [ "$RETURN" == "$RETURN_RESTART" ]; then
		continue
	elif [ "$RETURN" == "$RETURN_JUMP" ]; then
		POSITION="$JUMP"
		#TOTAL_QUEUE="`echo -e \"$QBUFFER\" | wc -l`"
		#POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 3))
		POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
		RIGHT_BANNER_WIDTH=$POSITION_WIDTH
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST" ]; then
		#new_POSITION="`echo -ne \"$QBUFFER\" | sed \"1,${POSITION}d\" | grep -ni \"\/$LOOP_ARTIST_NAME\" | head -1 | cut -d':' -f1`"
		new_POSITION="`printf '%s\n' \"${queue_array[@]}\" | sed \"1,${POSITION}d\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$(($new_POSITION+$POSITION))"
		else
			#POSITION="`echo -ne \"$QBUFFER\" | grep -ni \"\/$LOOP_ARTIST_NAME\" | head -1 | cut -d':' -f1`"
			POSITION="`printf '%s\n' \"${queue_array[@]}\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		fi
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST_BACK" ]; then
		#new_POSITION="`echo -ne \"$QBUFFER\" | sed \"${POSITION},${TOTAL_QUEUE}d\" | tac | grep -ni \"$LOOP_ARTIST_NAME\" | head -1 | cut -d':' -f1`"
		new_POSITION="`printf '%s\n' \"${queue_array[@]}\" | sed \"${POSITION},${TOTAL_QUEUE}d\" | tac | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$(($POSITION-$new_POSITION))"
		else
			#POSITION="`echo -ne \"$QBUFFER\" | grep -ni \"\/$LOOP_ARTIST_NAME\" | tail -1 | cut -d':' -f1`"
			POSITION="`printf '%s\n' \"${queue_array[@]}\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | tail -1 | cut -d':' -f1`"
		fi
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM" ]; then
		POSITION="$((1 + $RANDOM % $TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM_BACK" ]; then
		POSITION="$((1 + $RANDOM % $TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_ONLY_LOCKED_BACK" ]; then
		POSITION="$(($POSITION-1))"
		if [ "$POSITION" == "0" ]; then
			POSITION="$TOTAL_QUEUE"
		elif [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=0
		fi
	else
		POSITION="$(($POSITION+1))"
	fi
done

echo -ne "$NOCOLOR"
exit 0
