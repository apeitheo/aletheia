#!/bin/bash

# aletheia: a media player with pitch controls and voice feedback
#
# Copyright 2021-2024 Brad Hermanson <apeitheo@gmail.com>
#
# Aletheia is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License, version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details,
# available at https://www.gnu.org/licenses/
#
# GitHub:  https://github.com/apeitheo/aletheia
# Support: https://www.patreon.com/aletheia_project

PROGRAM_NAME="aletheia"
VERSION="0.9.6"
ALETHEIA_DATA_DIR="."
MAIN_REFRESH_TIME=${REFRESH_TIME:-0.2}
MPLAYER_PATH=${MPLAYER_PATH:-""}
if [ "$MPLAYER_PATH" != "" ] && [ "${MPLAYER_PATH: -1}" != "/" ]; then
	MPLAYER_PATH+="/"
fi
AUDIO_FORMATS="mp3,flac,ogg,wav,wma"
VIDEO_FORMATS="mkv,mp4,avi,webm,mpg,mpeg"
NO_HELP=${NO_HELP:-false}
USE_TAGS=true
PARALLEL_CACHE_ENABLED=false
PARALLEL_CACHE_JOBS="4"
THEME_FILE="Slate"
DEFAULT_THEME_FILE="$THEME_FILE"
THEME_ENABLED=true

ALETHEIA="$HOME/.aletheia"
MUSICDIR=${MUSICDIR:-"$HOME/Music/"}
SOUNDDIR=${SOUNDDIR:-"$HOME/Sounds/"}
VIDEODIR=${VIDEODIR:-"$HOME/Videos/"}

export MAIN_REFRESH_TIME
export MPLAYER_PATH

if [ "$1" == "--version" ]; then
	echo "$VERSION"
	exit 0
elif [ "$1" == "--help" ]; then
	space="$(printf '%*s' ${#PROGRAM_NAME})"
	echo -e "Usage: $PROGRAM_NAME [option] [<file/directory>|keyword]"
	echo
	echo -e "        $space--file <file>"
	echo -e "        $space--directory <directory>"
	echo -e "        $space--playlist <file>"
	echo
	echo -e "        $space--music [keyword]"
	echo -e "        $space--sound [keyword]"
	echo -e "        $space--video [keyword]"
	echo
	echo -e "        $space--vanish"
	echo -e "        $space--server"
	echo -e "        $space--version"
	echo
	echo -e "See \`man $PROGRAM_NAME\` for more help."
	exit 0
fi

tput init
tput civis
stty -echo
stty -ixon
clear

WEB_CLIENT=${WEB_CLIENT:-0}

export HELP_BUFFER=()
export SETUP_HELP_BUFFER=()
export TMP_BUFFER=()
export TWO_COLUMN=false
export OUTPUT=""

SCALE_SPEED=0.618
DEFAULT_SCALE_SPEED=$SCALE_SPEED
export DIMENSIONS_RESET=false
export SELECT_REPEAT_FILE=false
export LOOP_ON=false
export SAVED_POSITION=()
export CURRENT_POSITION=""
PANELS_ENABLED=true
BANNER_WAIT_TIME=0.6
MPLAYER_WAIT_TIME=0.05

LINE_CHAR="\033(0"
LINE_CHAR_END="\033(B"
ESC="\033["
NOCOLOR="${ESC}0m"

RETURN_NEXT="0"
RETURN_QUIT="1"
RETURN_BACK="2"
RETURN_RESTART="3"
RETURN_JUMP="4"
RETURN_LOOP_ARTIST="5"
RETURN_LOOP_ARTIST_BACK="6"
RETURN_TRACK_RANDOM="7"
RETURN_TRACK_RANDOM_BACK="8"
RETURN_ONLY_LOCKED_BACK="9"

DEFAULT_INTERVAL="0"
DEFAULT_EDO="60"
DEFAULT_VOLUME="50"
DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
EQUALIZER="$DEFAULT_EQUALIZER"
LOCKED_EDO=$DEFAULT_EDO
VOLUME=""
LIMIT_MASTER_VOLUME=100
ONLY_PITCH=false
DISPLAY_ALBUM=false

LOCKING_POS=0
EDO_LIMIT="1000000"
INTERVAL_LOWER_LIMIT=$(bc <<<"$DEFAULT_EDO * 2.6")
INTERVAL_UPPER_LIMIT=$(bc <<<"$DEFAULT_EDO * 2.1")
SAVED_INTERVAL=""
SAVED_EDO=""

KEYWORD=""
export KEYWORD
FILENAME=""
ARTIST=""
SONG=""

SLEEPING=false
SUSPEND=false

LOOP=false
LOOP_ARTIST=false
TRACK_RANDOM=false
ONLY_LOCKED=false
REPEAT_ONLY=false
SHUFFLED=false
export LOOPS_ONLY=false
export LOCKED_OFF=false

JUMP=0
POSITION=0
TOTAL_QUEUE=0
export LOOP_ARTIST_NAME=""
RIGHT_BANNER_WIDTH=0
CORNER_DIVIDER=":"

export VIDEO=false
export VIDEO_FLAGGED=false
export FULLSCREEN=true
ALWAYS_ON_TOP=true
NO_QUEUE_FLAG=false

export ARTIST=""
export SONG=""
PICK=""
NODE_PID=""
ESPEAK_PID=""
DOWNLOAD_POSITION=""
SONG_LENGTH=""
PADDING=" "

VOICE_ENABLED=false
VOICE_ENGINE="espeak-ng"
ESPEAK_DIGITAL_VOICE="${ESPEAK_DIGITAL_VOICE:-true}"
GTTS_NATURAL_VOICE="${GTTS_NATURAL_VOICE:-false}"
ESPEAK_LANGUAGE="en-us+m1"
GTTS_LANGUAGE="en"
VOICE_PITCH=0
VOICE_VOLUME=0.85
ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
ONLY_VOICE_TITLES=false

POSITION_WIDTH=0

get_system_volume() {
	IFS='/' read -r _ SYSTEM_VOLUME_LEFT _ SYSTEM_VOLUME_RIGHT _ <<<"$(pactl get-sink-volume @DEFAULT_SINK@)"
	SYSTEM_VOLUME_LEFT=${SYSTEM_VOLUME_LEFT// /}
	SYSTEM_VOLUME_RIGHT=${SYSTEM_VOLUME_RIGHT// /}
}

if [ ! -d "$ALETHEIA" ]; then
	mkdir -p "$ALETHEIA"
fi

touch -m "$ALETHEIA/start$$"

get_system_volume

read_config() {
	if [ "$2" != "" ] || [ "$4" == true ]; then
		local CONFIG="$2"
	fi
	if [ "$3" == true ]; then
		echo -ne "$CONFIG" | sed "/^#/d" | grep -i "^$1[[:space:]]*=" | cut -d'=' -f2 | sed -e "s/^[[:space:]]*//g;s/^ *//g;s/* $//g;s/\"//g;s/'//g"
	else
		echo -ne "$CONFIG" | sed "/^#/d" | grep -i "^$1[[:space:]]*=" | cut -d'=' -f2 | sed -e "s/^[[:space:]]*//g;s/^ *//g;s/* $//g;s/\"//g;s/'//g" | tr '[:upper:]' '[:lower:]'
	fi
}

check_colors() {
	if [ "$1" == true ]; then
		local CONFIG=
		if [ -e "$ALETHEIA/themes/$THEME_FILE" ]; then
			CONFIG="$(cat "$ALETHEIA/themes/$THEME_FILE")"
		elif [ -e "$ALETHEIA_DATA_DIR/themes/$THEME_FILE" ]; then
			CONFIG="$(cat "$ALETHEIA_DATA_DIR/themes/$THEME_FILE")"
		else
			CONFIG="$(cat "$ALETHEIA_DATA_DIR/themes/$DEFAULT_THEME_FILE")"
		fi
	fi
	if [ -n "$CONFIG" ]; then
		value="$(read_config "COLOR_BACKGROUND" "$CONFIG" false true)"
		if [ "$value" == "" ]; then
			value="ffffff"
		fi
		if [ "${value,,}" == "transparent" ]; then
			NOCOLOR="${ESC}0m"
		else
			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))
			NOCOLOR="${ESC}0;48;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_HIGHLIGHT" "$CONFIG" false true)"
		if [ "$value" == "" ]; then
			value="cccccc"
		fi
		color="${value#"#"}"
		red=$((16#${color:0:2}))
		green=$((16#${color:2:2}))
		blue=$((16#${color:4:2}))

		BLUE="${ESC}1;38;2;${red};${green};${blue}m"
		if [ "$PANELS_ENABLED" == true ]; then
			BLUE_BLACK="${ESC}1;38;2;${red};${green};${blue};1;40m"
		else
			BLUE_BLACK="${ESC}1;38;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_UNSELECTED" "$CONFIG" false true)"
		if [ "$value" == "" ]; then
			value="333333"
		fi
		color="${value#"#"}"
		red=$((16#${color:0:2}))
		green=$((16#${color:2:2}))
		blue=$((16#${color:4:2}))

		WHITE="${ESC}1;38;2;${red};${green};${blue}m"
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue};1;40m"
		else
			WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_PANEL" "$CONFIG" false true)"
		if [ "$value" == "" ]; then
			value="000000"
		fi
		if [ "$value" != "" ]; then
			COLOR_PANEL="$value"

			colorblue="${COLOR_PANEL#"#"}"
			red=$((16#${colorblue:0:2}))
			green=$((16#${colorblue:2:2}))
			blue=$((16#${colorblue:4:2}))

			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
				BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			fi
			COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"
		fi
	fi
}

is_num() {
	if [[ "$1" =~ ^-?[0-9]+(\.[0-9]*)?$ ]]; then
		if [[ "$1" == *"."* ]]; then
			echo -n "2"
		else
			echo -n "1"
		fi
	else
		echo -n "0"
	fi
}

check_dep() {
	local dep="$1"

	if [ ! -x "$(command -v "$dep")" ]; then
		if [ -n "$2" ]; then
			echo -e "${ESC}1;33mMissing optional dependency ${NOCOLOR}$dep"
			sleep 1s
		else
			echo -e "${ESC}1;31mMissing dependency ${NOCOLOR}$dep"
		fi
		QUIT=true
	fi
}

REPEAT_HELP="Loop Controls
6  Switch Loops
^  Reverse Switch
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
S  Start -0.01
G  Start +0.01
s  Start -0.05
g  Start +0.05
H  End -0.01
L  End +0.01
h  End -0.05
l  End +0.05
<  Gap -1
>  Gap +1
e  Play Transition
^H  Seek to Start
5  Start Position
7  End Position
c  Move Banner"

ORIG_REPEAT_HELP="$REPEAT_HELP"

SETUP_HELP="#  Save Settings
Voice Controls
d  Speak Page
T  Feedback Level
Voice Volume Settings
8  Volume Down
9  Volume Up
Voice Pitch Settings
J  Down
K  Up
Language
^V  Voice Engine
Metadata Cache
c  Cache Tags
^T  Toggle Tags
Customization
^A  Select Theme
^P  Toggle Panels
^O  Swap Color"

ORIG_SETUP_HELP="$SETUP_HELP"

QUEUE_HELP="Queue Controls
j  Page Down
k  Page Up
h  Selection Down
l  Selection Up
x  Remove Song
<  Move Song Down
>  Move Song Up
s  Keyword Search
c  Toggle Filename
g  Edit Tag
^G  Update Tag
'  Top
\"  Bottom"

ORIG_QUEUE_HELP="$QUEUE_HELP"

SCALE_HELP="Scale Controls
j  Scale Down
k  Scale Up
o  Double EDO
m  Halve EDO
c  Reverse
y  $DEFAULT_EDO-EDO"

ORIG_SCALE_HELP="$SCALE_HELP"

HELP="Basic Controls
i  Menu
?  Key Controls
j  Page Down
k  Page Up
;  Queue
p  Pause
n  Next Song
b  Previous Song
m  Man Page
q  Quit
Voice Feedback
d  Toggle Voice
T  Feedback Level
#  Save Settings
^K  Read Interval
I  Read Corner
,  Read Title
^S  Read Lock Status
Volume Controls
*  1% Down
(  1% Up
8  3% Down
9  3% Up
!  PCM 1% Down
@  PCM 1% Up
1  PCM 5% Down
2  PCM 5% Up
c  Mute
3  Fade Up/Down
Interval Controls
j  Pitch Down
k  Pitch Up
x  Lock
X  Unlock
f  Next Lock
F  Previous Lock
m  Half EDO
o  Double EDO
.  Set INT
/  Set EDO
w  Reset to Locked
H  Least Precise
L  Fully Precise
J  EDO Down
K  EDO Up
y  $DEFAULT_EDO-EDO
4  Reset INT/EDO
^U  Toggle Locked
Pitch Jump Controls
_  Octave Down
+  Octave Up
M  Inverse INT
Y  Zero INT
Pitch Fade Controls
C  Scale Speed
t  Zero INT
u  INT Up/Down
U  EDO Up/Down
-  Octave Down
=  Octave Up
^Y  Inverse INT
G  Oscillate
Balance Controls
{  1% Left Up
}  1% Right Up
[  1% Left Down
]  1% Right Down
0  Reset Fade
)  Reset
Track Controls
h  Seek Backward
l  Seek Forward
b  Queue Backward
n  Queue Forward
p  Pause
\\  Restart
r  Rename
D  Archive
^D  Delete
a  Equalizer
$  Save Position
^H  Seek to Position
P  Progress Bar
O  VIM Menu
g  Edit Tag
^G  Update Tag
Queue Controls
;  Queue
R  Shuffle
A  Sort
\"  Last of Artist
'  First of Artist
N  Next Artist
B  Previous Artist
Z  Export As
e  Loop Toggle
^R  Random Mode
Loop Toggle Controls
E  Loop Song
V  Loop Artist
Search Controls
S  New Search
s  Jump To
^I  Add Songs
Loop Editor Controls
5  Start Position
7  End Position
6  Enter Loop
6  Switch Loops
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
^E  Play Only Loops
\\  Seek to Start
Video Controls
<  Enable Video
>  Fullscreen Video
Download Controls
W  Add Downloads
^W  Jump Downloads
^N  Add and Jump
Advanced Controls
^A  Select Theme
^O  Swap Color
^P  Pause All
z  Redraw Screen
~  Sleep mode
|  Vanish Editor"

ORIG_HELP="$HELP"

HELP_LENGTH="$(echo -e "$HELP" | wc -l)"
SETUP_HELP_LENGTH="$(echo -e "$SETUP_HELP" | wc -l)"
SCALE_HELP_LENGTH="$(echo -e "$SCALE_HELP" | wc -l)"
REPEAT_HELP_LENGTH="$(echo -e "$REPEAT_HELP" | wc -l)"
QUEUE_HELP_LENGTH="$(echo -e "$QUEUE_HELP" | wc -l)"

export HELP_LENGTH
export SETUP_HELP_LENGTH
export SCALE_HELP_LENGTH
export REPEAT_HELP_LENGTH
export QUEUE_HELP_LENGTH

check_local_lang() {
	case "$1" in
		"af") return 0 ;;
		"bs") return 0 ;;
		"ca") return 0 ;;
		"cs") return 0 ;;
		"cy") return 0 ;;
		"da") return 0 ;;
		"de") return 0 ;;
		"el") return 0 ;;
		"en") return 0 ;;
		"eo") return 0 ;;
		"hi") return 0 ;;
		"ar") return 0 ;;
		"es") return 0 ;;
		"et") return 0 ;;
		"fi") return 0 ;;
		"fr") return 0 ;;
		"hr") return 0 ;;
		"hu") return 0 ;;
		"hy") return 0 ;;
		"id") return 0 ;;
		"it") return 0 ;;
		"nl") return 0 ;;
		"pl") return 0 ;;
		"pt") return 0 ;;
		"ru") return 0 ;;
		"sk") return 0 ;;
		"sq") return 0 ;;
		"sr") return 0 ;;
		"su") return 0 ;;
		"sv") return 0 ;;
		"sw") return 0 ;;
		"tr") return 0 ;;
		*) return 1 ;;
	esac
}

get_espeak_equiv() {
	case "$1" in
		"en") echo -ne "en-us" ;;
		"fr") echo -ne "fr-fr" ;;
		"su") echo -ne "en-us" ;;
		*) echo -ne "$1" ;;
	esac
}

check_config() {
	path="$ALETHEIA/config"
	if [ -e "$path" ]; then
		CONFIG="$(<"$path")"

		if [ "$CONFIG" != "" ]; then
			value="$(read_config "AUDIO_FORMATS")"
			if [ "$value" != "" ]; then
				AUDIO_FORMATS="$value"
			fi

			value="$(read_config "VIDEO_FORMATS")"
			if [ "$value" != "" ]; then
				VIDEO_FORMATS="$value"
			fi

			value="$(read_config "USE_TAGS")"
			if [ "$value" != "" ]; then
				USE_TAGS="$value"
				if [ "$USE_TAGS" != true ] && [ "$USE_TAGS" != false ]; then
					USE_TAGS=false
				fi
			fi

			value="$(read_config "PARALLEL_CACHE_ENABLED")"
			if [ "$value" != "" ]; then
				PARALLEL_CACHE_ENABLED="$value"
				if [ "$PARALLEL_CACHE_ENABLED" != true ] && [ "$PARALLEL_CACHE_ENABLED" != false ]; then
					PARALLEL_CACHE_ENABLED=false
				fi
				if [ "$PARALLEL_CACHE_ENABLED" == true ]; then
					QUIT=false
					check_dep parallel true
					sleep 3s
					if [ "$QUIT" == true ]; then
						PARALLEL_CACHE_ENABLED=false
					fi
				fi
				if [ "$PARALLEL_CACHE_ENABLED" == true ]; then
					value="$(read_config "PARALLEL_CACHE_JOBS")"
					if [ "$value" != "" ]; then
						PARALLEL_CACHE_JOBS="$value"
						if [ "$(is_num "$PARALLEL_CACHE_JOBS")" != "1" ] || [ "$PARALLEL_CACHE_JOBS" -lt "0" ]; then
							PARALLEL_CACHE_JOBS="4"
						fi
					fi
				fi
			fi

			value="$(read_config "MUSIC_DIR" "" true)"
			if [ "$value" != "" ]; then
				if [ -d "$value" ]; then
					MUSICDIR="$value"
				fi
			fi

			value="$(read_config "SOUND_DIR" "" true)"
			if [ "$value" != "" ]; then
				if [ -d "$value" ]; then
					SOUNDDIR="$value"
				fi
			fi

			value="$(read_config "VIDEO_DIR" "" true)"
			if [ "$value" != "" ]; then
				if [ -d "$value" ]; then
					VIDEODIR="$value"
				fi
			fi

			value="$(read_config "NO_HELP")"
			if [ "$value" != "" ]; then
				NO_HELP="$value"
				if [ "$NO_HELP" != true ] && [ "$NO_HELP" != false ]; then
					NO_HELP=false
				fi
			fi

			value="$(read_config "DISPLAY_ALBUM")"
			if [ "$value" != "" ]; then
				DISPLAY_ALBUM="$value"
				if [ "$DISPLAY_ALBUM" != true ] && [ "$DISPLAY_ALBUM" != false ]; then
					DISPLAY_ALBUM=false
				fi
			fi

			if [ -z "$NO_VERTICAL_PADDING" ] || [ "$1" == true ]; then
				value="$(read_config "NO_VERTICAL_PADDING")"
				if [ "$value" != "" ]; then
					NO_VERTICAL_PADDING="$value"
					if [ "$NO_VERTICAL_PADDING" != true ] && [ "$NO_VERTICAL_PADDING" != false ]; then
						NO_VERTICAL_PADDING=false
					fi
				fi
			fi

			value="$(read_config "LIMIT_MASTER_VOLUME")"
			if [ "$value" != "" ]; then
				LIMIT_MASTER_VOLUME="$value"
				if [ "$(is_num "$value")" != "1" ] || [ "$value" -gt "100" ]; then
					LIMIT_MASTER_VOLUME=100
				fi
				if [ "$LIMIT_MASTER_VOLUME" -lt "0" ]; then
					LIMIT_MASTER_VOLUME=0
				fi
			fi

			value="$(read_config "DEFAULT_EDO")"
			if [ "$value" != "" ]; then
				DEFAULT_EDO="$value"
				if [ "$(is_num "$value")" != "1" ] || [ "$value" -le "0" ]; then
					DEFAULT_EDO=60
				fi
			fi

			value="$(read_config "DEFAULT_INTERVAL")"
			if [ "$value" != "" ]; then
				DEFAULT_INTERVAL="$value"
				if [ "$(is_num "$value")" != "1" ] || [ "$(bc <<<"$value < -($DEFAULT_EDO*2.6)")" == "1" ] || [ "$(bc <<<"$value > ($DEFAULT_EDO*2.1)")" == "1" ]; then
					DEFAULT_INTERVAL=0
				fi
			fi

			value="$(read_config "DEFAULT_EQUALIZER")"
			if [ "$value" != "" ]; then
				DEFAULT_EQUALIZER="$value"
				stripped_value=${value//:/}
				stripped_value=$((${#value} - ${#stripped_value}))
				if [ "$stripped_value" == "9" ] && [ -z "$(echo -ne "$value" | sed -n '/^\(-\?\(1[0-2]\|[0-9]\):\)\{9\}-\?\(1[0-2]\|[0-9]\)$/p')" ]; then
					DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
				elif [ "$stripped_value" == "2" ] && [ -z "$(echo -ne "$value" | sed -n '/^\(-\?\(1[0-2]\|[0-9]\):\)\{2\}-\?\(1[0-2]\|[0-9]\)$/p')" ]; then
					DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
				else
					if [ "$stripped_value" == "2" ]; then
						bass=${value%%:*}
						tmp=${value%:*}
						mid=${tmp#*:}
						treble=${value##*:}

						bass="$bass:$bass:$bass"
						mid="$mid:$mid:$mid:$mid"
						treble="$treble:$treble:$treble"

						DEFAULT_EQUALIZER="$bass:$mid:$treble"
					fi
				fi
			fi

			value="$(read_config "DEFAULT_VOLUME")"
			if [ "$value" != "" ]; then
				DEFAULT_VOLUME="$value"
				if [ "$(is_num "$value")" != "1" ] || [ "$value" -gt "100" ] || [ "$value" -lt "0" ]; then
					DEFAULT_VOLUME=50
				fi
			fi

			value="$(read_config "VOICE_ENABLED")"
			if [ "$value" != "" ]; then
				VOICE_ENABLED="$value"
				if [ "$VOICE_ENABLED" != true ] && [ "$VOICE_ENABLED" != false ]; then
					VOICE_ENABLED=false
				fi
			fi

			value="$(read_config "ONLY_VOICE_TITLES")"
			if [ "$value" != "" ]; then
				ONLY_VOICE_TITLES="$value"
				if [ "$ONLY_VOICE_TITLES" != true ] && [ "$ONLY_VOICE_TITLES" != false ]; then
					ONLY_VOICE_TITLES=false
				fi
			fi

			value="$(read_config "VOICE_PITCH")"
			if [ "$value" != "" ]; then
				VOICE_PITCH="$value"
				if [ "$(is_num "$value")" != "1" ] || [ "$(bc <<<"$value < ($DEFAULT_EDO*2.6)")" == "1" ] || [ "$(bc <<<"$value > ($DEFAULT_EDO*2.1)")" == "1" ]; then
					VOICE_PITCH=0
				fi
			fi

			value="$(read_config "VOICE_VOLUME")"
			if [ "$value" != "" ]; then
				VOICE_VOLUME="$value"
				ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
				if [ "$VOICE_VOLUME" == "0" ] || [ "$VOICE_VOLUME" == "0.0" ]; then
					VOICE_ENABLED=false
				elif [ "$(is_num "$value")" != "1" ] && [ "$(is_num "$value")" != "2" ] || [ "$(bc <<<"$value < 0")" == "1" ] || [ "$(bc <<<"$value > 1.0")" == "1" ]; then
					VOICE_VOLUME=0.85
					ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
				fi
			fi

			value="$(read_config "VOICE_ENGINE")"
			if [ "$value" != "" ]; then
				if [ "$value" == "gtts-cli" ]; then
					QUIT=false
					check_dep gtts-cli true
					check_dep play true
					if [ "$QUIT" == true ]; then
						GTTS_NATURAL_VOICE=false
						ESPEAK_DIGITAL_VOICE=true
					else
						GTTS_NATURAL_VOICE=true
						ESPEAK_DIGITAL_VOICE=false
					fi
				else
					GTTS_NATURAL_VOICE=false
					ESPEAK_DIGITAL_VOICE=true
				fi
			fi

			value="$(read_config "LANGUAGE")"
			if [ "$value" != "" ]; then
				GTTS_LANGUAGE="$value"
				ESPEAK_LANGUAGE="$(get_espeak_equiv "$value")+m1"
				if check_local_lang "$GTTS_LANGUAGE"; then
					VOICE_APPEND=".$GTTS_LANGUAGE"
				else
					VOICE_APPEND=".en"
					GTTS_LANGUAGE="en"
				fi
				LANGUAGE=
				if [ -e "$ALETHEIA/languages/$GTTS_LANGUAGE" ]; then
					LANGUAGE="$(<"$ALETHEIA/languages/$GTTS_LANGUAGE")"
					if [ -e "$ALETHEIA/languages/$GTTS_LANGUAGE.help" ]; then
						# shellcheck disable=SC1090
						# Run shellcheck on these individually
						source "$ALETHEIA/languages/$GTTS_LANGUAGE.help"
					fi
				elif [ -e "$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE" ]; then
					LANGUAGE="$(<"$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE")"
					if [ -e "$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE.help" ]; then
						# shellcheck disable=SC1090
						# Run shellcheck on these individually
						source "$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE.help"
					fi
				fi
			fi

			value="$(read_config "PANELS_ENABLED")"
			if [ "$value" != "" ]; then
				PANELS_ENABLED="$value"
				if [ "$PANELS_ENABLED" != true ] && [ "$PANELS_ENABLED" != false ]; then
					PANELS_ENABLED=true
				fi
			fi

			if [ "$PANELS_ENABLED" == true ]; then
				BLUE_BLACK="${ESC}1;34;1;40m"
				WHITE_BLACK="${ESC}1;37;1;40m"
			else
				BLUE_BLACK="${ESC}1;34m"
				WHITE_BLACK="${ESC}1;37m"
			fi

			value="$(read_config "THEME_ENABLED")"
			if [ "$value" != "" ]; then
				THEME_ENABLED="$value"
				if [ "$THEME_ENABLED" != true ] && [ "$THEME_ENABLED" != false ]; then
					THEME_ENABLED=true
				fi
			fi

			value="$(read_config "THEME_FILE" "" true)"
			if [ "$value" != "" ]; then
				THEME_FILE="$value"
			fi

			if [ "$THEME_ENABLED" == true ] && [ -n "$THEME_FILE" ]; then
				check_colors true
			else
				check_colors
			fi
		fi
	fi
}

QUIT=false
check_dep bc
check_dep calc
check_dep espeak-ng
check_dep exiftool
check_dep eyeD3
check_dep ffmpeg
check_dep ffprobe
check_dep iconv
check_dep mplayer
check_dep pactl
check_dep sox
check_dep sqlite3

if [ "$QUIT" == true ]; then
	stty echo
	tput cnorm
	exit 1
fi

if [ ! -e "$ALETHEIA/config" ]; then
	sed "s/<username>/$(whoami)/g" <"$ALETHEIA_DATA_DIR/example.config" >"$ALETHEIA/config"
fi

check_config
if [ "$THEME_FILE" != "" ]; then
	if [ "$THEME_ENABLED" == true ]; then
		check_colors true
	else
		check_colors
	fi
fi

if check_local_lang "$GTTS_LANGUAGE"; then
	VOICE_APPEND=".$GTTS_LANGUAGE"
else
	VOICE_APPEND=".en"
	GTTS_LANGUAGE="en"
fi

if [ -z "$NO_VERTICAL_PADDING" ]; then
	NO_VERTICAL_PADDING=false
fi

# shellcheck disable=SC2317
# Function used indirectly via GNU parallel to extract metadata
extract_metadata() {
	file=$1
	time=$(ffprobe -i "$file" -show_entries format=duration -v quiet -of csv="p=0" | cut -d'.' -f1)
	line="$(exiftool -Artist -Title -Album -TrackNumber "$1")"
	artist="$(echo -ne "$line" | grep -E "^Artist" 2>/dev/null)"
	song="$(echo -ne "$line" | grep -E "^Title" 2>/dev/null)"
	i="${file##*/}"
	i="${i//\'/\'\'}"
	if [ "$artist" == "" ] && [ "$song" == "" ]; then
		if [ "$2" == true ]; then
			echo -ne "INSERT OR REPLACE INTO music (filename, time) VALUES ('$i', '$time');" >>"$ALETHEIA/useless_out"
		else
			echo -ne "INSERT OR REPLACE INTO music (filename, time) VALUES ('$i', '$time');"
		fi
		return
	fi
	album="$(echo -n "$line" | grep -E "^Album" 2>/dev/null)"
	tracknum="$(echo -n "$line" | grep -E "^Track Number" 2>/dev/null)"
	artist="${artist#*: }"
	song="${song#*: }"
	if [ "$2" == true ]; then
		echo ": $artist - $song" >>"$ALETHEIA/useless"
	else
		echo ": $artist - $song" >/dev/stderr
	fi
	album="${album##*: }"
	tracknum="${tracknum##*: }"
	artist="${artist//\'/\'\'}"
	song="${song//\'/\'\'}"
	album="${album//\'/\'\'}"
	tracknum="${tracknum//\'/\'\'}"
	((index++))

	if [ "$2" == true ]; then
		echo -ne "INSERT OR REPLACE INTO music (filename, artist, song, album, number, time) VALUES ('$i', '$artist', '$song', '$album', '$tracknum', '$time');" >>"$ALETHEIA/useless_out"
	else
		echo -ne "INSERT OR REPLACE INTO music (filename, artist, song, album, number, time) VALUES ('$i', '$artist', '$song', '$album', '$tracknum', '$time');"
	fi
}

cache_metadata() {
	export db_file="$ALETHEIA/music.db"
	if [ -z "$1" ]; then
		if [ -e "$db_file" ]; then
			mv "$db_file" "$db_file.backup"
		fi
	else
		if [ -e "$ALETHEIA/filelist_unique_fullpath.tmp" ]; then
			rm -f "$ALETHEIA/filelist_unique_fullpath.tmp"
		fi
		find "$MUSICDIR" -type f -regex "$regex" | sort >"$ALETHEIA/filelist_sorted_fullpath.tmp"
		while IFS= read -r filename; do
			tmp_filename=${filename//\[/\\\[}
			tmp_filename=${tmp_filename//\]/\\\]}
			grep "$tmp_filename" "$ALETHEIA/filelist_sorted_fullpath.tmp" >>"$ALETHEIA/filelist_unique_fullpath.tmp"
		done <"$1"
	fi
	if [ -e "$ALETHEIA/filelist_sorted_fullpath.tmp" ]; then
		rm -f "$ALETHEIA/filelist_sorted_fullpath.tmp"
	fi
	sqlite3 "$db_file" "CREATE TABLE IF NOT EXISTS music (filename TEXT PRIMARY KEY, artist TEXT, song TEXT, album TEXT, number TEXT, time TEXT);"

	regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"

	if [ -n "$1" ]; then
		mapfile -t music_array < <(cat "$ALETHEIA/filelist_unique_fullpath.tmp")
	else
		mapfile -t music_array < <(find "$MUSICDIR" -type f -iregex "$regex")
	fi

	rm -f "$ALETHEIA/useless" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/useless_out" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/cancel.tmp" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/finished.tmp" >/dev/null 2>/dev/null
	touch "$ALETHEIA/useless"
	touch "$ALETHEIA/useless_out"
	export -f extract_metadata
	gtts_speak "Caching metadata. This may take a while."
	key=
	parallel_pid=
	if [ "$PARALLEL_CACHE_ENABLED" == true ]; then
		local jobs=
		if [ -n "$PARALLEL_CACHE_JOBS" ]; then
			jobs="$PARALLEL_CACHE_JOBS"
		else
			jobs=4
		fi
		parallel -j"$jobs" extract_metadata {} ::: "${music_array[@]}" >>"$ALETHEIA/useless_out" 2>>"$ALETHEIA/useless" &
		parallel_pid=$!
	else
		count=1
		total=${#music_array[@]}
		for music_file in "${music_array[@]}"; do
			extract_metadata "$music_file" true
			if [ "$count" == "$total" ]; then
				touch "$ALETHEIA/finished.tmp"
			fi
			((count++))
			if [ -e "$ALETHEIA/cancel.tmp" ]; then
				rm -f "$ALETHEIA/cancel.tmp"
				break
			fi
		done &
	fi
	clear
	#while [ -s "$ALETHEIA/useless" ]; do
	#	sleep 0.5
	#done
	echo -ne "$BLUE"
	tail -f "$ALETHEIA/useless" | grep -E "^:" &
	tail_pid=$!

	while true; do
		read -rsn1 -t 1 key
		if [ "$key" == "q" ]; then
			touch "$ALETHEIA/cancel.tmp"
			if [ -n "$parallel_pid" ]; then
				kill "$parallel_pid" >/dev/null 2>/dev/null
			fi
			if [ -e "$db_file.backup" ]; then
				mv "$db_file.backup" "$db_file"
			fi
			break
		elif [ "$key" == $'\e' ]; then
			touch "$ALETHEIA/cancel.tmp"
			read -rsn3 -t 0.001
			if [ -n "$parallel_pid" ]; then
				kill "$parallel_pid" >/dev/null 2>/dev/null
			fi
			if [ -e "$db_file.backup" ]; then
				mv "$db_file.backup" "$db_file"
			fi
			break
		fi
		if [ -n "$parallel_pid" ]; then
			if ! ps -p "$parallel_pid" >/dev/null 2>/dev/null; then
				if [ -e "$db_file.backup" ]; then
					rm -f "$db_file.backup" >/dev/null 2>/dev/null
				fi
				break
			fi
		elif [ -e "$ALETHEIA/finished.tmp" ]; then
			rm -f "$db_file.backup" >/dev/null 2>/dev/null
			break
		fi
	done

	kill "$tail_pid"
	tail_pid=
	if [ -e "$ALETHEIA/filelist_unique_fullpath.tmp" ]; then
		rm -f "$ALETHEIA/filelist_unique_fullpath.tmp"
	fi

	line="$(<"$ALETHEIA/useless_out")"
	echo -ne "BEGIN;${line};END;" >"$ALETHEIA/music.sql"
	sqlite3 "$db_file" <"$ALETHEIA/music.sql"
	rm -f "$ALETHEIA/music.sql"
	gtts_speak "finished"
}

compute() {
	# if no pitch change requested, eliminate the overhead of calling sox to
	# change the default pitch of Google's digital voice
	if check_local_lang "$GTTS_LANGUAGE"; then
		lang="$GTTS_LANGUAGE"
	else
		lang="en"
	fi
	if [ "$VOICE_PITCH" == "0" ]; then
		gtts-cli " $1" -l "$lang" -o "$ALETHEIA/voices$VOICE_APPEND/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
	else
		gtts-cli " $1" -l "$lang" -o "/tmp/_$2-tmp.mp3" >/dev/null 2>/dev/null
		sox "/tmp/_$2-tmp.mp3" "$ALETHEIA/voices$VOICE_APPEND/$2${VOICE_PITCH}.mp3" speed "$(calc -pd "2^($VOICE_PITCH/60)")" >/dev/null 2>/dev/null
		rm -f "/tmp/_$2-tmp.mp3"
	fi
	if [ "$3" != true ]; then
		play -v "$VOICE_VOLUME" "$ALETHEIA/voices$VOICE_APPEND/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
	fi
}

gtts_speak_chain() {
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		kill "$(cat "$ALETHEIA/espeak.pid" 2>/dev/null)" >/dev/null 2>/dev/null
	fi
	if [ "$ESPEAK_DIGITAL_VOICE" == true ] && [ "$VOICE_ENABLED" == true ]; then
		list=""
		for i in "$@"; do
			list+="$i, "
		done
		if [ "${list:0:1}" == "-" ]; then
			list=" $list"
		fi
		espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" "$list" >/dev/null 2>/dev/null &
		echo -ne "$!" >"$ALETHEIA/espeak.pid"
	elif [ "$GTTS_NATURAL_VOICE" == true ]; then
		if [ "$NO_WAIT" != true ]; then
			if (( $# > 2 )); then
				gtts_speak "please wait"
			fi
		fi
		if [ "$VOICE_ENABLED" == true ]; then
			CHAIN=()
			index=0
			for i in "$@"; do
				if [ "${i:0:1}" == " " ]; then
					clip="${i:1}"
				else
					clip="$i"
				fi
				if [ "${i:0:1}" == "\-" ]; then
					clip="\\$clip"
				fi
				if [ "$clip" == "" ]; then
					continue
				fi
				clip="$(get_local_phrase "$clip")"
				if [ -e "$ALETHEIA/voices$VOICE_APPEND/$clip${VOICE_PITCH}.mp3" ]; then
					if [ "$(echo -ne "$clip" | rev | cut -c 1)" == "?" ]; then
						clip="$(echo -ne "$clip" | rev | cut -c 2- | rev)\\?"
					fi
				else
					compute "$clip" "$clip" true >/dev/null 2>/dev/null
				fi
				CHAIN[index]="$clip"
				index=$((index+1))
			done

			ind=0
			for i in "${CHAIN[@]}"; do
				z="$(get_local_phrase "$i")"
				CHAIN[ind]="$ALETHEIA/voices$VOICE_APPEND/$z${VOICE_PITCH}.mp3"
				ind=$((ind+1))
			done

			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			play -v "$VOICE_VOLUME" "${CHAIN[@]}" >/dev/null 2>/dev/null &
		fi
	fi
}

espeak_say() {
	if [ "$VOICE_ENABLED" == true ] || [ "$2" == true ] || [ "$4" == true ]; then
		if [ -n "$ESPEAK_PID" ] && [ "$ESPEAK_PID" != "$MPLAYER_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$VOICE_ENABLED" == false ] && [ "$4" != true ]; then
			return
		fi
		if [ "$1" != " " ]; then
			if [ "$2" == true ] || [ "$3" == true ]; then
				espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" " $1" >/dev/null 2>/dev/null
			else
				espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" " $1" >/dev/null 2>/dev/null &
			fi
		fi

		ESPEAK_PID="$!"
		if [ "$4" == true ]; then
			echo -ne "$ESPEAK_PID" >"$ALETHEIA/espeak.pid"
		fi
	fi
}


gtts_speak() {
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		if [ -e "$ALETHEIA/espeak.pid" ]; then
			kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
		fi
		espeak_say "$1" "$2" "$3" "$4"
	else
		local z="$1"
		if [ "$6" != true ]; then
			z="$(get_local_phrase "$z")"
		else
			z="$(get_local_phrase "$z" false true)"
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ] && [ "$VOICE_ENABLED" == true ] || [ "$2" == true ] || [ "$4" == true ]; then
			if [ "$ONLY_VOICE_TITLES" == false ] && [ "$VOICE_ENABLED" == false ] && [ "$4" != true ]; then
				return
			fi
			if [ "$5" != true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			line_count="$(echo -ne "$z" | wc -l)"
			if [ "$line_count" -gt 1 ]; then
				clip="$(echo -ne "$z" | head -1) - $line_count"
			else
				if [ "$(echo -ne "$z" | cut -c 1)" == " " ]; then
					clip="$(echo -ne "$z" | cut -c 2-)"
				else
					clip="$z"
				fi
				if [ "$(echo -ne "$z" | cut -c 1)" == "\-" ]; then
					clip="\\$clip"
				fi
			fi
			if [ -e "$ALETHEIA/voices$VOICE_APPEND/$clip${VOICE_PITCH}.mp3" ]; then
				if [ "$(echo -ne "$clip" | rev | cut -c 1)" == "?" ]; then
					clip="$(echo -ne "$clip" | rev | cut -c 2- | rev)\\?"
				fi
				if [ "$(echo -e "$VOICE_VOLUME > 1.0" | bc)" == "1" ]; then
					VOICE_VOLUME=.85
					ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
				fi
				if [ "$2" != true ]; then
					play -v "$VOICE_VOLUME" "$ALETHEIA/voices$VOICE_APPEND/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
				else
					play -v "$VOICE_VOLUME" "$ALETHEIA/voices$VOICE_APPEND/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
				fi
			else
				if [ "$line_count" -gt 1 ]; then
					if [ "$2" == false ] || [ "$2" == "" ]; then
						compute "$z" "$clip" >/dev/null 2>/dev/null &
					else
						compute "$z" "$clip" >/dev/null 2>/dev/null
					fi
				else
					if [ "$2" == false ] || [ "$2" == "" ]; then
						compute "$clip" "$clip" >/dev/null 2>/dev/null &
					else
						compute "$clip" "$clip" >/dev/null 2>/dev/null
					fi
				fi
			fi
		fi
	fi
}

draw_banner() {
	if [ "$3" != true ]; then
		LEFT=true
	else
		RIGHT_BANNER_WIDTH="$((${#i}+2))"
		LEFT=false
	fi
	if [ "$2" != true ]; then
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length="$POSITION_WIDTH"
		warning=false
	else
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length=5
		warning=true
	fi

	if [ "$3" == false ] || [ "$3" == "" ]; then
		tput cup $LINES
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}${1^^}$COLOR1 --$COLOR2 "
		tput sc
		if [ "$RIGHT_BANNER_WIDTH" != "0" ]; then
			if [ "$4" == true ]; then
				length="$RIGHT_BANNER_WIDTH"
			fi
		fi
		if [ "$((${#1} + 6 + RIGHT_BANNER_WIDTH + (${#PADDING}*2)))" -lt "$COLUMNS" ]; then
			printf '%*s' $((COLUMNS - ${#1} - 7 - (${#PADDING}*2) - length)) ""
		fi
	else
		tput cup $LINES $((COLUMNS - ${#1} - 8))
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}${1^^}$COLOR1 --$COLOR1 "
		RIGHT_BANNER_WIDTH=$((${#1}+6))
	fi

	if [ "$warning" == true ]; then
		echo -ne "${COLOR1}[${COLOR2}y${COLOR1}/${COLOR2}n${COLOR1}]$PADDING"
	fi

	if [ "$4" != true ]; then
		if [ "$3" != true ]; then
			tput rc
		fi
	fi
}

get_local_phrase() {
	if [ "$3" == true ]; then
		found="$(sed -n "/^$1\[$GTTS_LANGUAGE\]/p" <<<"$LANGUAGE" | tail -1)"
	else
		found="$(sed -n "/^$1\[$GTTS_LANGUAGE\]/{p;q}" <<<"$LANGUAGE")"
	fi
	if [ -n "$found" ]; then
		echo -ne "${found#*\]}"
	else
		echo -ne "$1"
	fi
}

draw_vanish_indicator() {
	tput cup $LINES $((COLUMNS-${#char_count}-2-${#word_count}-${#line_count}-${#PADDING}))
	echo -ne "$BLUE${char_count}$WHITE:$BLUE${word_count}$WHITE:$BLUE${line_count}$PADDING"
}

draw_vanish_banner() {
	tput cup $LINES
	echo -ne "${PADDING}$WHITE-- ${BLUE}$1$WHITE --"
	LEFTBANNER_WIDTH=$((6+${#1}))
}

clear_vanish_banner() {
	tput cup $LINES
	printf '%*s' $((LEFTBANNER_WIDTH+1)) ""
}

vanish() {
	local in_menu=$1
	gtts_speak "vanish"
	feedback_enabled=$VOICE_ENABLED
	inputnew=""
	display=""
	char_count=0
	line_count=1
	word_count=0
	saved_spot=""
	width=$((COLUMNS-((${#char_count}+2+${#word_count}+${#line_count})*2)-(${#PADDING}*2)-20))
	tput cup $LINES
	tput el
	draw_vanish_banner "$(get_local_phrase "INSERT")"
	tput cup $LINES $((COLUMNS/2))
	echo -ne "${BLUE}_"
	tput sc
	visible=true
	char=""
	draw_vanish_indicator
	tput rc
	tmpflag=true
	quit=false
	while true; do
		draw_vanish_banner "$(get_local_phrase "INSERT")"
		draw_vanish_indicator
		if [ "$tmpflag" == false ]; then
			IFS=$'\n'
			char=""
			until [ "$char" != "" ]; do
				read -rsn1 -t 0.6 char
				if [ "$char" == "" ]; then
						tput cup $LINES $((saved_spot+${#newdisplay}))
					if [ "$visible" == true ]; then
						echo -ne "${BLUE} "
						visible=false
					else
						echo -ne "${BLUE}_"
						visible=true
					fi
				fi
			done
			unset IFS
		else
			tmpflag=false
		fi
		preword=false
		if [ "$char" == $'\e' ]; then
			tput cup $LINES
			old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
			LEFTBANNER_WIDTH="9"

			if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
				printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
			fi
			gtts_speak "command mode"
			draw_vanish_banner "VANISH"
			while true; do
				read -rsn1 newchar
				if [ "$newchar" == "q" ]; then
					if [ "$in_menu" != true ]; then
						gtts_speak_chain "vanish closed" "main screen" &
						draw_pitch
						draw_position
					else
						gtts_speak "vanish closed" true
						draw_banner "$(get_local_phrase "MENU")"
						draw_position
						menu_start_over=true
						SKIP_SPEAK_MENU=false
					fi
					quit=true
					break
				elif [ "$newchar" == ":" ]; then
					clear_vanish_banner
					tput cup $LINES ${#PADDING}
					echo -ne ":"
					stty echo
					command_line="$(read_line)"
					stty -echo
					if [[ "$command_line" == *" "* ]]; then
						IFS=' ' read -r _ name <<< "$command_line"
						WRITE_AS="$name"
					else
						WRITE_AS=""
					fi
					if [ "$command_line" == "w" ] || [ "$WRITE_AS" != "" ] || [ "$command_line" == "wq" ]; then
						gtts_speak "saved"
						if [ "$WRITE_AS" == "" ]; then
							inputnew=$(fold -w 80 -s <<< "$inputnew")
							echo -ne "\n\n$(date)\n\n$inputnew\n" >>"$HOME/Documents/journal"
						else
							echo -ne "$inputnew" >"$HOME/$WRITE_AS"
						fi
						tput cup $LINES
						old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
						LEFTBANNER_WIDTH="11"

						if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
							printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
						fi
						draw_vanish_banner "$(get_local_phrase "SAVED")"
						sleep $BANNER_WAIT_TIME
						draw_vanish_banner "VANISH"
						if [ "$command_line" == "wq" ]; then
							if [ "$in_menu" != true ]; then
								draw_pitch
								draw_position
							else
								echo
							fi
							quit=true
						fi
						break
					elif [ "$command_line" == "q" ]; then
						if [ "$in_menu" != true ]; then
							draw_pitch
							draw_position
						else
							draw_banner "$(get_local_phrase "MENU")"
							draw_position
						fi
						quit=true
						break
					fi
				elif [ "$newchar" == "h" ]; then
					if [ "$width" -gt "$(((COLUMNS*5)/8))" ]; then
						continue
					fi
					width="$((width+2))"
					newdisplay="$(echo -ne "$display" | tail -c $width)"
					if [ "${char_count}" -le "$width" ]; then
						tput cup $LINES $(((COLUMNS/2)-$((char_count/2))))
					else
						tput cup $LINES $(((COLUMNS/2)-(width/2)))
					fi

					echo -ne "$WHITE${newdisplay}${BLUE}_"
					#FIXME
					tput el
					draw_vanish_indicator
				elif [ "$newchar" == "l" ]; then
					width="$((width-2))"
					if [ "$width" -lt "0" ]; then
						width=0
					fi
					newdisplay="$(echo -ne "$display" | tail -c $width)"
					if [ "${char_count}" -le "$width" ]; then
						tput cup $LINES $(((COLUMNS/2)-$((char_count/2))))
					else
						tput cup $LINES $(((COLUMNS/2)-(width/2)))
					fi
					tput cub1
					echo -ne " "
					echo -ne "$WHITE${newdisplay}${BLUE}_"
					tput el
					draw_vanish_indicator
				elif [ "$newchar" == "p" ]; then
					toggle_pause true
				elif [ "$newchar" == "w" ]; then
					gtts_speak "saved"
					inputnew=$(fold -w 80 -s <<< "$inputnew")
					echo -ne "\n\n$(date)\n\n$inputnew\n" >>"$HOME/Documents/journal"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="11"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
					fi
					draw_vanish_banner "$(get_local_phrase "SAVED")"
					sleep $BANNER_WAIT_TIME
				elif [ "$newchar" == "n" ]; then
					gtts_speak "new entry"
					inputnew=""
					display=""
					char_count=0
					tput cup $LINES
					tput el
					draw_vanish_indicator
					break
				elif [ "$newchar" == "d" ]; then
					if [ "$VOICE_ENABLED" == true ]; then
						gtts_speak "off"
						VOICE_ENABLED=false
						feedback_enabled=false
					else
						VOICE_ENABLED=true
						gtts_speak "on"
						feedback_enabled=true
					fi
				elif [ "$newchar" == "v" ]; then
					fold -w $COLUMNS -s <<< "$inputnew" | less
					gtts_speak "insert mode"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="12"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
					fi
					draw_vanish_banner "$(get_local_phrase "SAVED")"
					tput el
					draw_vanish_indicator
					break
				elif [ "$newchar" == "i" ]; then
					draw_vanish_indicator
					gtts_speak "insert mode"
					break
				fi
			done
			if [ "$quit" == true ]; then
				break
			fi
		elif [ "$char" == $'\x7F' ]; then
			if [ "$char_count" -gt "0" ]; then
				newchar="$(echo -ne "$inputnew" | rev | cut -c 1)"
				if [ "$newchar" == " " ]; then
					if [ "$inword" == true ]; then
						inword=false
						word_count=$((word_count-1))
						draw_vanish_indicator
					fi
					preword=true
				elif [ "$newchar" != " " ]; then
					inword=true
				elif [ "$preword" == true ]; then
					inword=true
					preword=false
				fi
				inputnew="$(echo -ne "$inputnew" | rev | cut -c2- | rev)"
				display="$(echo -ne "$display" | rev | cut -c2- | rev)"
				char_count=$((char_count-1))
				draw_vanish_indicator
				if [ "$word" != "" ]; then
					word="$(echo -ne "$word" | rev | cut -c2- | rev)"
				fi
				if [ "${char_count}" -lt "$width" ]; then
					saved_spot=$(((COLUMNS/2)-(char_count/2)-1))
					tput cup $LINES $saved_spot
					echo -ne " "
				fi
			fi
		elif [ "$char" == "" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" " $inputnew" &
			ESPEAK_PID="$!"
		elif [ "$char" == "" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
		else
			char_count=$((char_count+1))
			if [ "$char" == " " ]; then
				preword=false
				inputnew="${inputnew} "
				display="${display} "
				if [ "$feedback_enabled" == true ]; then
					espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" "$word" &
					ESPEAK_PID="$!"
				fi
				if [ "$inspace" == false ]; then
					word_count=$((word_count+1))
				fi
				inspace=true
				word=""
			else
				preword=false
				inputnew="${inputnew}${char}"
				display="${display}${char}"
				if [ "$inspace" == true ]; then
					inspace=false
					inword=true
				fi
				if [ "$char" == "." ] || [ "$char" == "?" ] || [ "$char" == "," ] || [ "$char" == "!" ]; then
					if [ "$feedback_enabled" == true ]; then
						espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" -v "$ESPEAK_LANGUAGE" "$word" &
						ESPEAK_PID="$!"
					fi
					word_count=$((word_count+1))
					inword=false
					word=""
				else
					word="$word$char"
				fi
			fi
		fi
		newdisplay="$(echo -ne "$display" | tail -c $width)"
		tput sc
		if [ "${char_count}" -le "$width" ]; then
			saved_spot=$(((COLUMNS/2)-(char_count/2)))
			tput cup $LINES $saved_spot
		else
			saved_spot=$(((COLUMNS/2)-(width/2)))
			tput cup $LINES $saved_spot
		fi
		echo -ne "$WHITE${newdisplay}${BLUE}_ \b"
		draw_vanish_indicator
		tput rc
	done
}

if [ "$1" == "--vanish" ]; then
	vanish true
	echo -ne "${ESC}0m"
	clear
	tput cnorm
	stty echo
	exit 0
fi

if [ "$LINES" -lt "7" ] || [ "$COLUMNS" -lt "33" ]; then
	if [ "$BYPASS_WARNING" != true ]; then
		echo -e "${RED}Error:${NOCOLOR} Terminal dimensions too small (Requires >= 33x7)"
		sleep 5
	fi
fi

draw_wait() {
	local clear_screen=$1
	if [ "$clear_screen" != true ]; then
		echo -ne "$NOCOLOR"
		clear
	fi
	if [ "$PANELS_ENABLED" == true ]; then
		tput cup 0
		printf "$BLUE_BLACK%*s" "$COLUMNS" " "
		tput cup "$LINES"
		printf "$BLUE_BLACK%*s" "$COLUMNS" " "
	fi
	tput cup $((LINES/2)) $(((COLUMNS/2)-5))
	echo -ne "$NOCOLOR${WHITE}-- ${BLUE}WAIT ${WHITE}--$NOCOLOR"
	gtts_speak "wait" false true
}

# shellcheck disable=SC2317
# trap function
cleanup() {
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		if [ -e "$ALETHEIA/espeak.pid" ]; then
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			rm -f "$ALETHEIA/espeak.pid" >/dev/null 2>/dev/null
		fi
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	fi
	if [ -n "$tail_pid" ]; then
		kill "$tail_pid" >/dev/null 2>/dev/null
	fi
	if [ ! -e "$ALETHEIA/finished.tmp" ] && [ "$METADATA_FINISHED" == false ]; then
		touch "$ALETHEIA/cancel.tmp"
	else
		rm -f "$ALETHEIA/finished.tmp"
		rm -f "$ALETHEIA/cancel.tmp" >/dev/null 2>/dev/null
	fi
	rm -f "$ALETHEIA"/useless{,_out}
	rm -f "$ALETHEIA/start$$"
	rm -f "$ALETHEIA/mplayer_output$$"
	rm -f "$ALETHEIA/mplayer_output_stderr$$"
	if [ -e "$ALETHEIA/fade" ]; then
		rm -f "$ALETHEIA/fade"
	fi
	pkill -f "^tail -f.*useless" >/dev/null 2>/dev/null
	tmp_volume_left="$(echo "$SYSTEM_VOLUME_LEFT" | cut -d'%' -f1)"
	tmp_volume_right="$(echo "$SYSTEM_VOLUME_RIGHT" | cut -d'%' -f1)"
	if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ "$SYSTEM_VOLUME_LEFT" >/dev/null 2>/dev/null
	elif [ "$tmp_volume_left" -lt "$tmp_volume_right" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ "$SYSTEM_VOLUME_RIGHT" >/dev/null 2>/dev/null
	fi
	echo -ne "${ESC}0m"
	clear
	tput cnorm
	stty ixon
	stty echo
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	kill "$MPLAYER_PID" 2>/dev/null >/dev/null
	exit 0
}

# shellcheck disable=SC2317
# trap function
cleanup_sigint() {
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	kill "$MPLAYER_PID" >/dev/null 2>/dev/null
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		if [ -e "$ALETHEIA/espeak.pid" ]; then
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			rm -f "$ALETHEIA/espeak.pid" >/dev/null 2>/dev/null
		fi
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	fi
	if [ "$WEB_CLIENT" == "1" ]; then
		kill "$NODE_PID" >/dev/null 2>/dev/null
	fi
	if [ -n "$tail_pid" ]; then
		kill "$tail_pid" >/dev/null 2>/dev/null
	fi
	if [ ! -e "$ALETHEIA/finished.tmp" ] && [ "$METADATA_FINISHED" == false ]; then
		touch "$ALETHEIA/cancel.tmp"
	else
		rm -f "$ALETHEIA/finished.tmp"
		rm -f "$ALETHEIA/cancel.tmp" >/dev/null 2>/dev/null
	fi
	if [ -e "$ALETHEIA/fade" ]; then
		rm -f "$ALETHEIA/fade"
	fi
	rm -f "$ALETHEIA"/useless{,_out}
	rm -f "$ALETHEIA/start$$"
	rm -f "$ALETHEIA/mplayer_output$$"
	rm -f "$ALETHEIA/mplayer_output_stderr$$"
	pkill -f "^tail -f.*useless" >/dev/null 2>/dev/null
	echo -ne "$NOCOLOR"
	clear
	tput cnorm
	stty ixon
	stty echo
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	exit 1
}

trap cleanup EXIT
trap cleanup_sigint SIGINT

update_metadata_db() {
	METADATA_FINISHED=false
	if [ "$USE_TAGS" == true ]; then
		if [ ! -e "$ALETHEIA/music.db" ]; then
			echo -n "" >"$ALETHEIA/filelist_unique.tmp"
			echo -n "" >"$ALETHEIA/cachelist_sorted.tmp"
		else
			sqlite3 "$ALETHEIA/music.db" "SELECT filename FROM music;" >"$ALETHEIA/cachelist.tmp"
			sort "$ALETHEIA/cachelist.tmp" >"$ALETHEIA/cachelist_sorted.tmp"
		fi

		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
		find "$MUSICDIR" -type f -regex "$regex" >"$ALETHEIA/filelist.tmp"
		rev <"$ALETHEIA/filelist.tmp" | cut -d'/' -f1 | rev | sort | uniq >"$ALETHEIA/filelist_sorted.tmp"

		diff -u "$ALETHEIA/filelist_sorted.tmp" "$ALETHEIA/cachelist_sorted.tmp" | grep -E '^-[^-]' | sed 's/^-//' >"$ALETHEIA/filelist_unique.tmp"
		if [ -n "$(cat "$ALETHEIA/filelist_unique.tmp")" ]; then #|| [ "$skip" == true ]; then
			cache_metadata "$ALETHEIA/filelist_unique.tmp"
		fi
		rm -f "$ALETHEIA/cachelist"{,_sorted,_unique}".tmp" "$ALETHEIA/filelist"{,_sorted,_unique}".tmp"
	fi
	METADATA_FINISHED=true
}

update_metadata_db

set_loop() {
	local force_enable=$1
	if [ "$LOOP" == false ] || [ "$force_enable" == true ]; then
		gtts_speak "loop song"
		LOOP=true
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
		draw_banner "$(get_local_phrase "LOOP SONG")"
	else
		gtts_speak "loop off"
		LOOP=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "$(get_local_phrase "RESET")"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_loop_artist() {
	local force_enable=$1
	if [ "$LOOP_ARTIST" == false ] || [ "$force_enable" == true ]; then
		if [ "$USE_TAGS" == true ]; then
			get_metadata "$POSITION" >/dev/null
			if [ "$artist" != "" ]; then
				LOOP_ARTIST_NAME="${artist,,}"
				LOOP=false
				LOOP_ARTIST=true
				TRACK_RANDOM=false
				ONLY_LOCKED=false
				gtts_speak "loop artist"
				draw_banner "$(get_local_phrase "LOOP ARTIST")"
			fi
		else
			if [[ "$TITLE" == *" - "* ]]; then
				LOOP=false
				LOOP_ARTIST=true
				TRACK_RANDOM=false
				ONLY_LOCKED=false
				LOOP_ARTIST_NAME="${TITLE%% - *}"
				LOOP_ARTIST_NAME="${LOOP_ARTIST_NAME,,}"
				gtts_speak "loop artist"
				draw_banner "$(get_local_phrase "LOOP ARTIST")"
			fi
		fi
	else
		gtts_speak "loop off"
		LOOP=false
		LOOP_ARTIST=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "$(get_local_phrase "RESET")"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_random() {
	if [ "$TRACK_RANDOM" == false ]; then
		gtts_speak "random mode"
		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=true
		ONLY_LOCKED=false
		draw_banner "$(get_local_phrase "RANDOM MODE")"
		reset_buffer
		redraw_buffer
	else
		gtts_speak "random mode off"
		TRACK_RANDOM=false
		draw_banner "$(get_local_phrase "RANDOM OFF")"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_only_locked() {
	if [ "$ONLY_LOCKED" == false ] || [ "$1" == true ]; then
		if [ "$3" != true ]; then
			gtts_speak "please wait"
		fi

		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		if [ "$5" != true ]; then
			ONLY_LOCKED=true
		fi
		if [ "$4" != true ]; then
			if [ "$PICK" == "" ]; then
				old_queue_array=("${queue_array[@]}")
				regex=".*\.\(${AUDIO_FORMATS//,/\.locked\\|})\.locked\)$"
				unset queue_array
				IFS=$'\n'
				index=0
				for i in $(find "$MUSICDIR" -type f -regex "$regex" | shuf); do
					if [ "$(echo -ne "$i" | grep '.repeat.')" == "" ]; then
						queue_array[index]="${i%.*}"
						index=$((index+1))
					fi
				done
				unset IFS
				if [ "$index" == "0" ]; then
					queue_array=("${old_queue_array[@]}")
					unset old_queue_array
					return 50
				else
					TOTAL_QUEUE=$index
				fi
					
			else
				unset queue_array
				c=$'\n'
				IFS=$'\n'
				index=0
				for i in $(printf '%s\n' "${queue_array[@]}"); do
					if [ -e "$i.locked" ]; then
						new_queue_array[index]="$i"
						index=$((index+1))
					fi
				done
				unset IFS
				queue_array=("${new_queue_array[@]}")
				TOTAL_QUEUE=$((index-1))
			fi
			if [ -e "$FILENAME.locked" ]; then
				new_list=""
				minusone=0
				IFS=$'\n'
				o_list="$FILENAME$IFS"
				for i in $(seq 1 $TOTAL_QUEUE); do
					if [ "$i" != "$POSITION" ]; then
						new_list="$new_list${queue_array[$((i-1-minusone))]}$IFS"
					else
						minusone=1
					fi
				done
				new_list="$(echo -ne "$new_list" | grep -v "$FILENAME" | shuf)"
				o_list="$o_list$new_list"
				index=0
				for i in $(echo -ne "$o_list"); do
					queue_array[index]="$i"
					index=$((index+1))
				done
				unset IFS
				POSITION=1
				ret=false
				flagp=true
			else
				JUMP=1
				ret=true
				flagp=false
			fi

			if [ "$flagp" == false ]; then
				POSITION=0
				tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1 | head -1)"
				if [ "$tmp" != "" ]; then
					POSITION="$tmp"
				fi
			fi
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			if [ "$5" != true ]; then
				draw_banner "$(get_local_phrase "ONLY LOCKED")"
			fi
			reset_buffer
			redraw_buffer
			if [ "$ret" == true ]; then
				return 200
			fi
		else
			return 200
		fi
	elif [ "$2" == true ]; then
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "$(get_local_phrase "RESET")"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	elif [ "$3" == true ]; then
		ONLY_LOCKED=false
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	else
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "$(get_local_phrase "RESET")"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

track_toggle() {
	if [ "$LOOP" == false ] && [ "$LOOP_ARTIST" == false ]; then
		set_loop true
	elif [ "$LOOP_ARTIST" == false ]; then
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		set_loop_artist true
	else
		gtts_speak "reset"
		LOOP=false
		LOOP_ARTIST=false
		draw_banner "$(get_local_phrase "RESET")"
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
	fi
}

about() {
	echo -ne "$NOCOLOR"
	draw_banner "$(get_local_phrase "ABOUT")"
	tput cup $LINES $((COLUMNS-${#PADDING}))
	echo -ne "$NOCOLOR${PADDING}"
	empty_pane
	lines_divided=$((LINES/2))
	cols_divided=$((COLUMNS/2))

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
		pad="_"
	else
		even=false
		pad=""
	fi
	if [ "$even" == true ]; then
		tput cup $((lines_divided-2)) $(((COLUMNS/2) - 4))
	else
		tput cup $((lines_divided-2)) $(((COLUMNS/2) - 3))
	fi
	echo -ne "${WHITE}aletheia${BLUE}_"
	tput sc

	tput cup $lines_divided $(((COLUMNS/2) - 7))
	if [ "$even" == true ]; then
		echo -ne "${WHITE}GPL${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2024"
		tput cup $((lines_divided+2)) $((cols_divided - 3))
	else
		echo -ne "${WHITE}GPL ${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2024"
		tput cup $((lines_divided+2)) $((cols_divided - 2))
	fi
	if [ "$even" == true ]; then
		echo -ne "${BLUE}v"
	fi
	echo -ne "$(echo -ne "$WHITE$VERSION" | sed "s/\./$(echo -ne "$BLUE").$(echo -ne "$WHITE")/g")"
	tput cup $((lines_divided-2)) $((cols_divided - 4))
}

set_scale_speed() {
	local reset=false
	tmp=""
	if [ "$SCALE_SPEED" != "$DEFAULT_SCALE_SPEED" ]; then
		reset=true
		draw_banner "$(get_local_phrase "RESET")"
		stty -echo
		sleep $BANNER_WAIT_TIME
		stty echo
		draw_pitch
		draw_position		
		tmp="$DEFAULT_SCALE_SPEED"
	else
		gtts_speak "set scale speed"
		draw_banner "$(get_local_phrase "SPEED")"
	fi

	if [ "$tmp" == "" ]; then
		tmp="$(read_line)"
	fi

	if [ "$(is_num "$tmp")" != "0" ]; then
		SCALE_SPEED=$tmp
		gtts_speak "scale speed set"
	else
		draw_pitch
		gtts_speak "closed" true
		return
	fi

	if [ "$reset" == true ]; then
		gtts_speak "speed reset"
	fi
	draw_pitch
}

less_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$EDO" -gt "$LOCKED_EDO" ]; do
		INTERVAL="$((INTERVAL/2))"
		EDO="$((EDO/2))"
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		sleep 0.01
	done
	echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	gtts_speak "less precise"
}

more_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		MUTE=false
		echo "mute" >"$ALETHEIA/pipe$$" &
	fi
	while [ "$EDO" -lt "$EDO_LIMIT" ]; do
		if [ "$INTERVAL" -lt "$EDO_LIMIT" ]; then
			INTERVAL="$((INTERVAL*2))"
			EDO="$((EDO*2))"
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			sleep 0.01
		else
			break
		fi
	done
	echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	gtts_speak "precise"
}

zero_interval_jump() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$INTERVAL" != "0" ]; then
		SAVED_INTERVAL="$INTERVAL"
		SAVED_EDO="$EDO"
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$SAVED_EDO"
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			INTERVAL="$SAVED_INTERVAL"
			EDO="$SAVED_EDO"
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		else
			return
		fi
	fi
	gtts_speak "$INTERVAL"
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	draw_pitch
}

draw_loop() {
	tput cup $LINES $((COLUMNS-RIGHT_BANNER_WIDTH-${#PADDING}))
	echo -ne "$BLUE_BLACK$START_MARKER$WHITE_BLACK:$BLUE_BLACK$END_MARKER$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
}

repeat() {
	echo -e "pausing_keep loop 0 1\nget_time_length" >"$ALETHEIA/pipe$$" &
	sleep $MPLAYER_WAIT_TIME
	TOTAL_TIME="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d '=' -f2)"
	if [ "$(is_num "$TOTAL_TIME")" == "0" ] || [ "$(echo -e "$TOTAL_TIME < 0.1" | bc)" == "1" ]; then
		TOTAL_TIME=0.1
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	if [ "$REPEAT_ONLY" == false ]; then
		gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
	fi
	if [ "$END_TIME" == "" ]; then
		if [ "$REPEATS" != "" ]; then
			repeats=$REPEATS
			if [ "$BACK" == true ]; then
				START_MARKER="$(echo -ne "$repeats" | tail -1 | cut -d '/' -f1)"
			else
				START_MARKER="$(echo -ne "$repeats" | head -1 | cut -d '/' -f1)"
			fi
			if [ "$(is_num "$START_MARKER")" == "0" ] || [ "$(echo -e "$START_MARKER < 0" | bc)" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "$(get_local_phrase "ERROR")"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_START_MARKER=$START_MARKER
			if [ "$START_MARKER" == "" ]; then
				START_MARKER=0.0
			fi
			if [ "$BACK" == true ]; then
				END_TIME="$(echo -ne "$repeats" | tail -1 | cut -d '/' -f2)"
			else
				END_TIME="$(echo -ne "$repeats" | head -1 | cut -d '/' -f2)"
			fi
			if [ "$(is_num "$END_TIME")" == "0" ] || [ "$(echo -e "$END_TIME < 0" | bc)" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "$(get_local_phrase "ERROR")"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_END_TIME=$END_TIME
			if [ "$END_TIME" == "" ]; then
				END_TIME=5.0
			fi
			if [ "$BACK" == true ]; then
				space="$(echo -ne "$repeats" | tail -1 | cut -d '/' -f3 | cut -d'.' -f1)"
			else
				space="$(echo -ne "$repeats" | head -1 | cut -d '/' -f3 | cut -d'.' -f1)"
			fi
			if [ "$BACK" == true ]; then
				BACK=false
			fi
			if [ "$(is_num "$space")" != "1" ]; then
				gtts_speak "loop file error"
				draw_banner "$(get_local_phrase "ERROR")"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_space=$space
			if [ "$space" == "" ]; then
				space=0
			fi
		else
			REPEAT_ONLY=false
			draw_banner "$(get_local_phrase "NO LOOPS")"
			gtts_speak "no loops"
			sleep $BANNER_WAIT_TIME
			draw_pitch
			draw_position
			if [ "$LOOP" == false ]; then
				echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			fi
			return 200
		fi
	fi
	if [ "$END_TIME" != "" ]; then
		END_MARKER=$END_TIME
		date_time=$(/usr/bin/time -p date +%s.%N 2>&1 | head -1)
		date_time=$(calc -pd "$date_time/1000000000000")
		timespent_timed=$(/usr/bin/time -p calc -pd "10 + (1687968170.908741168-1687968192.276557242) * (0.35) + ($date_time * 0.35)" 2>&1 | head -1)
		timespent_timed=$(calc -pd "$timespent_timed/1000000000000")
		old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
		s="$(calc -pd "1/(2^($INTERVAL/$EDO))")"
		orig_old_s=$old_s
		time="$(calc -pd "($END_TIME-$START_MARKER)*($s)")"
		input_char=""
		START_MARKER="$(printf '%.2f' "$START_MARKER")"
		END_MARKER="$(printf '%.2f' "$END_MARKER")"
		RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
		if [ "$REPEAT_TOTAL" == "0" ]; then
			draw_banner "$(get_local_phrase "LOOP") 0/$REPEAT_TOTAL"
		else
			draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
		fi
		draw_loop
		scale=false
		until [ "$input_char" == "q" ] || [ "$input_char" == "" ]; do
			if [ "$input_char" == "" ]; then
				timespent=0
				x=0
				if [ "$input_char" == "" ]; then
					if [ "$space" -gt "0" ]; then
						echo "pause" >"$ALETHEIA/pipe$$" &
						read -rsn1 -t "$(calc -pd "$space/20")" input_char
						echo "pause" >"$ALETHEIA/pipe$$" &
					fi
				fi
				if [ "$input_char" != "" ]; then
					continue
				fi
				echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
				time_before=$(date +%s.%N)
				if [ "$scale" == true ]; then
					num="$(echo -ne "$time" | cut -d'.' -f1)"
					skip=false
					while [ "$num" -gt "0" ]; do
						old_s="$(calc -pd "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
						if [ "$skip" == false ]; then
							if [ "$scale_down" == true ]; then
								INTERVAL=$((INTERVAL-1))
							elif [ "$scale_down" == false ]; then
								INTERVAL=$((INTERVAL+1))
							fi
						fi
						old_time_before=$time_before
						time_before=$(date +%s.%N)
						if [ "$skip" == false ]; then
							echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						else
							skip=false
						fi
						time_after=$(date +%s.%N)
						draw_pitch
						orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
						time_x=$(date +%s.%N)
						timespent="$(calc -pd "$timespent +($time_before-$old_time_before)*($old_s)+($time_x-$time_after)*($orig_old_s)+($date_time*2)*$old_s+($date_time*2)*$orig_old_s+$timespent_timed")"
						s=$orig_old_s
						old_s=$s
						s="$(calc -pd "1/$s")"

						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						numberz=$(calc -pd "($time-$timespent*$s)")
						if [ "$(echo "$numberz <= 0" | bc)" == "1" ]; then
							numberz=0
						fi
						if [ "$(echo -e "$numberz >= 0" | bc)" == "1" ]; then
							if [ "$numberz" == "0" ]; then
								input_char=""
								skip=true
							else
								if [ "$(echo "($numberz/$num) < 1" | bc)" == "1" ]; then
									skip=true
								fi
								time_y=$(date +%s.%N)
								timespent="$(calc -pd "$timespent + (($time_y-$time_x) * ($old_s)) + ($date_time * $old_s)")"
								if [ "$WEB_CLIENT" == "0" ]; then
									read -rsn1 -t "$(echo "$numberz/$num" | bc)" input_char
								else
									read -rsn1 -t "$(echo "$numberz/$num" | bc)" input_char <"$ALETHEIA/web_client_pipe$$"
								fi
								time_after=$(date +%s.%N)
							fi
						fi
						if [ "$input_char" != "" ]; then
							if [ "$input_char" == "q" ] || [ "$input_char" == "u" ] || [ "$input_char" == "" ]; then
								scale=false
								gtts_speak "scale closed"
								draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
								break
							elif [ "$input_char" == "c" ]; then
								if [ "$scale_down" == true ]; then
									scale_down=false
								else
									scale_down=true
								fi
								skip=true
							elif [ "$input_char" == "m" ]; then
								half_precise
								skip=true
							elif [ "$input_char" == "t" ]; then
								set_default_edo
								skip=true
							elif [ "$input_char" == "o" ]; then
								double_precise
								skip=true
							elif [ "$input_char" == "8" ]; then
								system_volume_change false 3 3
								skip=true
							elif [ "$input_char" == "9" ]; then
								system_volume_change true 3 3
								skip=true
							elif [ "$input_char" == "*" ]; then
								system_volume_change false 1 1
								skip=true
							elif [ "$input_char" == "(" ]; then
								system_volume_change true 1 1
								skip=true
							fi
						fi
						num=$((num-1))
					done
				else
					if [ "$(echo "$time <= 0" | bc)" == "1" ]; then
						time=0.01
						END_MARKER="$(echo "$START_MARKER+0.01" | bc)"
					fi
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$time" input_char
					else
						read -rsn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				time_after=$(date +%s.%N)
			fi
			if [ "$input_char" == "" ]; then
				continue
			fi
			if [ "$input_char" == "l" ] || [ "$input_char" == "h" ] || [ "$input_char" == "L" ] || [ "$input_char" == "H" ]; then
				case $input_char in
				'l')
					if [ "$(echo -e "($END_MARKER+0.05)<$TOTAL_TIME" | bc)" == "1" ]; then
						END_MARKER=$(calc -pd "$END_MARKER+0.05")
					else
						END_MARKER=$TOTAL_TIME
					fi
					;;
				'h')
					if [ "$(echo -e "(($END_MARKER-0.05) > $START_MARKER)" | bc)" == "1" ]; then
						END_MARKER=$(calc -pd "$END_MARKER-0.05")
					fi
					;;
				'L')
					if [ "$(echo -e "($END_MARKER < $TOTAL_TIME-0.05)" | bc)" == "1" ]; then
						END_MARKER=$(calc -pd "$END_MARKER+0.01")
					fi
					;;
				'H')
					if [ "$(echo -e "($END_MARKER > $START_MARKER+0.05)" | bc)" == "1" ]; then
						END_MARKER=$(calc -pd "$END_MARKER-0.01")
					fi
					;;
				esac

				time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")

				START_MARKER="$(printf '%.2f' "$START_MARKER")"
				END_MARKER="$(printf '%.2f' "$END_MARKER")"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop

				if [ "$(echo -e "$(calc -pd "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$time" input_char
					else
						read -rsn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc -pd "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$(calc -pd "1.5*$s")" input_char
					else
						read -rsn1 -t "$(calc -pd "1.5*$s")" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "s" ] || [ "$input_char" == "g" ] || [ "$input_char" == "S" ] || [ "$input_char" == "G" ]; then
				case $input_char in
				's')
					if [ "$(echo -e "(($START_MARKER-0.05) >= 0.0)" | bc)" == "1" ]; then
						START_MARKER=$(calc -pd "$START_MARKER-0.05")
					fi
					;;
				'g')
					if [ "$(echo -e "(($START_MARKER+0.05) < $END_MARKER)" | bc)" == "1" ]; then
						START_MARKER=$(calc -pd "$START_MARKER+0.05")
					fi
					;;
				'S')
					if [ "$(echo -e "(($START_MARKER-0.01) >= 0.0)" | bc)" == "1" ]; then
						START_MARKER=$(calc -pd "$START_MARKER-0.01")
					fi
					;;
				'G')
					if [ "$(echo -e "(($START_MARKER+0.01) <= ($END_MARKER-0.05))" | bc)" == "1" ]; then
						START_MARKER=$(calc -pd "$START_MARKER+0.01")
					fi
					;;
				esac
				truth="$(echo "$START_MARKER < 0.0" | bc)"
				if [ "$truth" == "1" ]; then
					START_MARKER="0.0"
				fi
				time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
				START_MARKER="$(printf '%.2f' "$START_MARKER")"
				END_MARKER="$(printf '%.2f' "$END_MARKER")"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "c" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$LEFT" == true ]; then
					draw_pitch
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				else
					RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_loop
				fi
				flagged=true
			elif [ "$input_char" == "d" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				toggle_voice
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "" ] || [ "$input_char" == "\\" ]; then
				input_char=""
				flagged=false
			elif [ "$input_char" == "u" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				gtts_speak "scale"
				draw_banner "$(get_local_phrase "SCALE")"
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$scale" == true ]; then
					scale=false
					if [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					fi
				else
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 inputchar
					else
						read -rsn1 inputchar <"$ALETHEIA/web_client_pipe$$"
					fi
					if [ "$inputchar" == "j" ]; then
						scale_down=true
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "k" ]; then
						scale_down=false
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					elif [ "$inputchar" == $'\e' ]; then
						read -rn2 -t 0.03 key
						case $key in
						'[B')
							scale_down=true
							scale=true
							input_char=""
							gtts_speak "scaling"
							draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
							flagged=false
							;;
						'[A')
							scale_down=false
							scale=true
							input_char=""
							gtts_speak "scaling"
							draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
							flagged=false
							;;
						*)
							gtts_speak "scale closed"
							draw_pitch
							draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
							flagged=true
							;;
						esac
					fi
				fi
			elif [ "$input_char" == "q" ]; then
				draw_pitch
				draw_position
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "a" ]; then
				toggle_pause
				set_equalizer
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "T" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				set_only_display_song
				redraw_buffer
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				load_loop_file
				if [ "$?" != "1" ]; then
					draw_pitch
					draw_position
					REPEAT_ONLY=false
					return 200
				fi
				flagged=true
			elif [ "$input_char" == "Z" ]; then
				toggle_pause true
				gtts_speak "export loop"
				draw_banner "$(get_local_phrase "EXPORT")" false false true
				tput rc
				read -rn1 number_repeats
				if [ -n "$number_repeats" ]; then
					number_repeats="$(read_line "$number_repeats" true)"
				else
					number_repeats=0
				fi
				if [ "$(is_num "$number_repeats")" != "1" ]; then
					toggle_pause true
					old_time_before=$time_before
					time_before=$(date +%s.%N)
					gtts_speak_chain "export closed" "loop mode" &
				else
					draw_banner "$(get_local_phrase "WAIT")" false false true
					gtts_speak "wait"
					ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
					filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
					rm -f "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
					rm -f "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
					local delay=0
					if [ "$space" != "0" ]; then
						delay="$(calc -pd "($space/20)")"
					fi
					ffmpeg -i "$FILENAME" -ss "$START_MARKER" -t "$(calc -pd "$END_MARKER-$START_MARKER")" -c copy "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
					if [ "$(is_num "$number_repeats")" == "1" ] && [ "${number_repeats:0:1}" != "-" ]; then
						sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat1.$ext" pad 0 "$delay" repeat "$number_repeats" speed "$(calc -pd "2^($INTERVAL/$EDO)")" >/dev/null 2>/dev/null
					else
						sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat1.$ext" pad 0 "$delay" speed "$(calc -pd "2^($INTERVAL/$EDO)")" >/dev/null 2>/dev/null
					fi
					mv "$filename_without_ext.repeat1.$ext" "$filename_without_ext.repeat.$ext"
					rm -f "$filename_without_ext.repeat0.$ext"
					toggle_pause true
					old_time_before=$time_before
					time_before=$(date +%s.%N)
					gtts_speak "finished"
					if [ -e "$filename_without_ext.repeat.$ext" ]; then
						REP="$BLUE_BLACK"
					else
						REP=""
					fi
					if [ "$NO_VERTICAL_PADDING" == true ]; then
						tput cup $((LOCKING_POS+1)) 1
					else
						tput cup $((LOCKING_POS+2)) 1
					fi
					if [ -e "$FILENAME.locked" ]; then
						if [ -e "$FILENAME.repeats" ]; then
							echo -ne "${WHITE_BLACK}${REP}#"
						else
							echo -ne "$BLUE_BLACK${REP}$"
						fi
					else
						if [ -e "$FILENAME.repeats" ]; then
							echo -ne "${WHITE_BLACK}${REP}&"
						else
							echo -ne "${WHITE_BLACK} "
						fi
					fi
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "A" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				sort_queue
				SHUFFLED=false
				flagged=true
			elif [ "$input_char" == "R" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				shuffle_queue
				SHUFFLED=true
				flagged=true
			elif [ "$input_char" == "I" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				read_corner
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "Y" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				zero_interval_jump
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				input_char=""
				flagged=true
				switch=true
			elif [ "$input_char" == "w" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				reset_to_locked
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
				switch=true
			elif [ "$input_char" == "q" ] || [ "$input_char" == "" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				draw_pitch
				draw_position
				REPEAT_ONLY=false
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				return 200
			elif [ "$input_char" == "W" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				add_downloaded "noposition"
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					gtts_speak "playing downloaded"
					JUMP="$DOWNLOAD_POSITION"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
				fi
				flagged=true
			elif [ "$input_char" == "?" ]; then
				toggle_pause true
				RIGHT_BANNER_WIDTH="$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))"
				draw_banner "$(get_local_phrase "HELP")" false false true
				tput cup $LINES $((COLUMNS-12))
				echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
				loop_help_screen
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				toggle_pause true
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				redraw_buffer
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "i" ]; then
				toggle_pause true
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				toggle_pause true
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "M" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				INTERVAL="$((-(INTERVAL)))"
				echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				draw_pitch
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				switch=true
				flagged=true
			elif [ "$input_char" == "v" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				toggle_scale_tempo
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "z" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_wait false
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				reset_dimensions
				draw_volume
				draw_equalizer
				reset_buffer
				redraw_buffer
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "<" ]; then
				if [ "$space" -gt "0" ]; then
					space=$((space-1))
				fi
				gtts_speak "$space"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "$(echo -e "$(calc -pd "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc -pd "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char
					else
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "." ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				set_custom_int true
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				switch=true
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "/" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				set_custom_edo true
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				switch=true
				flagged=true
			elif [ "$input_char" == "," ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				gtts_speak "$TITLE" >/dev/null 2>/dev/null
				flagged=true
			elif [ "$input_char" == ">" ]; then
				space=$((space+1))
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				gtts_speak "$space"
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "$(echo -e "$(calc -pd "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc -pd "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char
					else
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "k" ] || [ "$input_char" == "j" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				if [ "$input_char" == "k" ]; then
					pitch_up true
				else
					pitch_down true
				fi
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				switch=true
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "2" ] || [ "$input_char" == "1" ] || [ "$input_char" == "!" ] || [ "$input_char" == "@" ] || [ "$input_char" == "9" ] || [ "$input_char" == "8" ] || [ "$input_char" == "*" ] || [ "$input_char" == "(" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$input_char" == "2" ]; then
					if [ "$VOLUME" -le "95" ]; then
						VOLUME=$((VOLUME+5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "1" ]; then
					if [ "$VOLUME" -ge "5" ]; then
						VOLUME=$((VOLUME-5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "@" ]; then
					if [ "$VOLUME" -le "99" ]; then
						VOLUME=$((VOLUME+1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "!" ]; then
					if [ "$VOLUME" -ge "1" ]; then
						VOLUME=$((VOLUME-1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "8" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change false 3 3
				elif [ "$input_char" == "9" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change true 3 3
				elif [ "$input_char" == "*" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change false 1 1
				elif [ "$input_char" == "(" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change true 1 1
				fi
				flagged=true
			elif [ "$input_char" == "6" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" == "1" ]; then
					flagged=true
					gtts_speak "no more loops"
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$((REPEAT_CURRENT+1))
						if [ "$REPEAT_CURRENT" -gt "$REPEAT_TOTAL" ]; then
							REPEAT_CURRENT=1
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="$(printf '%.2f' "$START_MARKER")"
						END_MARKER="$(printf '%.2f' "$END_MARKER")"
						
						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					else
						gtts_speak "none"
						START_MARKER=0.00
						END_MARKER=5.00
						END_TIME=$END_MARKER
						space=0
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "$(get_local_phrase "LOOP") 0/$REPEAT_TOTAL"
					else
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "^" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" == "1" ]; then
					flagged=true
					gtts_speak "no more loops"
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$((REPEAT_CURRENT-1))
						if [ "$REPEAT_CURRENT" -lt "1" ]; then
							REPEAT_CURRENT=$REPEAT_TOTAL
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="$(printf '%.2f' "$START_MARKER")"
						END_MARKER="$(printf '%.2f' "$END_MARKER")"

						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					else
						gtts_speak "none"
						START_MARKER=0.00
						END_MARKER=5.00
						END_TIME=$END_MARKER
						space=0
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "$(get_local_phrase "LOOP") 0/$REPEAT_TOTAL"
					else
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "e" ]; then
				if [ "$(echo -e "$(calc -pd "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc -pd "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char
					else
						read -rn1 -t "$(calc -pd "1.5*$s")" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "" ]; then
				load_loop_file
				break
			elif [ "$input_char" == "q" ]; then
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "5" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="$(printf "%.2f" "$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d'=' -f2)")"
				time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "7" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_MARKER="$(printf "%.2f" "$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d'=' -f2)")"
				time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "n" ] || [ "$input_char" == "N" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" == "1" ] || [ "$REPEAT_TOTAL" == "0" ] || [ "$input_char" == "N" ] || [ "$REPEAT_ONLY" == false ]; then
					RIGHT_BANNER_WIDTH=0
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						return $RETURN_NEXT
					fi
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$((REPEAT_CURRENT+1))
						if [ "$REPEAT_CURRENT" -gt "$REPEAT_TOTAL" ]; then
							RIGHT_BANNER_WIDTH=0
							kill "$MPLAYER_PID" >/dev/null 2>/dev/null
							if [ "$TRACK_RANDOM" == true ]; then
								return $RETURN_TRACK_RANDOM
							elif [ "$LOOP_ARTIST" == true ]; then
								return $RETURN_LOOP_ARTIST
							else
								return $RETURN_NEXT
							fi
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="$(printf '%.2f' "$START_MARKER")"
						END_MARKER="$(printf '%.2f' "$END_MARKER")"

						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "$(get_local_phrase "LOOP") 0/$REPEAT_TOTAL"
					else
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				gtts_speak " $INTERVAL" false false true
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_ONLY" == false ]; then
					text="LOOP MODE"
					REPEAT_ONLY=true
					RIGHT_BANNER_WIDTH="${#text}"
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_banner "$text" false true
					gtts_speak "loop mode"
					sleep $BANNER_WAIT_TIME
					RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_loop
				else
					text="$(get_local_phrase "OFF")"
					REPEAT_ONLY=false
					RIGHT_BANNER_WIDTH="${#text}"
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_banner "$text" false true
					gtts_speak "loop mode off"
					sleep $BANNER_WAIT_TIME
					RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_loop
				fi
				flagged=true
			elif [ "$input_char" == "b" ] || [ "$input_char" == "B" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" == "1" ] || [ "$REPEAT_TOTAL" == "0" ] || [ "$input_char" == "B" ] || [ "$REPEAT_ONLY" == false ]; then
					RIGHT_BANNER_WIDTH=0
					if [ "$input_char" == "B" ]; then
						BACK=false
					else
						BACK=true
					fi
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$REPEAT_ONLY" == true ]; then
						return $RETURN_ONLY_LOCKED_BACK
					else
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM_BACK
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST_BACK
						elif [ "$ONLY_LOCKED" == true ]; then
							return $RETURN_ONLY_LOCKED_BACK
						else
							return $RETURN_BACK
						fi
					fi
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$((REPEAT_CURRENT-1))
						BACK=true
						if [ "$REPEAT_CURRENT" == "0" ]; then
							RIGHT_BANNER_WIDTH=0
							kill "$MPLAYER_PID" >/dev/null 2>/dev/null
							if [ "$REPEAT_ONLY" == true ]; then
								return $RETURN_ONLY_LOCKED_BACK
							else
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM_BACK
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST_BACK
								elif [ "$ONLY_LOCKED" == true ]; then
									return $RETURN_ONLY_LOCKED_BACK
								else
									return $RETURN_BACK
								fi
							fi
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="$(printf '%.2f' "$START_MARKER")"
						END_MARKER="$(printf '%.2f' "$END_MARKER")"

						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "$(get_local_phrase "LOOP") 0/$REPEAT_TOTAL"
					else
						draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "y" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				set_default_edo
				time_x=$(date +%s.%N)
				LOCKED=false
				flagged=true
			elif [ "$input_char" == "p" ]; then
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				toggle_pause
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 input_char
				else
					read -rn1 input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				toggle_pause
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				time_x=$(date +%s.%N)
				flagged=true
			elif [ "$input_char" == "o" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				flagged=true
			elif [ "$input_char" == "m" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				flagged=true
			elif [ "$input_char" == "x" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				RIGHT_BANNER_WIDTH=$((${#REPEAT_CURRENT}+${#REPEAT_TOTAL}+12))
				lock
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "X" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				RIGHT_BANNER_WIDTH=$((${#REPEAT_CURRENT}+${#REPEAT_TOTAL}+12))
				unlock
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "f" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				RIGHT_BANNER_WIDTH=$((${#REPEAT_CURRENT}+${#REPEAT_TOTAL}+12))
				swap_lock true
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				switch=true
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "F" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				RIGHT_BANNER_WIDTH=$((${#REPEAT_CURRENT}+${#REPEAT_TOTAL}+12))
				swap_lock
				orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
				switch=true
				draw_pitch
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "%" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" -ge "1" ]; then
					gtts_speak "unlocked $REPEAT_CURRENT"
					draw_banner "$(get_local_phrase "UNLOCKED") $REPEAT_CURRENT"
					draw_loop
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t $BANNER_WAIT_TIME t
					else
						read -rn1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
					fi
					input_char="$t"
					if [ "$REPEAT_TOTAL" == "1" ]; then
						rm -f "$FILENAME.repeats"
						REPEATS=""
						REPEAT_CURRENT=0
						REPEAT_TOTAL=0
					else
						sed -i "${REPEAT_CURRENT}d" "$FILENAME.repeats"
						REPEATS="$(echo -ne "$REPEATS" | sed "${REPEAT_CURRENT}d")"
						REPEAT_TOTAL=$((REPEAT_TOTAL-1))
						REPEAT_CURRENT=$((REPEAT_CURRENT-1))
					fi

					if [ "$REPEAT_TOTAL" == "0" ]; then
						if [ "$NO_VERTICAL_PADDING" == true ]; then
							tput cup $((LOCKING_POS+1)) 1
						else
							tput cup $((LOCKING_POS+2)) 1
						fi
						if [ -e "$FILENAME.locked" ]; then
							echo -ne "${WHITE}$"
						else
							echo -ne "${BLUE} "
						fi
					fi
					if [ "$REPEATS" != "" ]; then
						if [ "$REPEAT_CURRENT" == "0" ]; then
							REPEAT_CURRENT=1
						fi
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						END_TIME=$END_MARKER
						time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
					fi
				else
					gtts_speak "no repeats"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEATS" != "" ]; then
					REPEATS="$(echo -ne "$REPEATS" | sed -e "s/$orig_START_MARKER\/$orig_END_TIME\/$orig_space/$START_MARKER\/$END_MARKER\/$space/g")"
					echo -ne "$REPEATS" >"$FILENAME.repeats"
					gtts_speak "saved loop"
				else
					gtts_speak "no loops"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "SAVED")" false false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 -t $BANNER_WAIT_TIME input_char
				else
					read -rn1 -t $BANNER_WAIT_TIME input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "&" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEATS" != "" ]; then
					echo -ne "$REPEATS\n$START_MARKER/$END_MARKER/$space" >"$FILENAME.repeats"
					REPEATS="$REPEATS\n$START_MARKER/$END_MARKER/$space"
					REPEAT_CURRENT=$((REPEAT_CURRENT+1))
					REPEAT_TOTAL=$((REPEAT_TOTAL+1))
					gtts_speak "locked $REPEAT_TOTAL"
					if [ "$NO_VERTICAL_PADDING" == true ]; then
						tput cup $((LOCKING_POS+1)) 1
					else
						tput cup $((LOCKING_POS+2)) 1
					fi
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
				else
					REPEATS="$START_MARKER/$END_MARKER/$space$(echo -ne "\n")"
					echo -ne "$START_MARKER/$END_MARKER/$space" >"$FILENAME.repeats"
					gtts_speak "locked"
					if [ "$NO_VERTICAL_PADDING" == true ]; then
						tput cup $((LOCKING_POS+1)) 1
					else
						tput cup $((LOCKING_POS+2)) 1
					fi
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
					REPEAT_CURRENT=1
					REPEAT_TOTAL=$((REPEAT_TOTAL+1))
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "$(get_local_phrase "LOCKED") $REPEAT_TOTAL"
				draw_loop
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 -t $BANNER_WAIT_TIME t
				else
					read -rn1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				input_char="$t"
				flagged=true
			elif [ "$input_char" == $'\e' ]; then
				read -rn2 -t 0.03 key
				case $key in
				'[B')
					old_time_before=$time_before
					time_before=$(date +%s.%N)
					orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
					pitch_down true
					orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
					switch=true
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
					flagged=true
					;;
				'[A')
					old_time_before=$time_before
					time_before=$(date +%s.%N)
					orig_orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
					pitch_up true
					orig_old_s="$(calc -pd "(2^($INTERVAL/$EDO))")"
					switch=true
					draw_banner "$(get_local_phrase "LOOP") $REPEAT_CURRENT/$REPEAT_TOTAL" false true
					flagged=true
					;;
				*)
					if [ "$LOOP" == false ]; then
						echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
					fi
					break
					;;
				esac
			else
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				process_key "$input_char"
				flagged=true
			fi
			if [ "$flagged" == true ]; then
				time_x=$(date +%s.%N)
				flagged=false
				if [ "$switch" == true ]; then
					switch=false
					timespent="$(calc -pd "$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*3)*$orig_old_s+($date_time*1)*$orig_orig_old_s")"
				else
					timespent="$(calc -pd "$timespent +($time_after-$old_time_before)*($orig_old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*4)*$orig_old_s")"
				fi
				s=$orig_old_s
				old_s=$s
				s="$(calc -pd "1/$s")"

				time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
				input_char=""
				numberz=$(calc -pd "($time-$timespent*$s)")
				if [ "$(echo "$numberz <= 0" | bc)" == "1" ]; then
					numberz=0
				fi
				if [ "$(echo -e "$numberz >= 0" | bc)" == "1" ]; then
					if [ "$numberz" == "0" ]; then
						input_char=""
					else
						time_y=$(date +%s.%N)
						time_before=$time_y
						timespent="$(calc -pd "$timespent +(($time_y-$time_x)*($old_s))")"
						if [ "$WEB_CLIENT" == "0" ]; then
							read -rn1 -t "$numberz" input_char
						else
							read -rn1 -t "$numberz" input_char <"$ALETHEIA/web_client_pipe$$"
						fi
						time_after=$(date +%s.%N)
					fi
				fi
			fi

		done
		scale=false
		REPEAT_ONLY=false
		if [ ! -e "$FILENAME.locked" ]; then
			gtts_speak "loop closed"
		fi

		END_TIME="$END_MARKER"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		if [ "$LOOP" == false ]; then
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		fi
		return 200
	fi
}

zero_interval() {
	reverse=false
	zero=false
	if [ "$INTERVAL" != "0" ]; then
		draw_banner "$(get_local_phrase "ZERO")" false true
		zero=true
		SAVED_INTERVAL=$INTERVAL
		SAVED_EDO=$EDO
		gtts_speak "scaling to original pitch"
		old_int="$INTERVAL"
		old_edo="$EDO"
		new_INTERVAL="$DEFAULT_INTERVAL"
		new_EDO="$EDO"
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			draw_banner "$(get_local_phrase "RESET")" false true
			gtts_speak "scaling back"
			old_int="0"
			old_edo="$EDO"
			new_INTERVAL="$SAVED_INTERVAL"
			new_EDO="$SAVED_EDO"
			reverse=true
		else
			old_int="0"
			new_INTERVAL="$DEFAULT_INTERVAL"
			new_EDO="$EDO"
		fi
	fi
	
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi

	if [ "$old_int" -gt "$new_INTERVAL" ]; then
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -lt "$old_int" ]; do
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "$(get_local_phrase "ZERO")" true
			if [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "$(get_local_phrase "ZERO")" false true
				else
					draw_banner "$(get_local_phrase "RESET")" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
				if [ "$zero" == true ]; then
					draw_banner "$(get_local_phrase "ZERO")" false true
				else
					draw_banner "$(get_local_phrase "RESET")" false true
				fi
			elif [ "$c" == "q" ]; then
				draw_banner "$(get_local_phrase "QUIT")" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "quit"
				fi
				read -rn1 input_char
				if [ "$input_char" == "y" ]; then
					echo -ne "$NOCOLOR"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					clear
					stty echo
					return $RETURN_QUIT
				elif [ "$input_char" == "q" ]; then
					flaggy=true
					draw_pitch
					break
				fi
			elif [ "$c" == $'\e' ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$((old_int-1))"
				INTERVAL="$((INTERVAL-1))"
				echo -e "speed_set $(calc -pd "2^($old_int/$old_edo)")" >"$ALETHEIA/pipe$$" &
			fi
			draw_pitch 1
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	else
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -gt "$old_int" ]; do
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "$(get_local_phrase "ZERO")" true
			if [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "$(get_local_phrase "ZERO")" false true
				else
					draw_banner "$(get_local_phrase "RESET")" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "q" ] || [ "$c" == $'\e' ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$((old_int+1))"
				INTERVAL="$((INTERVAL+1))"
				echo -e "speed_set $(calc -pd "2^($old_int/$old_edo)")" >"$ALETHEIA/pipe$$" &
				draw_pitch 1
			fi
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	fi
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	LOCKED=false
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

scale_edo() {
	gtts_speak "scale e d o"
	draw_banner "$(get_local_phrase "SCALE")"
	stopat=""
	read -rsn1 edo_change
	if [ "$edo_change" == "J" ]; then
		if [ "$EDO" -le "2" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=true
		time=2.5
		edo_change="$((EDO-1))"
	elif [ "$edo_change" == "K" ]; then
		if [ "$EDO" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=false
		time=2.5
		edo_change="$((EDO+1))"
	elif [ "$edo_change" == "j" ]; then
		gtts_speak "scaling"
		downwards=true
		time=$SCALE_SPEED
		edo_change="$((EDO-1))"
	elif [ "$edo_change" == "k" ]; then
		gtts_speak "scaling"
		downwards=false
		time=$SCALE_SPEED
		edo_change="$((EDO+1))"
	elif [ "$edo_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == $'\e' ] || [ "$edo_change" == "q" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "?" ]; then
		scale_help_screen
		draw_pitch
		draw_position
		return
	elif [ "$(is_num "$edo_change")" != "0" ] || [ "$edo_change" == "-" ]; then
		draw_position
		draw_banner "$(get_local_phrase "SCALE")"
		if [ "$edo_change" != "-" ]; then
			tmp="$(read_line "$edo_change")"
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi

		if [ "$(is_num "$tmp")" != "1" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi

		if [ "$tmp" -lt "$EDO" ]; then
			if [ "$tmp" -le "0" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=true
			time=$SCALE_SPEED
			edo_change="$((EDO-1))"
		elif [ "$tmp" -gt "$EDO" ]; then
			if [ "$tmp" -ge "2000000" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=false
			time=$SCALE_SPEED
			edo_change="$((EDO+1))"
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$edo_change" != "" ]; then
		draw_banner "$(get_local_phrase "SCALE")" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		original_edo="$EDO"
		c=""
		flaggy=false
		orig_edo=$EDO
		orig_interval=$INTERVAL
		while [ "$edo_change" != "$original_edo" ]; do
			if [ "$downwards" == true ]; then
				draw_pitch 2
				read -rsn1 -t "$time" c
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "$(get_local_phrase "SCALE")"
				if [ "$c" == $'\e' ] || [ "$c" == "u" ] || [ "$c" == "q" ]; then
					break
				elif [ "$c" == "c" ]; then
					downwards=false
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					edo_change="2000000"
					flaggy=false
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "$(get_local_phrase "SCALE")" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "$(get_local_phrase "SCALE")" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					original_edo="$EDO"
					EDO="$((EDO-1))"
					edo_change="$((edo_change-1))"
					INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
					INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
					if [ "$flaggy" == false ]; then
						temp="$(calc -pd "$orig_edo/$EDO")"
						INTERVAL="$(calc -pd " $orig_interval/$temp")"
						INTERVAL="${INTERVAL%%.*}"
					fi
					if [ "$EDO" == "1" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "1" ]; then
					break
				fi

			elif [ "$downwards" == false ]; then
				draw_pitch 2
				read -rsn1 -t "$time" c
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "$(get_local_phrase "SCALE")"
				if [ "$c" == $'\e' ] || [ "$c" == "q" ] || [ "$c" == "u" ]; then
					break
				elif [ "$c" == "c" ]; then
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					original_edo="$EDO"
					flaggy=false
					downwards=true
					edo_change="1"
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "$(get_local_phrase "SCALE")" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "$(get_local_phrase "SCALE")" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					original_edo=$EDO
					EDO="$((EDO+1))"
					edo_change=$((edo_change+1))

					INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
					INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")

					if [ "$flaggy" == false ]; then
						temp="$(calc -pd "$EDO/$orig_edo")"
						INTERVAL="$(echo "$orig_interval*$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
					fi

					if [ "$INTERVAL" == "0" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch 2
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "0" ]; then
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

draw_menu() {
	local longest=0
	if [ "$3" == true ]; then
		local OPT=( "" "${tmp_OPT[@]}" )
		local TOTAL_OPTS=$tmp_TOTAL_OPTS
	fi
	if [ "$6" == true ]; then
		for l in "${OPT_FULL[@]}"; do
			if [ "${#l}" -gt "$longest" ]; then
				longest=${#l}
			fi
		done
	else
		for l in "${OPT[@]}"; do
			if [ "${#l}" -gt "$longest" ]; then
				longest=${#l}
			fi
		done
	fi

	add="$(tput el)"
	if [ -n "$2" ] && [ "$3" != true ]; then
		add="$(tput cuf $((${#PADDING}+8)))"
	fi

	if [ "$1" == true ]; then
		q=$(printf '%*s' $((longest+4)) "" | tr ' ' 'q')
	else
		q=$(printf '%*s' $((longest+3)) "" | tr ' ' 'q')
	fi
	if [ -n "$2" ]; then
		if [ "$_offset" == "0" ]; then
			TOP_BAR_MENU="${LINE_CHAR}w${q}k$LINE_CHAR_END"
			BOTTOM_BAR_MENU="${LINE_CHAR}u${q}j$LINE_CHAR_END"
		else
			TOP_BAR_MENU="${LINE_CHAR}t${q}k$LINE_CHAR_END"
			BOTTOM_BAR_MENU="${LINE_CHAR}v${q}j$LINE_CHAR_END"
		fi
	else
		TOP_BAR_MENU="${LINE_CHAR}l${q}k$LINE_CHAR_END"
		BOTTOM_BAR_MENU="${LINE_CHAR}m${q}j$LINE_CHAR_END"
	fi
	if [ -n "$4" ] && [ -n "$5" ]; then
		TOP_BAR_MENU="${LINE_CHAR}$4${q}k$LINE_CHAR_END"
		BOTTOM_BAR_MENU="${LINE_CHAR}$5${q}j$LINE_CHAR_END"
	fi

	q=$(printf '%*s' $((longest+2)) "" | tr ' ' 'q')
	BAR="${LINE_CHAR}x${LINE_CHAR_END}"
	menu_buf="$NOCOLOR$PADDING$add$COLOR_ACCENT$TOP_BAR_MENU$(tput el)"

	for i in $(seq 1 "$TOTAL_OPTS"); do
		pad="  "
		if [ "$6" == true ]; then
			temp="${#OPT_FULL[$i]}"
		else
			temp="${#OPT[$i]}"
		fi
		while [ "$temp" -le "$pad_" ]; do
			pad="$pad "
			temp="$((temp+1))"
		done
		if [ -z "$6" ]; then
			if [ "${OPT[$i]}" == "$_Music" ] || [ "${OPT[$i]}" == "$_Edit" ] || [ "${OPT[$i]}" == "$_Theme" ] || [ "${OPT[$i]}" == "$_Language" ]; then
				arrow=" "
			else
				arrow="  "
			fi
		else
			arrow="  "
		fi
		if [ "$6" == true ]; then
			if [ "${#OPT_FULL[$i]}" -lt "$longest" ]; then
				pad2=$(printf '%*s' "$((longest-${#OPT_FULL[$i]}))" "")
			else
				pad2=""
			fi
		else
			if [ "${#OPT[$i]}" -lt "$longest" ]; then
				pad2=$(printf '%*s' "$((longest-${#OPT[$i]}))" "")
			else
				pad2=""
			fi
		fi
		if [ "$i" == "$SELECTION" ]; then
			pad=""
			if [ "$6" == true ]; then
				_opt="${OPT_FULL[$i]}"
			else
				_opt="${OPT[$i]}"
			fi
			menu_buf="$menu_buf\n$PADDING$COLOR_ACCENT$add$BAR$BLUE_BLACK $_opt$pad2$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR$(tput el)"
			if [ "$tagged" == false ] || [ "$tagged" == "" ]; then
				if [ "$nospeak" == false ]; then
					if [ "$menu_start_over" == true ]; then
						if [ "$SKIP_SPEAK_MENU" != true ]; then
							if [ "${OPT[i]}" == "Setup" ]; then
								opt="settings"
							else
								if [ "$6" == true ]; then
									opt="${OPT_FULL[i]}"
								else
									opt="${OPT[i]}"
								fi
							fi
							gtts_speak "$opt" "" "" "" "" true
						fi
						menu_start_over=false
					else
						if [ "$NO_QUEUE_FLAG" == false ]; then
							if [ "$SKIP_SPEAK_MENU" != true ]; then
								if [ "${OPT[i]}" == "Setup" ]; then
									opt="settings"
								else
									if [ "$6" == true ]; then
										opt="${OPT_FULL[i]}"
									else
										opt="${OPT[i]}"
									fi
								fi
								gtts_speak "$opt" "" "" "" "" true
							fi
						else
							NO_QUEUE_FLAG=false
						fi
					fi
				fi
			fi
		else
			pad=""
			if [ "$6" == true ]; then
				_opt="${OPT_FULL[$i]}"
			else
				_opt="${OPT[$i]}"
			fi
			menu_buf="$menu_buf\n$PADDING$add$COLOR_ACCENT$BAR$WHITE $_opt$pad2$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR$(tput el)"
		fi
	done

	if [ -n "$2" ]; then
		menu_buf="$menu_buf\n$PADDING$COLOR_ACCENT$add$BOTTOM_BAR_MENU$(tput el)"
	else
		menu_buf="$menu_buf\n$PADDING$(tput el)$COLOR_ACCENT$add$BOTTOM_BAR_MENU$(tput el)"
	fi
	local top=$2
	if [ -z "$top" ]; then
		top=$((LINES-1-(${#OPT[@]}+2)))
		if [ "$top" -lt "1" ]; then
			top=1
		fi
	fi

	echo -ne "$NOCOLOR"
	if [ "$TOTAL_OPTS" -lt "$((LINES-4))" ]; then
		echo -ne "$NOCOLOR"
		if [ -z "$2" ] || [ -n "$3" ]; then
			empty_pane 1 $((top-1))
		fi
	fi
	if [ -z "$2" ]; then
		tput cup "$top" 0
	else
		if [ "$TOTAL_OPTS" -gt "$((LINES-4))" ]; then
			tput cup 1 0
		else
			tput cup "$((top-_offset-1))" 0
		fi
	fi
	if [ "$((${#OPT[@]}+2))" -gt "$((LINES-2))" ]; then
		echo -ne "$menu_buf" | sed -n "$((1+_offset)),$((LINES-2+_offset))p"
	else
		if [ -n "$2" ]; then
			printf '%b' "$menu_buf" | sed -n "$((1+_offset)),$((LINES-$2+_offset))p"
		else
			printf '%b' "$menu_buf"
		fi
	fi
}

lang_submenu() {
	local initial_screen=$1
	local z=""
	local old_LINES=$LINES
	local old_COLUMNS=$COLUMNS
	local tagged=false
	local SELECTION=1
	local espeak_voices=""
	espeak_voices="$(espeak-ng --voices)"
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	else
		_input=
	fi

	local nospeak=false
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi

	local even=false
	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	fi

	local OPT=( )
	OPT[0]=
	local voices=( )
	if [ -d "$ALETHEIA/languages" ] && [ -n "$(find "$ALETHEIA/languages" -maxdepth 1 -type f)" ]; then
		voices=("$ALETHEIA/languages/"*[^\.help])
		voices+=("$ALETHEIA_DATA_DIR/languages/"*[^\.help])
	else
		voices=("$ALETHEIA_DATA_DIR/languages/"*[^\.help])
	fi
	voices=("${voices[@]##*/}")
	OPT+=("${voices[@]}")
	unset "OPT[0]"
	for (( i=1; i<=${#OPT[@]}; i++ )); do
		OPT_FULL[i]="$(get_local_lang "${OPT[i]}")"
	done

	combined=( )

	for i in "${!OPT_FULL[@]}"; do
		combined+=("${OPT_FULL[i]} ${OPT[i]}")
	done

	sorted_combined=$(printf "%s\n" "${combined[@]}" | sort)

	OPT_FULL=("")
	OPT=("")

	x=0
	while IFS=' ' read -r item1 item2; do
		if [ -n "$item1" ] && [ -n "$item2" ]; then
			OPT_FULL+=("$item1")
			OPT+=("$item2")
		fi
	done <<< "$sorted_combined"

	unset "OPT[0]" "OPT_FULL[0]"

	local TOTAL_OPTS=${#OPT[@]}
	z="$GTTS_LANGUAGE"
	zt="$((TOTAL_OPTS+1))"
	lt="$((LINES-4))"
	local _offset_=0
	if [ -n "$z" ]; then
		j=1
		until [ "${OPT[$j]}" == "${z%\+*}" ]; do
			((SELECTION++))
			if [ "$SELECTION" -gt "$lt" ]; then
				((_offset_++))
			fi
			((j++))
			if [ "$j" == "$zt" ]; then
				SELECTION=1
				_offset_=0
				break
			fi
		done
	fi

	orig_SELECTION=$SELECTION

	local pad_=1
	local menu_start_over=true
	local first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	local last=$((first + TOTAL_OPTS - 1))

	draw_banner "$(get_local_phrase "LANGUAGE")"
	echo -ne "$NOCOLOR"

	up() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -gt "1" ]; then
			SELECTION="$((SELECTION-1))"
			if [ "$((SELECTION-_offset_))" == "0" ]; then
				((_offset_--))
			fi
		else
			SELECTION="$TOTAL_OPTS"
			_offset_=$((TOTAL_OPTS-LINES+4))
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			ESPEAK_LANGUAGE="$(get_espeak_equiv "${OPT[SELECTION]}")+m1"
			GTTS_LANGUAGE="${OPT[$SELECTION]}"
		else
			lang="$(get_espeak_equiv "${OPT[SELECTION]}")"
			if grep -q -E "[[:space:]]${lang}[[:space:]]" <<<"$espeak_voices"; then
				ESPEAK_LANGUAGE="$(get_espeak_equiv "${OPT[$SELECTION]}")+m1"
			fi
			GTTS_LANGUAGE="${OPT[$SELECTION]}"
			if check_local_lang "$GTTS_LANGUAGE"; then
				VOICE_APPEND=".$GTTS_LANGUAGE"
			else
				VOICE_APPEND=".en"
			fi
			if [ ! -d "$ALETHEIA/voices$VOICE_APPEND" ]; then
				mkdir "$ALETHEIA/voices$VOICE_APPEND"
			fi
		fi
		echo -ne "$NOCOLOR"
		tagged=false
		z=""
	}

	down() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
			SELECTION="$((SELECTION+1))"
			if [ "$((SELECTION-_offset_))" == "$((LINES-3))" ]; then
				((_offset_++))
			fi
		else
			SELECTION="1"
			_offset_=0
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			ESPEAK_LANGUAGE="$(get_espeak_equiv "${OPT[$SELECTION]}")+m1"
			GTTS_LANGUAGE="${OPT[$SELECTION]}"
		else
			lang="$(get_espeak_equiv "${OPT[SELECTION]}")"
			if grep -q -E "[[:space:]]${lang}[[:space:]]" <<<"$espeak_voices"; then
				ESPEAK_LANGUAGE="$(get_espeak_equiv "${OPT[$SELECTION]}")+m1"
			fi
			GTTS_LANGUAGE="${OPT[$SELECTION]}"
			if check_local_lang "$GTTS_LANGUAGE"; then
				VOICE_APPEND=".$GTTS_LANGUAGE"
			else
				VOICE_APPEND=".en"
			fi
			if [ ! -d "$ALETHEIA/voices$VOICE_APPEND" ]; then
				mkdir "$ALETHEIA/voices$VOICE_APPEND"
			fi
		fi
		echo -ne "$NOCOLOR"
		tagged=false
		z=""
	}

	left() {
		if [ "$orig_SELECTION" != "$SELECTION" ]; then
			draw_banner "$(get_local_phrase "WAIT")"
			echo -ne "$NOCOLOR"
			reset_dimensions
			if [ "$2" != true ]; then
				reset_buffer
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == false ]; then
				draw_banner "$(get_local_phrase "WAIT")"
				ESPEAK_LANGUAGE="$(get_espeak_equiv "$GTTS_LANGUAGE")+m1"
			fi
			_save_setting "LANGUAGE" "$GTTS_LANGUAGE"
			if [ -e "$ALETHEIA/languages/$GTTS_LANGUAGE" ]; then
				LANGUAGE="$(<"$ALETHEIA/languages/$GTTS_LANGUAGE")"
			else
				LANGUAGE="$(<"$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE")"
			fi
			if [ "$GTTS_LANGUAGE" == "en" ]; then
				HELP="$ORIG_HELP"
				REPEAT_HELP="$ORIG_REPEAT_HELP"
				SETUP_HELP="$ORIG_SETUP_HELP"
				QUEUE_HELP="$ORIG_QUEUE_HELP"
				SCALE_HELP="$ORIG_SCALE_HELP"
				render_all_help_screens
			else
				if [ -e "$ALETHEIA/languages/$GTTS_LANGUAGE.help" ]; then
					# shellcheck disable=SC1090
					# Run shellcheck on these individually
					source "$ALETHEIA/languages/$GTTS_LANGUAGE.help"
					render_all_help_screens
				elif [ -e "$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE.help" ]; then
					# shellcheck disable=SC1090
					# Run shellcheck on these individually
					source "$ALETHEIA_DATA_DIR/languages/$GTTS_LANGUAGE.help"
					render_all_help_screens
				fi
			fi
			echo -e "$CONFIG" >"$ALETHEIA/config"
		fi
		if [ "$2" != true ]; then
			redraw_buffer
			draw_pitch
			draw_position
		fi
		echo -ne "$NOCOLOR"
		_Music="$(get_local_phrase "Music")"
		_Theme="$(get_local_phrase "Theme")"
		_Edit="$(get_local_phrase "Edit")"
		_Language="$(get_local_phrase "Language")"
		z=","
	}

	skip_=false
	until [ "$z" == "," ]; do
		TOTAL_OPTS=${#OPT[@]}
		if [ "$z" == "" ]; then
			x=1

			if [ "$skip_" != true ]; then
				if [ "$3" == true ] && [ -n "$4" ]; then
					SELECTION="$4" draw_menu false "$(($2-5))" true "l" "m" true
				fi
				_offset=$_offset_ draw_menu false "" false "" "" true
			else
				skip_=false
			fi

			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.0005
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						reset_buffer
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						_offset_=0
						SELECTION=1
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "LANGUAGE")"
						draw_position
						echo -ne "$NOCOLOR"
						break
					else
						screen_redrawn=false
					fi
					if read -rsn1 -t $BANNER_WAIT_TIME z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "k" ]; then
			up
			continue
		elif [ "$z" == "j" ]; then
			down
			continue
		elif [ "$z" == "q" ] || [ "$z" == "i" ] || [ "$z" == "" ] || [ "$z" == "h" ]; then
			left "$3" "$initial_screen"
			return
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			skip_=true
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "LANGUAGE")"
			draw_position
			if [ "$initial_screen" == false ]; then
				reset_buffer
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				continue
				;;
			'[B')
				down
				continue
				;;
			'[C')
				z=""
				continue
				;;
			*)
				left "$3" "$initial_screen"
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			case $SELECTION in
			*)
				left "$3" "$initial_screen"
				;;
			esac
		fi
		if [ "$z" == "," ]; then
			if [ "$REPEAT_ONLY" == true ]; then
				gtts_speak_chain "menu closed" "loop mode" &
			else
				gtts_speak_chain "menu closed" "main screen" &
			fi
		fi
	done
}

theme_submenu() {
	local initial_screen=$1
	local z=""
	local old_LINES=$LINES
	local old_COLUMNS=$COLUMNS
	local tagged=false

	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	else
		_input=
	fi

	local nospeak=false
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	fi

	local even=false
	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	fi

	local OPT=( )
	local list_themes=

	if [ -d "$ALETHEIA/themes" ]; then
		list_themes="$(ls -1 "$ALETHEIA/themes")"
		if [ -d "$ALETHEIA/themes" ] && [ -n "$list_themes" ]; then
			readarray -O 1 -t OPT <<<"$list_themes"
		fi
	fi
	local TOTAL_OPTS=${#OPT[@]}
	if [ -d "$ALETHEIA_DATA_DIR/themes" ]; then
		readarray -O $((TOTAL_OPTS+1)) -t OPT <<<"$(ls -1 "$ALETHEIA_DATA_DIR/themes/")"
	fi
	TOTAL_OPTS=${#OPT[@]}
	export OPT TOTAL_OPTS

	local longest=
	longest="$(wc -L <<<"${OPT[@]}")"

	local SELECTION="1"
	local _offset_=0
	if [ -n "$THEME_FILE" ]; then
		j=1
		until [ "${OPT[$j]}" == "$THEME_FILE" ]; do
			((SELECTION++))
			if [ "$SELECTION" -gt "$((LINES-4))" ]; then
				((_offset_++))
			fi
			((j++))
			if [ "$j" == "$((TOTAL_OPTS+1))" ]; then
				SELECTION=1
				_offset_=0
				break
			fi
		done
	fi

	orig_SELECTION=$SELECTION

	local pad_=1
	local menu_start_over=true
	local first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	local last=$((first + TOTAL_OPTS - 1))

	draw_banner "$(get_local_phrase "THEME")"
	echo -ne "$NOCOLOR"

	THEME_FILE="${OPT[SELECTION]}"
	check_colors true
	draw_volume
	draw_equalizer
	draw_banner "$(get_local_phrase "THEME")"
	draw_position
	THEME_ENABLED=true
	_save_setting "THEME_ENABLED" "$THEME_ENABLED"
	echo -e "$CONFIG" >"$ALETHEIA/config"

	up() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -gt "1" ]; then
			SELECTION="$((SELECTION-1))"
			if [ "$((SELECTION-_offset_))" == "0" ]; then
				((_offset_--))
			fi
		else
			SELECTION="$TOTAL_OPTS"
			_offset_=$((TOTAL_OPTS-LINES+4))
		fi
		THEME_FILE="${OPT[SELECTION]}"
		THEME_ENABLED=true
		check_colors true
		draw_volume
		draw_equalizer
		draw_banner "$(get_local_phrase "THEME")"
		draw_position
		if [ "$MUTE" == true ]; then
			draw_banner "$(get_local_phrase "MUTE")"
		elif [ "$PAUSE" == true ]; then
			draw_banner "$(get_local_phrase "PAUSE")"
		fi
		echo -ne "$NOCOLOR"
		tagged=false
		z=""
	}

	down() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
			SELECTION="$((SELECTION+1))"
			if [ "$((SELECTION-_offset_))" == "$((LINES-3))" ]; then
				((_offset_++))
			fi
		else
			SELECTION="1"
			_offset_=0
		fi
		THEME_FILE="${OPT[SELECTION]}"
		THEME_ENABLED=true
		check_colors true
		draw_volume
		draw_equalizer
		draw_banner "$(get_local_phrase "THEME")"
		draw_position
		if [ "$MUTE" == true ]; then
			draw_banner "$(get_local_phrase "MUTE")"
		elif [ "$PAUSE" == true ]; then
			draw_banner "$(get_local_phrase "PAUSE")"
		fi
		echo -ne "$NOCOLOR"
		tagged=false
		z=""
	}

	left() {
		#if [ "$orig_SELECTION" != "$SELECTION" ]; then
			draw_banner "$(get_local_phrase "WAIT")"
			echo -ne "$NOCOLOR"
			reset_dimensions
			if [ "$2" != true ]; then
				reset_buffer
			fi
			_save_setting "THEME_FILE" "$THEME_FILE"
			echo -e "$CONFIG" >"$ALETHEIA/config"
		#fi
		if [ "$1" != true ]; then
			redraw_buffer
			draw_pitch
			draw_position
		fi
		echo -ne "$NOCOLOR"
		z=","
	}

	until [ "$z" == "," ]; do
		TOTAL_OPTS=${#OPT[@]}
		if [ "$z" == "" ]; then
			x=1

			if [ "$3" == true ] && [ -n "$4" ]; then
				SELECTION="$4" draw_menu false "$(($2-5))" true "l" "m"
			fi
			_offset=$_offset_ draw_menu

			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.0005
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						reset_buffer
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						_offset_=0
						SELECTION=1
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "THEME")"
						draw_position
						echo -ne "$NOCOLOR"
						break
					else
						screen_redrawn=false
					fi
					if read -rsn1 -t $BANNER_WAIT_TIME z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "k" ]; then
			up
			continue
		elif [ "$z" == "j" ]; then
			down
			continue
		elif [ "$z" == "q" ] || [ "$z" == "i" ] || [ "$z" == "" ] || [ "$z" == "h" ]; then
			left "$3" "$initial_screen"
			return
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "THEME")"
			draw_position
			if [ "$initial_screen" == false ]; then
				reset_buffer
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				continue
				;;
			'[B')
				down
				continue
				;;
			'[C')
				z=""
				continue
				;;
			*)
				left "$3" "$initial_screen"
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			case $SELECTION in
			*)
				THEME_ENABLED=true
				_save_setting "THEME_ENABLED" "$THEME_ENABLED"
				echo -e "$CONFIG" >"$ALETHEIA/config"
				check_colors true

				draw_volume
				draw_equalizer
				draw_banner "$(get_local_phrase "THEME")"
				draw_position
				if [ "$MUTE" == true ]; then
					draw_banner "$(get_local_phrase "MUTE")"
				elif [ "$PAUSE" == true ]; then
					draw_banner "$(get_local_phrase "PAUSE")"
				fi
			esac
		fi
		if [ "$z" == "," ]; then
			if [ "$REPEAT_ONLY" == true ]; then
				gtts_speak_chain "menu closed" "loop mode" &
			else
				gtts_speak_chain "menu closed" "main screen" &
			fi
		fi
	done
}

music_submenu() {
	local initial_screen=$1
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	local z=""
	old_LINES=$LINES
	old_COLUMNS=$COLUMNS
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi
	tagged=false

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	else
		even=false
	fi

	local OPT=( )
	OPT=( "" "$(get_local_phrase "Locks")" "$(get_local_phrase "Loops")" )
	unset "OPT[0]"
	local SELECTION="1"
	pad_=1
	menu_start_over=true
	first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	last=$((first + TOTAL_OPTS - 1))
	local _offset=0

	draw_banner "$(get_local_phrase "Music")"
	echo -ne "$NOCOLOR"
	local TOTAL_OPTS=

	up() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -gt "1" ]; then
			SELECTION="$((SELECTION-1))"
			if [ "$((SELECTION-_offset))" == "0" ]; then
				((_offset--))
			fi
		else
			SELECTION="$TOTAL_OPTS"
			_offset=$((TOTAL_OPTS-LINES+4))
			if [ "$_offset" -lt "0" ]; then
				_offset=0
			fi
		fi
		tagged=false
		z=""
	}

	down() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
			SELECTION="$((SELECTION+1))"
			if [ "$((SELECTION-_offset))" == "$((LINES-3))" ]; then
				((_offset++))
			fi
		else
			SELECTION="1"
			_offset=0
		fi
		tagged=false
		z=""
	}

	until [ "$z" == "," ]; do
		TOTAL_OPTS=${#OPT[@]}
		if [ "$z" == "" ]; then
			x=1

			draw_menu

			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.0005
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						reset_buffer
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						_offset=0
						SELECTION=1
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "Music")"
						draw_position
						echo -ne "$NOCOLOR"
						break
					else
						screen_redrawn=false
					fi
					if read -rsn1 -t $BANNER_WAIT_TIME z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "k" ]; then
			up
			continue
		elif [ "$z" == "j" ]; then
			down
			continue
		elif [ "$z" == "q" ] || [ "$z" == "i" ] || [ "$z" == "h" ]; then
			if [ "$initial_screen" == true ]; then
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
				return
			fi
			z=","
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "Music")"
			draw_position
			if [ "$initial_screen" == false ]; then
				reset_buffer
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				continue
				;;
			'[B')
				down
				continue
				;;
			'[D')
				if [ "$initial_screen" == true ]; then
					draw_banner "$(get_local_phrase "MENU")"
					draw_position
					return
				fi
				z=","
				;;
			'[C')
				right
				continue
				;;
			*)
				if [ "$initial_screen" == true ]; then
					draw_banner "$(get_local_phrase "MENU")"
					draw_position
					return
				fi
				z=","
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			if [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Loops")" ]; then
				VIDEO=false
				load_only_loops true
				if [ "$?" == "200" ]; then
					draw_banner "$(get_local_phrase "NO LOOPS")"
					gtts_speak "$(get_local_phrase "no loops")" true
					sleep $BANNER_WAIT_TIME
					draw_banner "$(get_local_phrase "MENU")"
					echo -ne "$NOCOLOR"
					menu_start_over=true
					continue
				fi
				JUMP="1"
				echo -ne "$NOCOLOR"
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				REPEAT_ONLY=true
				return $RETURN_JUMP
			elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Locks")" ]; then
				VIDEO=false
				draw_banner "$(get_local_phrase "WAIT")"
				set_only_locked false false false false true
				if [ "$?" == "50" ]; then
					draw_banner "$(get_local_phrase "NO LOCKS")"
					gtts_speak "$(get_local_phrase "no locks")" true
					sleep $BANNER_WAIT_TIME
					draw_banner "$(get_local_phrase "MENU")"
					echo -ne "$NOCOLOR"
					menu_start_over=true
					continue
				fi
				JUMP="1"
				echo -ne "$NOCOLOR"
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				REPEAT_ONLY=false
				return $RETURN_JUMP
			else
				z=","
			fi
		fi
		if [ "$z" == "," ]; then
			if [ "$REPEAT_ONLY" == true ]; then
				gtts_speak_chain "menu closed" "loop mode" &
			else
				gtts_speak_chain "menu closed" "main screen" &
			fi
			z=","
		fi
	done
}

edit_submenu() {
	local initial_screen=$1
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	local z=""
	old_LINES=$LINES
	old_COLUMNS=$COLUMNS
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	else
		_input=
	fi
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi
	tagged=false

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	else
		even=false
	fi

	local OPT=( )
	_Tag="$(get_local_phrase "Tag")"
	_Lock="$(get_local_phrase "Lock")"
	_Loop="$(get_local_phrase "Loop")"
	_Queue="$(get_local_phrase "Queue")"
	_Config="$(get_local_phrase "Config")"
	OPT=( "" "$_Tag" "$_Lock" "$_Loop" "$_Queue" "$_Config" )
	unset "OPT[0]"
	local SELECTION="1"
	pad_=1
	menu_start_over=true
	first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	last=$((first + TOTAL_OPTS - 1))
	local _offset=0

	draw_banner "$(get_local_phrase "$_Edit")"
	echo -ne "$NOCOLOR"
	local TOTAL_OPTS=

	up() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -gt "1" ]; then
			SELECTION="$((SELECTION-1))"
			if [ "$((SELECTION-_offset))" == "0" ]; then
				((_offset--))
			fi
		else
			SELECTION="$TOTAL_OPTS"
			_offset=$((TOTAL_OPTS-LINES+4))
			if [ "$_offset" -lt "0" ]; then
				_offset=0
			fi
		fi
		tagged=false
		z=""
	}

	down() {
		if [ -n "$ESPEAK_PID" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			unset ESPEAK_PID
		fi
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
			SELECTION="$((SELECTION+1))"
			if [ "$((SELECTION-_offset))" == "$((LINES-3))" ]; then
				((_offset++))
			fi
		else
			SELECTION="1"
			_offset=0
		fi
		tagged=false
		z=""
	}

	left() {
		if [ "$initial_screen" == true ]; then
			draw_banner "$(get_local_phrase "MENU")"
			draw_position
			return 1
		else
			if [ "$1" == true ]; then
				redraw_buffer
			fi
			draw_pitch
			draw_position
		fi
		z=","
		return 0
	}

	until [ "$z" == "," ]; do
		TOTAL_OPTS=${#OPT[@]}
		if [ "$z" == "" ]; then
			x=1

			draw_menu

			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.0005
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						reset_buffer
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						_offset=0
						SELECTION=1
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "EDIT")"
						draw_position
						echo -ne "$NOCOLOR"
						break
					else
						screen_redrawn=false
					fi
					if read -rsn1 -t $BANNER_WAIT_TIME z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "k" ]; then
			up
			continue
		elif [ "$z" == "j" ]; then
			down
			continue
		elif [ "$z" == "q" ] || [ "$z" == "i" ] || [ "$z" == "h" ]; then
			left "$2"
			if [ "$?" == "1" ]; then
				return
			fi
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "EDIT")"
			draw_position
			if [ "$initial_screen" == false ]; then
				reset_buffer
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				continue
				;;
			'[B')
				down
				continue
				;;
			'[D')
				left "$2"
				if [ "$?" == "1" ]; then
					return
				fi
				;;
			'[C')
				z=""
				continue
				;;
			*)
				left "$2"
				if [ "$?" == "1" ]; then
					return
				fi
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			case $SELECTION in
			*)
				if [ "${OPT[$SELECTION]}" == "$_Queue" ]; then
					if [ "$initial_screen" == true ]; then
						gtts_speak "nothing loaded" true
						draw_banner "N/A"
						sleep $BANNER_WAIT_TIME
					else
						edit_playlist_vim
						menu_start_over=true
						if [ "$?" == "$RETURN_JUMP" ]; then
							return "$RETURN_JUMP"
						fi
					fi
					draw_banner "$(get_local_phrase "EDIT")"
					draw_position
				elif [ "${OPT[$SELECTION]}" == "$_Tag" ]; then
					tag_mp3 "$initial_screen"
					draw_banner "$(get_local_phrase "EDIT")"
					draw_position
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "$_Loop" ]; then
					if [ -z "$FILENAME" ]; then
						gtts_speak "nothing loaded" true
						draw_banner "N/A"
						sleep $BANNER_WAIT_TIME
					else
						gtts_speak "opening vim"
						if [ -e "$FILENAME.repeats" ]; then
							cp "$FILENAME.repeats" "$ALETHEIA/.${FILENAME##*/}.repeats"
						fi
						vim -c "silent edit $FILENAME.repeats | source $ALETHEIA_DATA_DIR/vimrc/vimrc.lock"
						tput civis
						stty -ixon
						if [ -e "$FILENAME.repeats" ] && [ -z "$(cat "$FILENAME.repeats")" ]; then
							rm -f "$FILENAME.repeats"
						elif [ -e "$FILENAME.repeats" ] && [ -n "$(diff "$FILENAME.repeats" "$ALETHEIA/.${FILENAME##*/}.repeats")" ]; then
							REPEATS=$(<"$FILENAME.repeats")
							REPEAT_CURRENT=1
							REPEAT_TOTAL=$(wc -l <"$FILENAME.repeats")

							START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
							orig_START_MARKER=$START_MARKER
							if [ "$START_MARKER" == "" ]; then
								START_MARKER=0.00
							fi
							END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
							orig_END_TIME=$END_MARKER
							if [ "$END_MARKER" == "" ]; then
								END_MARKER=5.00
							fi
							if [ "$START_MARKER" == "$END_MARKER" ]; then
								START_MARKER=0.00
								END_MARKER=5.00
							fi

							START_MARKER="$(printf '%.2f' "$START_MARKER")"
							END_MARKER="$(printf '%.2f' "$END_MARKER")"

							time=$(calc -pd "($END_MARKER-$START_MARKER)*($s)")
							space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
							orig_space=$space
							if [ "$space" == "" ]; then
								space=0
							fi
							gtts_speak "loop updated" true
						fi
						if [ -e "$ALETHEIA/.${FILENAME##*/}.repeats" ]; then
							rm -f "$ALETHEIA/.${FILENAME##*/}.repeats"
						fi
					fi
					menu_start_over=true
					draw_banner "$(get_local_phrase "EDIT")"
					draw_position
				elif [ "${OPT[$SELECTION]}" == "$_Lock" ]; then
					if [ -z "$FILENAME" ]; then
						gtts_speak "nothing loaded" true
						draw_banner "N/A"
						sleep $BANNER_WAIT_TIME
					else
						gtts_speak "opening vim"
						if [ -e "$FILENAME.locked" ]; then
							cp "$FILENAME.locked" "$ALETHEIA/.${FILENAME##*/}.locked"
						fi
						vim -c "silent edit $FILENAME.locked | source $ALETHEIA_DATA_DIR/vimrc/vimrc.lock"
						tput civis
						stty -ixon
						if [ -e "$FILENAME.locked" ] && [ -z "$(cat "$FILENAME.locked")" ]; then
							rm -f "$FILENAME.locked"
						elif [ -e "$FILENAME.locked" ] && [ -n "$(diff "$FILENAME.locked" "$ALETHEIA/.${FILENAME##*/}.locked")" ]; then
							CONTENTS=$(<"$FILENAME.locked")
							LOCK_TOTAL=$(wc -l <<<"$CONTENTS")
							((LOCK_TOTAL++))
							LOCK_SELECTION=0
							gtts_speak "lock updated" true
						fi
						if [ -e "$ALETHEIA/.${FILENAME##*/}.locked" ]; then
							rm -f "$ALETHEIA/.${FILENAME##*/}.locked"
						fi
					fi
					menu_start_over=true
					draw_banner "$(get_local_phrase "EDIT")"
					draw_position
				elif [ "${OPT[$SELECTION]}" == "$_Config" ]; then
					gtts_speak "opening vim"
					cp "$ALETHEIA/config" "$ALETHEIA/.config.old"
					vim -c "silent edit $ALETHEIA/config | source $ALETHEIA_DATA_DIR/vimrc/vimrc"
					tput civis
					stty -ixon
					if [ -n "$(diff "$ALETHEIA/config" "$ALETHEIA/.config.old")" ]; then
						gtts_speak "please wait"
						check_config true
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "WAIT")"
						draw_position
						render_all_help_screens
						if [ "$initial_screen" != true ]; then
							reset_buffer
						fi
						draw_banner "$(get_local_phrase "MENU")"
						draw_position
						gtts_speak "config updated" true
					fi
					menu_start_over=true
					rm -f "$ALETHEIA/.config.old"
				else
					z=","
				fi
			esac
		fi
		if [ "$z" == "," ]; then
			if [ "$REPEAT_ONLY" == true ]; then
				gtts_speak_chain "menu closed" "loop mode" &
			else
				gtts_speak_chain "menu closed" "main screen" &
			fi
			z=","
		fi
	done
}

edit_playlist_vim() {
	echo -e "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/queue"
	cp "$ALETHEIA/queue" "$ALETHEIA/queue.old"
	gtts_speak "opening vim"
	vim -c "silent edit $ALETHEIA/queue | source $ALETHEIA_DATA_DIR/vimrc/vimrc.queue" +"$POSITION"
	tput civis
	stty -ixon
	diff "$ALETHEIA"/queue "$ALETHEIA"/queue.old >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		unset queue_array

		IFS=$'\n'
		index=0
		while read -r i; do
			queue_array[index]="$i"
			index=$((index+1))
		done < "$ALETHEIA/queue"
		unset IFS
		TOTAL_QUEUE=$index
		gtts_speak "queue updated" true
		# FIXME
		new="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		if [ "$new" == "" ]; then
			res="${queue_array[$POSITION]}"
			if [ "$res" != "$FILENAME" ]; then
				rm -f "$ALETHEIA/queue" "$ALETHEIA/queue.old"
				tput civis
				stty -ixon
				JUMP="$POSITION"
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				return $RETURN_JUMP
			fi
		else
			POSITION="$new"
		fi
		reset_buffer
	else
		gtts_speak "closed" true
	fi
	rm -f "$ALETHEIA/queue" "$ALETHEIA/queue.old"
	draw_volume
	draw_equalizer
	draw_pitch
	draw_position
}

main_menu() {
	local initial_screen=$1
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	fi
	z=""
	old_LINES=$LINES
	old_COLUMNS=$COLUMNS
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	else
		_input=
	fi
	nospeak=false
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	fi
	tagged=false

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	else
		even=false
	fi

	unset OPT

	_Music="$(get_local_phrase "Music")"
	_Theme="$(get_local_phrase "Theme")"
	_Edit="$(get_local_phrase "Edit")"
	_Language="$(get_local_phrase "Language")"

	OPT=( "" "$_Music" "$(get_local_phrase "Sound")" "$(get_local_phrase "Video")" "$(get_local_phrase "Empty")" "$(get_local_phrase "Queue")" "$(get_local_phrase "Setup")" "$_Theme" "$_Edit" "$(get_local_phrase "Language")" "$(get_local_phrase "Help")" "$(get_local_phrase "Quit")" )

	unset "OPT[0]"
	TOTAL_OPTS=${#OPT[@]}

	SELECTION="1"
	pad_=1
	menu_start_over=true
	_offset=0

	first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	last=$((first + TOTAL_OPTS - 1))

	if [ "$initial_screen" == true ]; then
		echo -ne "$NOCOLOR"
		draw_volume
		draw_equalizer
		draw_banner "$(get_local_phrase "MENU")"
		draw_position
	else
		draw_banner "$(get_local_phrase "MENU")"
		echo -ne "$NOCOLOR"
	fi

	until [ "$z" == "," ]; do
		up() {
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$SELECTION" -gt "1" ]; then
				SELECTION="$((SELECTION-1))"
				if [ "$((SELECTION-_offset))" == "0" ]; then
					((_offset--))
				fi
			else
				SELECTION="$TOTAL_OPTS"
				_offset=$((TOTAL_OPTS-LINES+4))
			fi
			tagged=false
			z=""
		}

		down() {
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
				SELECTION="$((SELECTION+1))"
				if [ "$((SELECTION-_offset))" == "$((LINES-3))" ]; then
					((_offset++))
				fi
			else
				SELECTION="1"
				_offset=0
			fi
			tagged=false
			z=""
		}

		left() {
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			echo -ne "$WHITE"
			z=""
		}

		right() {
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "${OPT[SELECTION]}" == "$_Music" ]; then
				music_submenu "$initial_screen"
				local _ret="$?"
				if [ "$_ret" == "$RETURN_JUMP" ]; then
					return "$RETURN_JUMP"
				elif [ "$_ret" == "200" ]; then
					z=","
				fi
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
				menu_start_over=true
			elif [ "${OPT[SELECTION]}" == "$_Edit" ]; then
				edit_submenu "$initial_screen" false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return "$RETURN_JUMP"
				fi
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
				menu_start_over=true
			elif [ "${OPT[SELECTION]}" == "$_Theme" ]; then
				tmp_OPT=( "${OPT[@]}" )
				tmp_TOTAL_OPTS=$TOTAL_OPTS
				theme_submenu "$initial_screen" "" true
				draw_banner "$(get_local_phrase "MENU")"
				menu_start_over=true
			elif [ "${OPT[SELECTION]}" == "$_Language" ]; then
				lang_submenu true
				_Music="$(get_local_phrase "Music")"
				_Theme="$(get_local_phrase "Theme")"
				_Edit="$(get_local_phrase "Edit")"
				_Language="$(get_local_phrase "Language")"
				menu_start_over=true
				OPT=( "" "$_Music" "$(get_local_phrase "Sound")" "$(get_local_phrase "Video")" "$(get_local_phrase "Empty")" "$(get_local_phrase "Queue")" "$(get_local_phrase "Setup")" "$_Theme" "$_Edit" "$(get_local_phrase "Language")" "$(get_local_phrase "Help")" "$(get_local_phrase "Quit")" )
				unset "OPT[0]"
				draw_banner "$(get_local_phrase "MENU")"
				if [ "${OPT[SELECTION]}" == "$_Music" ] || [ "${OPT[SELECTION]}" == "$_Edit" ] || [ "${OPT[SELECTION]}" == "$_Theme" ] || [ "${OPT[SELECTION]}" == "$_Language" ]; then
					arrow=" "
				else
					arrow="  "
				fi
			fi
			z=""
		}

		if [ "$z" == "" ]; then
			x=1

			draw_menu

			until [ -n "$z" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				else
					tmp_z=
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.005
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						if [ "$initial_screen" == false ]; then
							reset_buffer
						fi
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						_offset=0
						SELECTION=1
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						draw_volume
						draw_equalizer
						draw_banner "$(get_local_phrase "MENU")"
						draw_position
						echo -ne "$NOCOLOR"
						break
					else
						screen_redrawn=false
					fi
					if IFS= read -rsn1 -t "$MAIN_REFRESH_TIME" z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ] && [ -z "$z" ]; then
			continue
		fi

		if [ "$z" == "j" ]; then
			down
			continue
		elif [ "$z" == "k" ]; then
			up
			continue
		elif [ "$z" == "l" ]; then
			right
			local _ret="$?"
			if [ "$_ret" == "$RETURN_JUMP" ]; then
				return "$RETURN_JUMP"
			fi
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			if [ "$initial_screen" == true ]; then
				menu_start_over=true
			fi
			draw_banner "$(get_local_phrase "MENU")"
			draw_position
			z=""
			continue
		elif [ "$z" == "i" ]; then
			if [ "$initial_screen" == true ]; then
				z=""
				continue
			else
				z=","
			fi
		elif [ "$z" == "T" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			toggle_feedback_level
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "a" ]; then
			set_equalizer false true
			draw_equalizer
			z=""
			continue
		elif [ "$z" == "" ]; then
			theme_submenu true
			draw_banner "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			lang_submenu "$initial_screen"
			OPT=( "" "$(get_local_phrase "Music")" "$(get_local_phrase "Sound")" "$(get_local_phrase "Video")" "$(get_local_phrase "Empty")" "$(get_local_phrase "Queue")" "$(get_local_phrase "Setup")" "$(get_local_phrase "Theme")" "$(get_local_phrase "Edit")" "$(get_local_phrase "Language")" "$(get_local_phrase "Help")" "$(get_local_phrase "Quit")" )
			unset "OPT[0]"
			draw_banner "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "|" ]; then
			vanish true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "g" ]; then
			if [ "$initial_screen" == false ]; then
				tag_mp3 false
			fi
			z=""
			continue
		elif [ "$z" == "" ]; then
			invert_colors true
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			z=""
			continue
		elif [ "$z" == "C" ]; then
			set_scale_speed
			draw_banner "$(get_local_phrase "MENU")"
			z=""
			continue
		elif [ "$z" == "q" ]; then
			if [ "$initial_screen" == true ]; then
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				else
					_input=
				fi
				if [ "$_input" != "" ]; then
					if [ "$_input" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					fi
				fi
				draw_banner "$(get_local_phrase "QUIT")" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "do you want to quit?"
				fi
				input_char=""
				while true; do
					read -rn1 input_char
					if [ "$input_char" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						exit 0
					elif [ "$input_char" == "q" ] || [ "$input_char" == $'\e' ]; then
						if [ -n "$ESPEAK_PID" ]; then
							kill "$ESPEAK_PID" >/dev/null 2>/dev/null
							unset ESPEAK_PID
						fi
						if [ "$GTTS_NATURAL_VOICE" == true ]; then
							pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
						fi
						break
					elif [ "$input_char" == "n" ]; then
						break
					fi
				done
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
				gtts_speak "quit canceled" true
				z=""
				continue
			fi
			z=","
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false true
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "MENU")"
			draw_position
			reset_buffer
			z=""
			continue
		elif [ "$z" == ":" ]; then
			tput cup 1
			tput el
			tput cup $((LINES-2))
			tput el
			setup_screen "$initial_screen" true
			OPT=( "" "$(get_local_phrase "Music")" "$(get_local_phrase "Sound")" "$(get_local_phrase "Video")" "$(get_local_phrase "Empty")" "$(get_local_phrase "Queue")" "$(get_local_phrase "Setup")" "$(get_local_phrase "Theme")" "$(get_local_phrase "Edit")" "$(get_local_phrase "Language")" "$(get_local_phrase "Help")" "$(get_local_phrase "Quit")" )
			unset "OPT[0]"
			if [ "$initial_screen" == false ]; then
				redraw_buffer
			fi
			draw_banner "$(get_local_phrase "MENU")"
			z=""
			continue
		elif [ "$z" == "?" ]; then
			tput cup 1
			tput el
			tput cup $((LINES-2))
			tput el
			if [ "$initial_screen" == true ]; then
				help_screen true
			else
				help_screen false
			fi
			draw_volume
			draw_equalizer
			if [ "$initial_screen" == true ]; then
				draw_menu
			else
				draw_pitch
			fi
			draw_position
			menu_start_over=true
			z=""
			continue
		#elif [ "$z" == "S" ]; then
		#	new_playlist true
		#	if [ "$?" == "$RETURN_JUMP" ]; then
		#		return $RETURN_JUMP
		#	fi
		#	menu_start_over=true
		#	z=""
		#	continue
		elif [ "$z" == "" ]; then
			toggle_pause false true
			z=""
			continue
		elif [ "$z" == "p" ] || [ "$z" == " " ]; then
			if [ "$initial_screen" != true ]; then
				toggle_pause true
			fi
			z=""
			continue
		elif [ "$z" == "s" ]; then
			if [ "$initial_screen" == false ]; then
				REPEAT_ONLY=false
			fi
			if [ "$SELECTION" == "2" ]; then
				dir="$SOUNDDIR"
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
			elif [ "$SELECTION" == "3" ]; then
				dir="$VIDEODIR"
				regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
			else
				dir="$MUSICDIR"
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
			fi
			VIDEO=false
			mapfile -t tmp_array < <(find "$dir" -type f -iregex "$regex" | sort)
			new_TOTAL_QUEUE=${#tmp_array[@]}
			if [ "$new_TOTAL_QUEUE" == "0" ]; then
				if [ "$SELECTION" == "2" ]; then
					draw_banner "$(get_local_phrase "NO SOUND")"
					gtts_speak "no sound"
				elif [ "$SELECTION" == "3" ]; then
					draw_banner "$(get_local_phrase "NO VIDEO")"
					gtts_speak "no video"
				else
					draw_banner "$(get_local_phrase "NO MUSIC")"
					gtts_speak "no music"
				fi
				sleep $BANNER_WAIT_TIME
				NO_QUEUE_FLAG=true
				menu_start_over=true
				z=""
				continue
			else
				old_tq=$TOTAL_QUEUE
				old_qa=("${queue_array[@]}")
				TOTAL_QUEUE=$new_TOTAL_QUEUE
				queue_array=("${tmp_array[@]}")
				SHUFFLED=false
				echo -ne "$NOCOLOR"
			fi
			start_search true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			else
				TOTAL_QUEUE=$old_tq
				queue_array=("${old_qa[@]}")
			fi
			draw_banner "$(get_local_phrase "MENU")"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "Q" ]; then
			queue_controls true
			if [ "$?" == "$RETURN_JUMP" ]; then
				JUMP=1
				return $RETURN_JUMP
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				continue
				;;
			'[B')
				down
				continue
				;;
			'[D')
				left
				continue
				;;
			'[C')
				right
				local _ret="$?"
				if [ "$_ret" == "$RETURN_JUMP" ]; then
					return "$RETURN_JUMP"
				fi
				continue
				;;
			'')
				if [ "$initial_screen" == true ]; then
					exit 0
				else
					tput cup $((LINES-2))
					tput el
					z=","
				fi
				;;
			'[1')
				read -rsn2 -t 0.001
				z=""
				continue
				;;
			'[2')
				read -rsn2 -t 0.001 key2
				if [ "$key2" == "~" ]; then
					if [ "$initial_screen" == true ]; then
						JUMP=1
						new_playlist true
						if [ "$?" == "$RETURN_JUMP" ]; then
							return $RETURN_JUMP
						fi
					else
						insert
						z=","
						break
					fi
				fi
				z=""
				continue
				;;
			'[3')
				read -rsn1 -t 0.001
				z=""
				continue
				;;
			'[5')
				read -rsn1 -t 0.001
				z=""
				continue
				;;
			'[6')
				read -rsn1 -t 0.001
				z=""
				continue
				;;
			*)
				if [ "$key" == "[O" ]; then
					read -rsn1 -t 0.001
				fi
				z=""
				continue
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			case $SELECTION in
			*)
				if [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Empty")" ]; then
					JUMP="1"
					new_playlist true
					if [ "$?" == "$RETURN_JUMP" ]; then
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "$_Music" ]; then
					regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$MUSICDIR" -type f -regex "$regex" -and -not -iname "*.repeat.*" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "$(get_local_phrase "NO MUSIC")"
						gtts_speak "no music" true
						sleep $BANNER_WAIT_TIME
						draw_banner "$(get_local_phrase "MENU")"
						echo -ne "$NOCOLOR"
						menu_start_over=true
						NO_QUEUE_FLAG=true
						continue
					else
						PICK=""
						REPEAT_ONLY=false
						VIDEO=false
						SHUFFLED=true
						queue_array=("${tmp_array[@]}")
						TOTAL_QUEUE=$new_TOTAL_QUEUE
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Sound")" ]; then
					regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$SOUNDDIR" -type f -regex "$regex" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "$(get_local_phrase "NO SOUNDS")"
						gtts_speak "no sounds" true
						sleep $BANNER_WAIT_TIME
						draw_banner "$(get_local_phrase "MENU")"
						echo -ne "$NOCOLOR"
						menu_start_over=true
						NO_QUEUE_FLAG=true
						continue
					else
						PICK=""
						REPEAT_ONLY=false
						VIDEO=false
						SHUFFLED=true
						TOTAL_QUEUE="$new_TOTAL_QUEUE"
						queue_array=("${tmp_array[@]}")
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Video")" ]; then
					regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$VIDEODIR" -type f -regex "$regex" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "$(get_local_phrase "NO VIDEOS")"
						gtts_speak "no videos" true
						sleep $BANNER_WAIT_TIME
						draw_banner "$(get_local_phrase "MENU")"
						echo -ne "$NOCOLOR"
						NO_QUEUE_FLAG=true
						menu_start_over=true
						continue
					else
						REPEAT_ONLY=false
						SHUFFLED=true
						TOTAL_QUEUE=$new_TOTAL_QUEUE
						queue_array=("${tmp_array[@]}")
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Queue")" ]; then
					if [ ! -d "$ALETHEIA/playlists" ]; then
						draw_banner "$(get_local_phrase "NO QUEUES")"
						sleep "$BANNER_WAIT_TIME"
						draw_banner "$(get_local_phrase "MENU")"
						echo -ne "$NOCOLOR"
						menu_start_over=true
					fi
					queue_controls true
					if [ "$?" == "$RETURN_JUMP" ]; then
						JUMP=1
						return $RETURN_JUMP
					fi
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "$_Edit" ]; then
					edit_submenu "$initial_screen" false
					if [ "$?" == "$RETURN_JUMP" ]; then
						return "$RETURN_JUMP"
					fi
					draw_banner "$(get_local_phrase "MENU")"
					draw_position
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "$_Theme" ]; then
					tmp_OPT=( "${OPT[@]}" )
					tmp_TOTAL_OPTS=$TOTAL_OPTS
					theme_submenu "$initial_screen" "" true
					draw_banner "$(get_local_phrase "MENU")"
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Setup")" ]; then
					if [ "$NO_VERTICAL_PADDING" == false ]; then
						tput cup 1
						tput el
						tput cup $((LINES-2))
						tput el
					fi
					setup_screen "$initial_screen" true
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Language")" ]; then
					lang_submenu true
					menu_start_over=true
					draw_banner "$(get_local_phrase "MENU")"
					OPT=( "" "$_Music" "$(get_local_phrase "Sound")" "$(get_local_phrase "Video")" "$(get_local_phrase "Empty")" "$(get_local_phrase "Queue")" "$(get_local_phrase "Setup")" "$_Theme" "$_Edit" "$(get_local_phrase "Language")" "$(get_local_phrase "Help")" "$(get_local_phrase "Quit")" )
					unset "OPT[0]"
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Help")" ]; then
					tput cup 1
					tput el
					tput cup $((LINES-2))
					tput el
					if [ "$initial_screen" == true ]; then
						help_screen true
					else
						help_screen false
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					fi
					draw_volume
					draw_equalizer
					if [ "$initial_screen" == true ]; then
						draw_menu
					else
						draw_pitch
					fi
					draw_position
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "$(get_local_phrase "Quit")" ]; then
					clear
					exit 0
				else
					z=","
				fi

			esac
		fi
		if [ "$z" == "," ]; then
			if [ "$1" != true ]; then
				if [ "$((LINES-TOTAL_OPTS-2))" -le "1" ]; then
					redraw_buffer true
				else
					redraw_buffer
				fi
				draw_pitch
				draw_position
			fi
			if [ "$REPEAT_ONLY" == true ]; then
				gtts_speak_chain "menu closed" "loop mode" &
			else
				gtts_speak_chain "menu closed" "main screen" &
			fi
			z=","
		fi
	done
}

scale() {
	if [ "$WEB_CLIENT" != 1 ]; then
		gtts_speak "scale interval"
	fi
	draw_banner "$(get_local_phrase "SCALE")"
	stopat=""
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 interval_change
	else
		read -rsn1 interval_change <"$ALETHEIA/web_client_pipe$$"
	fi

	if [ "$interval_change" == "J" ]; then
		limit="-${INTERVAL_LOWER_LIMIT%%.*}"
		if [ "$INTERVAL" -le "$limit" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=2.5
		interval_change="$limit"
	elif [ "$interval_change" == "K" ]; then
		limit="${INTERVAL_UPPER_LIMIT%%.*}"
		if [ "$INTERVAL" -ge "$limit" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=2.5
		interval_change="$limit"
	elif [ "$interval_change" == "j" ]; then
		limit="-${INTERVAL_LOWER_LIMIT%%.*}"
		if [ "$INTERVAL" -le "$limit" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=$SCALE_SPEED
		interval_change="$limit"
	elif [ "$interval_change" == "k" ]; then
		limit="${INTERVAL_UPPER_LIMIT%%.*}"
		if [ "$INTERVAL" -ge "$limit" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=$SCALE_SPEED
		interval_change="$limit"
	elif [ "$interval_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "?" ]; then
		scale_help_screen
		RIGHT_BANNER_WIDTH=0
		redraw_buffer
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == $'\e' ] || [ "$interval_change" == "q" ] || [ "$interval_change" == "u" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$(is_num "$interval_change")" == "1" ] || [ "$interval_change" == "-" ]; then
		draw_position
		draw_banner "$(get_local_phrase "SCALE")"
		tmp="$(read_line "$interval_change" true)"
		if [ "$?" == "1" ]; then
			gtts_speak_chain "invalid number" "main screen" &
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		if [ "$tmp" -lt "$INTERVAL" ]; then
			if [ "$tmp" -le "-$(echo -n "$INTERVAL_LOWER_LIMIT" | cut -d'.' -f1)" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=true
			time=$SCALE_SPEED
			interval_change="$((INTERVAL-EDO))"
		elif [ "$tmp" -gt "$INTERVAL" ]; then
			if [ "$tmp" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=false
			time=$SCALE_SPEED
			interval_change="$((INTERVAL+EDO))"
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "$(get_local_phrase "SCALE")" false true
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$interval_change" != "" ]; then
		draw_banner "$(get_local_phrase "SCALE")" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		orig_int="$INTERVAL"
		c=""
		while [ "$interval_change" != "$orig_int" ]; do
			if [ "$interval_change" -le "$orig_int" ] || [ "$backwards" == true ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t "$SCALE_SPEED" c
				else
					read -rsn1 -t "$SCALE_SPEED" c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "$(get_local_phrase "SCALE")"
				if [ "$c" == $'\e' ] || [ "$c" == "u" ] || [ "$c" == "q" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ]; then
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					if [ "$backwards" == true ]; then
						backwards=false
						interval_change="$((interval_change * -1))"
					else 
						backwards=true
						interval_change="$((interval_change * -1))"
						INTERVAL="$((INTERVAL-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "$(get_local_phrase "SCALE")" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "$(get_local_phrase "SCALE")" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
					INTERVAL="$((INTERVAL-1))"
					echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-$(echo -n "$INTERVAL_LOWER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				fi

			elif [ "$interval_change" -ge "$orig_int" ] || [ "$backwards" == false ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t "$SCALE_SPEED" c
				else
					read -rsn1 -t "$SCALE_SPEED" c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "$(get_local_phrase "SCALE")"
				if [ "$c" == $'\e' ] || [ "$c" == "q" ] || [ "$c" == "u" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ] || [ "$backwards" == true ]; then
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						INTERVAL="$((INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						INTERVAL="$((INTERVAL+1))"
					else
						backwards=true
						INTERVAL="$((INTERVAL-1))"
						interval_change="$((interval_change*-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "$(get_local_phrase "SCALE")" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "$(get_local_phrase "SCALE")" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					INTERVAL="$((INTERVAL+1))"
					echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-$(echo -n "$INTERVAL_LOWER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

scale_octave() {
	draw_banner "$(get_local_phrase "OCTAVE")" false true
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	if [ "$1" == "-" ]; then
		orig_int=$INTERVAL
		if [ "$((INTERVAL-EDO))" -ge "-$(echo -n "$INTERVAL_LOWER_LIMIT" | cut -d'.' -f1)" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$((INTERVAL-EDO))
				echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -lt "$EDO" ]; do
					read -rsn1 -t "$SCALE_SPEED" c 
					secondary_scale_func "$c" "$(get_local_phrase "OCTAVE")"
					if [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "$(get_local_phrase "OCTAVE")" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == $'\e' ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$((INTERVAL-1))"
						echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$((x+1))
					fi
				done
			fi
		fi
	elif [ "$1" == "+" ]; then
		orig_int=$INTERVAL
		if [ "$((INTERVAL+EDO))" -le "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$((INTERVAL+EDO))
				echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -lt "$EDO" ]; do
					read -rsn1 -t "$SCALE_SPEED" c 
					secondary_scale_func "$c" "$(get_local_phrase "OCTAVE")"
					if [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "$(get_local_phrase "OCTAVE")" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == $'\e' ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$((INTERVAL+1))"
						echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$((x+1))
					fi
				done
			fi
		fi
	fi
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

set_custom_int() {
	gtts_speak "enter interval adjustment"
	draw_banner "$(get_local_phrase "INT")" false false true
	tput rc
	read -rn1 interval_jump
	if [ "$(is_num "$interval_jump")" == "1" ] || [ "$interval_jump" == "-" ]; then
		interval_jump="$(read_line "$interval_jump" true)"
		if [ "$?" == "1" ]; then
			gtts_speak_chain "invalid number" "main screen" &
			draw_pitch
			return
		fi
		gtts_speak " $interval_jump"
	else
		gtts_speak_chain "invalid number" "main screen" &
		draw_pitch
		redraw_buffer
		return
	fi
	if [ "$interval_jump" != "" ]; then
		PAUSE=false
		echo -e "speed_set $(calc -pd "2^($interval_jump/$EDO)")" >"$ALETHEIA/pipe$$" &
		INTERVAL="$interval_jump"
	else
		gtts_speak "closed" true
		if [ "$1" != true ]; then
			draw_position
		fi
	fi
	draw_pitch
}

toggle_mute() {
	if [ "$MUTE" == false ]; then
		echo -e "mute 1" >"$ALETHEIA/pipe$$" &
		MUTE=true
		draw_banner "$(get_local_phrase "MUTE")"
		gtts_speak "muted" true
		pactl set-sink-mute @DEFAULT_SINK@ 1 >/dev/null 2>/dev/null
	else
		pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
		echo -e "mute 0" >"$ALETHEIA/pipe$$" &
		gtts_speak "unmuted"
		MUTE=false
		draw_pitch
	fi
}

toggle_pause() {
	if [ "$2" == true ]; then
		for pipe in "$ALETHEIA/pipe"*; do
			echo "pause" >"$pipe" &
		done
	else
		echo "pause" >"$ALETHEIA/pipe$$" &
	fi
	if [ "$PAUSE" == false ]; then
		PAUSE=true
		if [ "$1" != true ]; then
			gtts_speak "paused"
			draw_banner "$(get_local_phrase "PAUSE")" false false true
		fi
	else
		PAUSE=false
		if [ "$1" != true ]; then
			gtts_speak "unpaused"
			draw_pitch
		fi
	fi
}

reset_all_tuning() {
	SCALETEMPO=false
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	echo -e "af_del scaletempo\nspeed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	gtts_speak "reset"
	draw_equalizer
	draw_pitch
}

read_locked_file() {
	CONTENTS="$1"
	LOCK_SELECTION=0
	LOCK_TOTAL=$(echo -n "$CONTENTS" | wc -l)
	((LOCK_TOTAL++))
	IFS='/' read -r _int _edo _scaletempo_flag oldstyle1 oldstyle2 <<< "${CONTENTS%%$'\n'*}"
	if [ "$oldstyle1" != "" ] && [ "$oldstyle2" != "" ]; then
		# backwards compatible with old style locked file
		_scaletempo_flag=$oldstyle2
	fi
	if [ "$(is_num "$_edo")" != "1" ] || [ "$_edo" -le "0" ]; then
		return 1
	else
		INTERVAL_LOWER_LIMIT=$(bc <<<"$_edo*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$_edo*2.1")
	fi
	if [ "$(is_num "$_int")" != "1" ] || [ "$(bc <<<"$_int < -$INTERVAL_LOWER_LIMIT")" == "1" ] || [ "$(bc <<<"$_int > $INTERVAL_UPPER_LIMIT")" == "1" ]; then
		return 1
	fi
	INTERVAL=$_int
	EDO=$_edo
}

reset_to_locked() {
	if [ -e "$FILENAME.locked" ]; then
		read_locked_file "$(<"$FILENAME.locked")"
		LOCKED=true

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		
		if [ "$EQUALIZER" == "" ]; then
			EQUALIZER="$DEFAULT_EQUALIZER"
			equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
			equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
			equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"
		else
			if [ "$EQUALIZER" != "0:0:0:0:0:0:0:0:0:0" ]; then
				echo -e "af_del equalizer" >"$ALETHEIA/pipe$$" &
				echo -e "af_add equalizer=$EQUALIZER" >"$ALETHEIA/pipe$$" &

				equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
				equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
				equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"
			fi
		fi

		if [ "$_scaletempo_flag" == "" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "0" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "1" ]; then
			SCALETEMPO=true
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "2" ]; then
			SCALETEMPO=true
			ONLY_PITCH=true
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		fi
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		sleep $MPLAYER_WAIT_TIME
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	else
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$DEFAULT_EDO"
		INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
		echo "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		VOLUME="$DEFAULT_VOLUME"
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	gtts_speak "tuning reset"
	draw_equalizer
	draw_volume
	draw_pitch
	draw_position
}

set_custom_edo() {
	draw_banner "EDO" false false true
	gtts_speak "enter e d o"
	tput rc
	read -rn1 new_edo
	if [ "$(is_num "$new_edo")" == "1" ]; then
		new_edo="$(read_line "$new_edo" true)"
		if [ "$?" == "1" ]; then
			gtts_speak_chain "invalid number" "main screen" &
			draw_pitch
			return
		fi
	else
		gtts_speak_chain "invalid number" "main screen" &
		draw_pitch
		redraw_buffer
		return
	fi

	reset_buffer
	if [ "$new_edo" == "" ]; then
		gtts_speak "closed"
		draw_pitch
		redraw_buffer
		return
	fi

	if [ "$(is_num "$new_edo")" != "0" ]; then
		PAUSE=false
		if [ "$new_edo" -lt "1" ]; then
			return
		fi
		if [ "$new_edo" -gt "$EDO" ]; then
			temp="$(calc -pd "$new_edo/$EDO")"
			INTERVAL="$(calc -pd " $INTERVAL*$temp")"
			INTERVAL="${INTERVAL%%.*}"
		elif [ "$new_edo" -lt "$EDO" ]; then
			temp="$(calc -pd "$EDO/$new_edo")"
			INTERVAL="$(calc -pd " $INTERVAL/$temp")"
			INTERVAL="${INTERVAL%%.*}"
		else
			draw_pitch
			if [ "$1" != true ]; then
				draw_position
			fi
			return
		fi

		gtts_speak_chain "$INTERVAL" "$new_edo" &

		EDO="$new_edo"
		LOCKED_EDO="$EDO"
		INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		LOCKED=false
		draw_volume
		draw_equalizer
		redraw_buffer
		draw_pitch
		if [ "$1" != true ]; then
			draw_position
		fi
	fi
}

double_precise() {
	if [ "$EDO" -lt "$EDO_LIMIT" ]; then
		INTERVAL=$((INTERVAL * 2))
		EDO=$((EDO*2))
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
		gtts_speak "$EDO"
	else
		gtts_speak "limit"
	fi
}

half_precise() {
	old="$(calc -pd "($INTERVAL/$EDO)")"
	if [ "$((EDO % 2))" == "0" ]; then
		new_edo="$((EDO/2))"
		if [ "$new_edo" -ge "2" ]; then
			temp="$(calc -pd "$new_edo/$EDO")"
			INTERVAL="$(calc -pd " $INTERVAL*$temp")"
			INTERVAL="${INTERVAL%%.*}"
			if [ "$(is_num "$INTERVAL")" == "0" ]; then
				INTERVAL=0
			fi
			EDO="$new_edo"
			new="$(calc -pd "($INTERVAL/$EDO)")"
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
			INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
			gtts_speak "$EDO"
		else
			gtts_speak "limit"
		fi
		if [ "$old" != "$new" ]; then
			LOCKED=false
		fi
		draw_pitch
	fi
}

pitch_down() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" != true ]; then
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -gt "-${INTERVAL_LOWER_LIMIT%.*}" ]; then
		INTERVAL=$((INTERVAL-1))
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" != true ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

pitch_up() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then 
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" != true ]; then 
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -lt "${INTERVAL_UPPER_LIMIT%.*}" ]; then
		INTERVAL=$((INTERVAL+1))
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" != true ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

edo_down() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -gt "1" ]; then
		EDO=$((EDO-1))
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
		if [ "$(bc <<<"$INTERVAL > $INTERVAL_UPPER_LIMIT || $INTERVAL < -$INTERVAL_LOWER_LIMIT")" == "1" ]; then
			if [ "${INTERVAL:0:1}" == "-" ]; then
				INTERVAL=-${INTERVAL_LOWER_LIMIT%%.*}
			else
				INTERVAL=${INTERVAL_UPPER_LIMIT%%.*}
			fi
		fi

		LOCKED=false
		draw_pitch 2
	else
		gtts_speak "limit"
	fi

	return 200
}

set_default_edo() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	new_edo="$DEFAULT_EDO"
	if [ "$new_edo" -gt "$EDO" ]; then
		temp="$(calc -pd "$new_edo/$EDO")"
		INTERVAL="$(calc -pd " $INTERVAL*$temp")"
		INTERVAL="${INTERVAL%%.*}"
	elif [ "$new_edo" -lt "$EDO" ]; then
		temp="$(calc -pd "$EDO/$new_edo")"
		INTERVAL="$(calc -pd " $INTERVAL/$temp")"
		INTERVAL="${INTERVAL%%.*}"
	fi
	EDO="$new_edo"
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
	echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	LOCKED=false
	draw_pitch 1
	gtts_speak "$EDO"
}

edo_up() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -lt "2000000" ]; then
		EDO=$((EDO+1))
		echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
		INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")

		if [ "$(bc <<<"$INTERVAL > $INTERVAL_UPPER_LIMIT || $INTERVAL < -$INTERVAL_LOWER_LIMIT")" == "1" ]; then
			if [ "${INTERVAL:0:1}" == "-" ]; then
				INTERVAL=-${INTERVAL_LOWER_LIMIT%%.*}
			else
				INTERVAL=${INTERVAL_UPPER_LIMIT%%.*}
			fi
		fi
		LOCKED=false
		draw_pitch 2
	else
		gtts_speak "limit"
	fi

	return 200
}

toggle_scale_tempo() {
	if [ "$SCALETEMPO" == false ]; then
		echo -e "af_add scaletempo" >"$ALETHEIA/pipe$$" &
		gtts_speak "tempo"
		SCALETEMPO=true
		ONLY_PITCH=false
	else
		if [ "$ONLY_PITCH" == false ]; then
			ONLY_PITCH=true
			gtts_speak "pitch"
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep $MPLAYER_WAIT_TIME
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		else
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			gtts_speak "pitch and tempo"
			SCALETEMPO=false
			ONLY_PITCH=false
		fi
	fi
	if [ "$PAUSE" == true ]; then
		PAUSE=false
	fi
	draw_pitch 3
}

secondary_scale_func() {
	if [ "$1" == "v" ]; then
		toggle_scale_tempo
	elif [ "$1" == "j" ]; then
		pitch_down
	elif [ "$1" == "k" ]; then
		pitch_up
	elif [ "$1" == "l" ]; then
		gtts_speak "forward"
		echo "seek +5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "h" ]; then
		gtts_speak "backward"
		echo "seek -5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "8" ]; then
		system_volume_change false 3 3
	elif [ "$1" == "9" ]; then
		system_volume_change true 3 3
	elif [ "$1" == "*" ]; then
		system_volume_change false 1 1
	elif [ "$1" == "(" ]; then
		system_volume_change true 1 1
	elif [ "$1" == "I" ]; then
		read_corner
		gtts_speak "scaling"
	elif [ "$1" == "H" ]; then
		less_precise
	elif [ "$1" == "L" ]; then
		more_precise
	elif [ "$1" == "o" ]; then
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			mute=false
			draw_pitch
		fi
		double_precise
	elif [ "$1" == "m" ]; then
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			mute=false
			draw_pitch
		fi
		half_precise				
	elif [ "$1" == "M" ]; then
		invert_int
	elif [ "$1" == "a" ]; then
		PAUSE=false
		draw_banner "$2" false true
		set_equalizer
		draw_banner "$2" false true
	elif [ "$1" == "y" ]; then
		set_default_edo
	elif [ "$1" == "!" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "@" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "1" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "2" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "p" ]; then
		toggle_pause
		draw_banner "$2" false true
		if [ "$WEB_CLIENT" == "0" ]; then
			read -rn1 input_char
		else
			read -rn1 input_char <"$ALETHEIA/web_client_pipe$$"
		fi

		toggle_pause
		draw_banner "$2" false true
	elif [ "$1" == "" ]; then
		gtts_speak " $INTERVAL" false false true
	elif [ "$1" == "\\" ]; then
		echo "seek 0 2" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "f" ]; then
		draw_banner "$2" false true
		swap_lock true
		draw_pitch
		draw_banner "$2" false true
	elif [ "$1" == "F" ]; then
		draw_banner "$2" false true
		swap_lock
		draw_pitch
		draw_banner "$2" false true
	else
		process_key "$1"
		return
	fi
}

oscillate() {
	old_int="$INTERVAL"
	gtts_speak "oscillate"
	draw_banner "$(get_local_phrase "OSCILLATE")"
	tput rc
	read -rsn1 result
	if [ "$result" == "q" ] || [ "$result" == "G" ] || [ "$result" == $'\e' ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	elif [ "$result" != "" ]; then
		if [ "$result" == "-" ] || [ "$(is_num "$result")" == "1" ]; then
			result="$(read_line "$result")"
		else
			gtts_speak "closed" true
			draw_pitch
			draw_position
			return
		fi
	fi

	if [ "$(is_num "$result")" != "1" ] && [ "$result" != "" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi

	if [ "$result" != "" ]; then
		if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			if [ "$INTERVAL" -lt "$result" ]; then
				NEGATIVE=true
			else
				NEGATIVE=false
			fi
			abs_int=${INTERVAL#-}
			abs_result=${result#-}
			if [ "$abs_int" -gt "$abs_result" ]; then
				result="$(echo -e "$abs_int - $abs_result" | bc)"
			elif [ "$abs_int" -lt "$abs_result" ]; then
				result="$(echo -e "$abs_result - $abs_int" | bc)"
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -gt "0" ]; then
			if [ "$INTERVAL" -gt "$result" ]; then
				result="$(echo -e "$INTERVAL - $result" | bc)"
				NEGATIVE=false
			elif [ "$INTERVAL" -lt "$result" ]; then
				result="$(echo -e "$result - $INTERVAL" | bc)"
				NEGATIVE=true
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -lt "0" ]; then
			abs_result=${result#-}
			result="$(echo -e "$abs_result + $INTERVAL" | bc)"
			NEGATIVE=false
		elif [ "$INTERVAL" -lt "0" ] && [ "$result" -gt "0" ]; then
			abs_int=${INTERVAL#-}
			result="$(echo -e "$result + $abs_int" | bc)"
			NEGATIVE=true
		elif [ "$INTERVAL" == "0" ] || [ "$result" == "0" ]; then
			if [ "$INTERVAL" == "0" ] && [ "$result" == "0" ]; then
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			elif [ "$INTERVAL" == "0" ]; then
				if [ "$result" -lt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				result="$(calc -pd "abs($result)")"
			elif [ "$result" == "0" ]; then
				if [ "$INTERVAL" -lt "0" ]; then
					NEGATIVE=true
				else
					NEGATIVE=false
				fi
				result="$(calc -pd "abs($INTERVAL)")"
			fi
		fi
	fi
	if [ "$result" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi
	if [ "$INTERVAL" == "0" ] && [ "$result" == "" ]; then
		gtts_speak "can't oscillate; interval at zero"
		draw_pitch
		draw_position
		return
	fi
	draw_banner "$(get_local_phrase "OSCILLATE")" false true
	gtts_speak "oscillating"
	if [ "$result" == "" ]; then
		old_int="$INTERVAL"
		INTERVAL="$((-(INTERVAL)))"
		if [ "$INTERVAL" -lt "0" ]; then
			result="$old_int"
		else
			result="$INTERVAL"
		fi
		result="$((result*2))"
		if [ "$old_int" -gt "0" ]; then
			NEGATIVE=false
		else
			NEGATIVE=true
		fi
	fi
	x=0

	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$x" -lt "$result" ]; do
		read -rsn1 -t "$SCALE_SPEED" c
		ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "o" ]; then
			old_int=$((old_int*2))
			if [ "$EDO" -lt "$EDO_LIMIT" ]; then
				x=$((x*2))
				result=$((result*2))
			fi
		elif [ "$c" == "m" ]; then
			if [ "$((EDO % 2))" == "0" ]; then
				old_int=$((old_int/2))
				x=$((x/2))
				result=$((result/2))
			fi
		fi
		secondary_scale_func "$c" "$(get_local_phrase "OSCILLATE")"
		if [ "$c" == "c" ]; then
			x=$((result-x-2))
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
		elif [ "$c" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "$(get_local_phrase "OSCILLATE")" false true
			redraw_screen false 1 1 1 0
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_pitch
			draw_banner "$(get_local_phrase "OSCILLATE")" false true
		elif [ "$c" == "q" ] || [ "$c" == $'\e' ]; then
			break
		elif [ "$c" == "" ]; then
			if [ "$NEGATIVE" == false ]; then
				INTERVAL="$((old_int-1))"
				old_int="$((old_int-1))"
			else
				INTERVAL="$((old_int+1))"
				old_int="$((old_int+1))"
			fi
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			x="$((x+1))"
		fi

		if [ "$x" == "$result" ]; then
			x=0
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch
				draw_position
				return
			fi
			if [ "$c" == "o" ]; then
				old_int=$((old_int*2))
				if [ "$EDO" -lt "$EDO_LIMIT" ]; then
					x=$((x*2))
					result=$((result*2))
				fi
			elif [ "$c" == "m" ]; then
				if [ "$((EDO % 2))" == "0" ]; then
					old_int=$((old_int/2))
					x=$((x/2))
					result=$((result/2))
				fi
			fi
			secondary_scale_func "$c" "$(get_local_phrase "OSCILLATE")"
			if [ "$c" == "c" ]; then
				x=$((result-x-2))
				if [ "$NEGATIVE" == true ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
			elif [ "$c" == "H" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "L" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				draw_banner "$(get_local_phrase "OSCILLATE")" false true
				redraw_screen false 1 1 1 0
			elif [ "$c" == "q" ] || [ "$c" == $'\e' ]; then
				break
			elif [ "$c" == "" ]; then
				echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			fi
		fi

	done
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

pcm_volume_change() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	if [ "$1" == "1" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$(bc <<<"$VOLUME >= 5")" == "1" ]; then
			VOLUME="$(bc <<<"$VOLUME-5")"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		else
			VOLUME=0
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "2" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$(bc <<<"$VOLUME <= 95")" == "1" ]; then
			VOLUME="$(bc <<<"$VOLUME+5")"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		else
			VOLUME=100
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "!" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$(bc <<<"$VOLUME >= 0.25")" == "1" ]; then
			if [[ "$VOLUME" =~ .*\..* ]]; then
				VOLUME="${VOLUME%.*}"
			else
				VOLUME="$(bc <<<"$VOLUME-1")"
			fi
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "@" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$(bc <<<"$VOLUME <= 99.75")" == "1" ]; then
			if [[ "$VOLUME" =~ .*\..* ]]; then
				VOLUME="$(bc <<<"$VOLUME+1")"
				VOLUME="${VOLUME%.*}"
			else
				VOLUME="$(bc <<<"$VOLUME+1")"
			fi
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	fi
	read -rn1 -t 0.1 key
	if [ "$key" != "" ]; then
		if [ "$key" == "1" ] || [ "$key" == "2" ] || [ "$key" == "!" ] || [ "$key" == "@" ]; then
			pcm_volume_change "$1"
			ret="$?"
			if [ "$ret" != "200" ]; then
				return $ret
			fi
		fi
	fi
	return 200
}

if [ "$(pgrep -c aletheia)" -gt "1" ]; then
	VOLUME="0"
fi

set_system_volume() {
	if [ "$1" == true ]; then
		dir="+"
	else
		dir="-"
	fi
	pactl set-sink-volume @DEFAULT_SINK@ "${dir}$2%" "${dir}$3%" >/dev/null 2>/dev/null
}

system_volume_change() {
	local raise_volume=$1
	local left_adjustment=$2
	local right_adjustment=$3

	get_system_volume
	leftvolume=${SYSTEM_VOLUME_LEFT%\%}
	rightvolume=${SYSTEM_VOLUME_RIGHT%\%}

	if [ -z "$leftvolume" ]; then
		leftvolume=0
	fi
	if [ -z "$rightvolume" ]; then
		rightvolume=0
	fi

	pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null

	if [ "$raise_volume" == true ]; then
		if [ "$((leftvolume + left_adjustment))" -gt "$LIMIT_MASTER_VOLUME" ]; then
			left_adjustment=$((LIMIT_MASTER_VOLUME - leftvolume))
		fi
		if [ "$((rightvolume + right_adjustment))" -gt "$LIMIT_MASTER_VOLUME" ]; then
			right_adjustment=$((LIMIT_MASTER_VOLUME - rightvolume))
		fi

		if [ "$((leftvolume + left_adjustment))" -le "$LIMIT_MASTER_VOLUME" ] && [ "$((rightvolume + right_adjustment))" -le "$LIMIT_MASTER_VOLUME" ]; then
			set_system_volume true "$left_adjustment" "$right_adjustment"
		fi
	else
		if [ $((leftvolume - left_adjustment)) -lt 1 ]; then
			left_adjustment=$((leftvolume - 1))
		fi
		if [ $((rightvolume - right_adjustment)) -lt 1 ]; then
			right_adjustment=$((rightvolume - 1))
		fi

		if [ $((leftvolume - left_adjustment)) -ge 1 ] && [ $((rightvolume - right_adjustment)) -ge 1 ]; then
			set_system_volume false "$left_adjustment" "$right_adjustment"
		fi
	fi

	get_system_volume
	draw_volume 2 3
}

fade_volume() {
	inputchar=""
	_input=
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		inputchar="$_input"
	fi
	draw_banner "$(get_local_phrase "FADE")"
	gtts_speak "select direction to fade"
	PAUSE=false
	MUTE=false
	x=0
	local pause=false
	if [ ! -e "$ALETHEIA/fade" ]; then
		touch "$ALETHEIA/fade"
		while true; do
			read -rsn1 -t 0.01 inputchar
			if [ -n "$inputchar" ]; then
				rm -f "$ALETHEIA/fade"
				break
			fi
			if [ ! -e "$ALETHEIA/fade" ]; then
				inputchar="j"
				pause=true
				break
			fi
		done
	else
		rm -f "$ALETHEIA/fade"
		inputchar="k"
	fi

	down=false
	up=false
	if [ "$inputchar" == "j" ]; then
		down=true
		gtts_speak "down"
	elif [ "$inputchar" == "k" ]; then
		up=true
		gtts_speak "up"
	else
		gtts_speak "closed" true
		draw_pitch
		return
	fi

	if [ "$down" == true ] && [ "$VOLUME" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	if [ "$up" == true ] && [ "$VOLUME" == "100" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	c=
	while [ "$(bc <<<"$VOLUME >= 0")" == "1" ] && [ "$(bc <<<"$VOLUME <= 100")" == "1" ]; do
		if [ "$c" != "j" ] && [ "$c" != "k" ]; then
			if [ "$up" == true ]; then
				if [ "$VOLUME" == "100" ]; then
					draw_pitch
					return
				fi
				if [ "$(bc <<<"$VOLUME+0.5 <= 100")" == "1" ]; then
					if [ "$(bc <<<"$VOLUME <= 7")" == "1" ]; then
						VOLUME="$(calc -pd "$VOLUME+0.25")"
					elif [ "$(bc <<<"$VOLUME <= 14")" == "1" ]; then
						VOLUME="$(calc -pd "$VOLUME+0.50")"
					else
						VOLUME="$(calc -pd "$VOLUME+2")"
						VOLUME="${VOLUME%.*}"
					fi
				else
					draw_pitch
					return
				fi
			elif [ "$down" == true ]; then
				if [ "$VOLUME" == "0" ]; then
					if [ "$pause" == true ]; then
						break
					fi
					draw_pitch
					return
				fi
				if [ "$(bc <<<"$VOLUME-0.25 >= 0")" == "1" ]; then
					if [ "$(bc <<<"$VOLUME <= 7")" == "1" ]; then
						VOLUME="$(calc -pd "$VOLUME-0.25")"
					elif [ "$(bc <<<"$VOLUME <= 14")" == "1" ]; then
						VOLUME="$(calc -pd "$VOLUME-0.50")"
					else
						VOLUME="$(calc -pd "$VOLUME-2")"
						VOLUME="${VOLUME%.*}"
					fi
				fi
			fi
			if [ "$(bc <<<"$VOLUME > 100")" == "1" ]; then
				VOLUME=100
			elif [ "$(bc <<<"$VOLUME < 0")" == "1" ]; then
				VOLUME=0
			fi
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		fi
		draw_volume
		if [ "$up" == true ]; then
			if [ "$(bc <<<"$VOLUME > 15")" == "1" ]; then
				read -rsn1 -t 0.23 c
			else
				read -rsn1 -t 0.13 c
			fi
		elif [ "$down" == true ]; then
			if [ "$(bc <<<"$VOLUME < 5")" == "1" ]; then
				read -rsn1 -t 0.23 c
			else
				read -rsn1 -t 0.13 c
			fi
		fi
		if [ "$c" == "8" ]; then
			system_volume_change false 3 3
		elif [ "$c" == "9" ]; then
			system_volume_change true 3 3
		elif [ "$c" == "j" ]; then
			pitch_down
			ret=$?
			if [ "$OUTPUT" != "" ]; then
				input=$OUTPUT
			fi
			if [ "$ret" != "200" ]; then
				return $ret
			fi
		elif [ "$c" == "k" ]; then
			pitch_up
			ret=$?
			if [ "$OUTPUT" != "" ]; then
				input=$OUTPUT
			fi
			if [ "$ret" != "200" ]; then
				return $ret
			fi
		fi
		ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "q" ] || [ "$c" == $'\e' ] || [ "$c" == "3" ]; then
			if [ -e "$ALETHEIA/fade" ]; then
				rm -f "$ALETHEIA/fade"
			fi
			gtts_speak "closed" true
			draw_pitch
			break
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "$(get_local_phrase "FADE")"
		elif [ "$c" == "c" ]; then
			if [ "$down" == true ]; then
				down=false
				up=true
			else
				down=true
				up=false
			fi
			gtts_speak "order reversed"
		elif [ "$c" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "$(get_local_phrase "FADING")"
			redraw_screen false 1 1 0 1
		fi
		x=$((x+1))
	done
	if [ "$down" == true ] && [ "$pause" == true ]; then
		toggle_pause true
		draw_banner "$(get_local_phrase "PAUSE")"
	else
		draw_pitch
	fi
	redraw_buffer
}

sleep_countdown() {
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 -t "$(echo "$1 * 60" | bc)" tmp
	else
		read -rsn1 -t "$(echo "$1 * 60" | bc)" tmp <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$tmp" != "" ]; then
		gtts_speak_chain "sleep canceled" "main screen" &
		echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "$(get_local_phrase "CANCELED")"
		sleep $BANNER_WAIT_TIME
		draw_pitch
		return
	fi
	if [ "$SLEEPING" == true ]; then
		SLEEPING=false
		draw_banner "$(get_local_phrase "SLEEPING")"
		x="$VOLUME"
		while [ "$x" -ge "0" ] && [ "$VOLUME" -gt "0" ]; do
			VOLUME="$((VOLUME-1))"
			echo "volume $x 1" >"$ALETHEIA/pipe$$" &
			draw_volume
			if [ "$WEB_CLIENT" == "0" ]; then
				read -rsn1 -t 0.7 tmp
			else
				read -rsn1 -t 0.7 tmp <"$ALETHEIA/web_client_pipe$$"
			fi
			if [ "$tmp" != "" ]; then
				echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
				return
			fi
			x=$((x-1))
		done

		kill "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$SUSPEND" == true ]; then
			systemctl suspend
		fi
		exit 0
	fi
}

set_sleep() {
	if [ "$WEB_CLIENT" == "0" ]; then
		draw_banner "$(get_local_phrase "MINUTES")"
		gtts_speak "enter time to sleep, in minutes"
		answer="$(read_line)"
	else
		answer="180"
	fi

	if [ "$answer" != "" ]; then
		if [ "$(is_num "$answer")" != "0" ]; then
			SLEEPING=true
			if [ "$WEB_CLIENT" == "0" ]; then
				gtts_speak "do you want to suspend?"
				draw_banner "$(get_local_phrase "SUSPEND")" true
				read -rsn1 suspend
			else
				suspend="y"
			fi
		
			if [ "$suspend" == "y" ] || [ "$suspend" == "Y" ]; then
				SUSPEND=true
			elif [ "$suspend" == "q" ] || [ "$suspend" == $'\e' ] || [ "$suspend" == "~" ]; then
				gtts_speak_chain "sleep canceled" "main screen" &
				draw_pitch
				draw_position
				return
			else
				SUSPEND=false
			fi

			if [ "$SUSPEND" == true ]; then
				draw_banner "$(get_local_phrase "SUSPEND") ${answer}"
				draw_position
				gtts_speak "suspending in" true false
			else
				draw_banner "$(get_local_phrase "SLEEP") ${answer}"
				draw_position
				gtts_speak "sleeping in" true false
			fi
			gtts_speak "$answer" true false
			if [ "$answer" == "1" ]; then
				gtts_speak "minute"
			else
				gtts_speak "minutes"
			fi
			PAUSE=false
			if [ "$MUTE" == true ]; then
				echo "mute" >"$ALETHEIA/pipe$$" &
				MUTE=false
			fi
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_position
			sleep_countdown "$answer"
			draw_pitch
			draw_position
		else
			gtts_speak_chain "sleep canceled" "main screen" &
			draw_pitch
			draw_position
		fi
	else
		gtts_speak_chain "sleep canceled" "main screen" &
		draw_pitch
		redraw_buffer
	fi
}

read_line() {
	first_char=$1
	only_numbers=$2

	IFS=$'\n'
	line=""
	stty -echo
		
	if [ "$first_char" != "" ]; then
		x="$1"
	else
		read -rn1 x
	fi
	if [ "$x" == "" ]; then
		unset IFS
		return
	elif [ "$x" == $'\e' ]; then
		unset IFS
		return
	fi
	if [ "$only_numbers" == true ] && [ "$x" != "" ] && [ "$x" != "-" ]; then
		if [ "$(is_num "$x")" == "0" ]; then
			unset IFS
			return 1
		fi
	fi

	echo -ne "$x" >/dev/stderr
	if [ "$VOICE_ENABLED" == true ]; then
		if [ "$x" == "-" ]; then
			gtts_speak "negative"
		elif [ "$x" == "." ]; then
			gtts_speak "point"
		else
			gtts_speak " $x"
		fi
	fi


	if [ "$x" != $'\x7F' ]; then
		line="$x"
	fi

	read -rn1 x
	while [ -n "$x" ]; do
		if [ "$only_numbers" == true ] && [ "$x" != "" ] && [ "$x" != $'\x7F' ]; then
			if [ "$(is_num "$x")" == "0" ]; then
				unset IFS
				return 1
			fi
		fi
		if [ "$x" == $'\e' ]; then
			unset IFS
			return
		elif [ "$x" == $'\x7F' ]; then
			if [ "${#line}" -lt "1" ]; then
				read -rn1 x
				continue
			fi
			line="$(echo "${line}" | rev | cut -c2- | rev)"
			echo -ne "\b \b" >/dev/stderr
			read -rn1 x
			continue
		elif [ "$x" == "" ]; then
			echo -n "$line"
			unset IFS
			return
		else
			line="$line$x"
		fi

		echo -ne "$x" >/dev/stderr
		if [ "$VOICE_ENABLED" == true ]; then
			if [ "$x" == "-" ]; then
				gtts_speak "negative"
			elif [ "$x" == "." ]; then
				gtts_speak "point"
			else
				gtts_speak " $x"
			fi
		fi
		read -rn1 x
		if [ "$only_numbers" == true ] && [ "$x" != "" ]; then
			if [ "$(is_num "$x")" == "0" ]; then
				unset IFS
				return 1
			fi
		fi
	done

	unset IFS
	echo -n "$line"
}

read_number() {
	stty -echo
	number="0"
	echo -ne "$number" >/dev/stderr
	read -rn1 x
	if [ "$x" == $'\e' ]; then
		return
	fi
	while [ -n "$x" ]; do
		if [ "$x" == "j" ]; then
			if [ "$number" -gt "-12" ]; then
				for i in $(seq 1 ${#number}); do
					echo -ne "\b" >/dev/stderr
					if [ "$number" == "10" ]; then
						echo -ne " \b" >/dev/stderr
					fi
				done
				number="$((number-1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "k" ]; then
			if [ "$number" -lt "12" ]; then
				for i in $(seq 1 ${#number}); do
					echo -ne "\b" >/dev/stderr
					if [ "$number" == "-10" ] || [ "$number" == "-1" ]; then
						echo -ne " \b" >/dev/stderr
					fi
				done
				number="$((number+1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "-" ]; then
			for i in $(seq 1 ${#number}); do
				echo -ne "\b" >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			if [ "$VOICE_ENABLED" == true ]; then
				gtts_speak " $x"
			fi
			tmp="$(read_line)"
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$tmp" == "" ]; then
				echo -ne ""
				return
			fi
			if [ "$(is_num "$tmp")" != "0" ]; then
				echo -ne "-$tmp"
				return
			fi
		elif [ "$(is_num "$x")" != "0" ]; then
			for i in $(seq 1 ${#number}); do
				echo -ne "\b" >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			gtts_speak " $x"
			tmp=""
			if [ "$tmp" == "" ]; then
				echo -ne "$x"
				return
			elif [ "$(is_num "$tmp")" != "0" ]; then
				echo -ne "$x$tmp"
				return
			fi
		elif [ "$x" == $'\e' ]; then
			echo -e ""
			return
		elif [ "$x" == "q" ]; then
			echo -e ""
			return
		elif [ "$x" == "" ]; then
			break
		fi
		read -rsn1 x
	done
	echo -ne "$number"
	return
}

reset_dimensions() {
	if [ "$LINES" != "$old_LINES" ] || [ "$COLUMNS" != "$old_COLUMNS" ]; then
		DIMENSIONS_RESET=true
	fi
	render_all_help_screens
}

redraw_screen() {
	reset_buffer

	if [ "$2" == "" ]; then
		draw_volume
		draw_equalizer
		draw_pitch
		draw_position
	else
		if [ "$2" == "1" ]; then
			draw_volume
		fi
		if [ "$3" == "1" ]; then
			draw_equalizer
		fi
		if [ "$4" == "1" ]; then
			draw_pitch
		fi
		if [ "$5" == "1" ]; then
			draw_position
		fi
	fi

	redraw_buffer
	if [ "$NO_VERTICAL_PADDING" == false ]; then
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
	fi
}

reset_buffer() {
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi
	original_number_per_page="$number_per_page"

	BUFFER=""

	HALF="$((POSITION % number_per_page + (number_per_page/2 + 1)))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		HALF="1"
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
		number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$((number_per_page*2 - 1))" ]; then
		HALF="$((POSITION-original_number_per_page/2))"
	fi

	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
		number_per_page="$TOTAL_QUEUE"
		FLAGGED=true
	fi

	half_page="$((number_per_page/2))"

	if [ "$POSITION" -gt "$half_page" ]; then
		if [ "$((number_per_page % 2))" != "" ]; then
			HALF=$((POSITION-half_page))
		else
			HALF=$((1+POSITION-half_page))
		fi

		if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$((TOTAL_QUEUE-number_per_page+1))"
		fi
	fi

	HALF_OFFSET="0"
	if [ "$HALF" -lt "1" ]; then
		HALF_OFFSET="$((HALF*-1)) - 1"
		HALF="1"
	fi

	pos_on_page=0
	_last=$((HALF+number_per_page-HALF_OFFSET))
	diff=$((_last-HALF))
	if [ "$TOTAL_QUEUE" -lt "$diff" ]; then
		diff="$TOTAL_QUEUE"
	fi

	for i in $(seq 1 "$diff"); do
		pos=$((i-1+HALF))
		new_line="${queue_array[i+HALF-2]}"
		orig_line="$new_line"

		ext=${orig_line##*.}
		filename_without_ext=${orig_line%%.*}

		_REP="$WHITE"
		if [ "$pos" == "$POSITION" ]; then
			if [ "$PANELS_ENABLED" == true ]; then
				_REP="$WHITE_BLACK"
			fi
			get_metadata "$pos" true >/dev/null
		else
			get_metadata "$pos" >/dev/null
		fi

		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			if [ "$pos" == "$POSITION" ] && [ "$PANELS_ENABLED" ]; then
				REP="$BLUE_BLACK"
			else
				REP="$BLUE"
			fi
		else
			REP=""
		fi

		if [ -e "$orig_line.locked" ]; then
			if [ -e "$orig_line.repeats" ]; then
				INDICATOR="${_REP}$REP#"
			else
				INDICATOR="${_REP}$"
			fi
		else
			if [ -e "$orig_line.repeats" ]; then
				INDICATOR="${_REP}$REP&"
			else
				INDICATOR="${_REP} "
			fi
		fi
		
		if (( pos < 10 && TOTAL_QUEUE > 9 )); then
			pad="0"
			display_pad=" "
		else
			pad=""
			display_pad=""
		fi

		pos_on_page=$((pos_on_page+1))
		offset="$((COLUMNS - 11 - ${#pos} - ${#pad}))"
		if [ "${#line}" -gt "$offset" ]; then
			line="${line## .*}"
			line="${line:0:$((offset-1))}"
		fi
		#if [[ "$line" == *" - "* ]]; then
		#	first_part="${line%% - *}"
		#	second_part="${line##* - }"
		#	combined=false
		#else
		#	combined=true
		#fi

		#if [ "$combined" == false ]; then
		#	line="$first_part - $second_part"
		#fi

		if [ "$SONG_LENGTH" == "" ]; then
			if [ "$pos" == "$POSITION" ]; then
				time=$(ffprobe -i "$orig_line" -show_entries format=duration -v quiet -of csv="p=0" | cut -d'.' -f1)
				SONG_LENGTH="$(date -u -d @"$time" +%H:%M:%S)"
				IFS=':' read -r hours minutes seconds <<< "$SONG_LENGTH"
			else
				APPEND=""
				APPEND_BLACK=""
				hours="00"
				minutes="--"
				seconds="--"
			fi
		else
			SONG_LENGTH="$(date -u -d @"$SONG_LENGTH" +%H:%M:%S)"
			IFS=':' read -r hours minutes seconds <<< "$SONG_LENGTH"
		fi
		if [ "$hours" != "00" ]; then
			buf_space="$(printf '%*s' $((COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-8)) "")"
			APPEND_BLACK="${BLUE_BLACK}$hours${WHITE_BLACK}:${BLUE_BLACK}"
			APPEND="${BLUE}$hours${WHITE}:$BLUE"
		else
			buf_space="$(printf '%*s' $((COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-5)) "")"
			APPEND=""
			APPEND_BLACK=""
		fi
		if [ "$(echo -ne "$line" | grep $'\e')" != "" ]; then
			if [ "$pos" == "$POSITION" ] && [ "$PANELS_ENABLED" == true ]; then
				line=$(echo -ne "$line" | sed "s|^|\\$BLUE_BLACK|g;s||~|g")
			else
				if [ "$pos" == "$POSITION" ] && [ "$PANELS_ENABLED" == false ]; then
					line=$(echo -ne "$line" | sed "s|^|\\$BLUE_BLACK|g;s||~|g")
				else
					line=$(echo -ne "$line" | sed "s|^|\\$WHITE|g;s||~|g;s|$|\\${BLUE}|g")
				fi
			fi
		fi

		if [ "$PANELS_ENABLED" == true ] && [ "$pos" == "$POSITION" ]; then
			BUFFER="$BUFFER$BLUE_BLACK$PADDING$BLUE_BLACK$INDICATOR$BLUE_BLACK $BLUE_BLACK$display_pad$BLUE_BLACK$pos $line$buf_space$APPEND_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING$NOCOLOR\n"
			LOCKING_POS="$((i-1))"
		else
			if [ "$PANELS_ENABLED" == false ]; then
				if [ "$pos" == "$POSITION" ]; then
					BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $BLUE$display_pad$BLUE$pos $line$buf_space$APPEND$BLUE$minutes$WHITE:$BLUE$seconds$PADDING\n"
					LOCKING_POS="$((i-1))"
				else
					BUFFER="$BUFFER$PADDING$WHITE$INDICATOR $BLUE$display_pad$BLUE$pos $WHITE$line$buf_space$APPEND$BLUE$minutes$WHITE:$BLUE$seconds$PADDING\n"
				fi
			else
				BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $display_pad$BLUE$pos$NOCOLOR $WHITE$line$buf_space$APPEND$BLUE$minutes$WHITE:$BLUE$seconds$PADDING\n"
			fi
		fi
	done
}

redraw_buffer() {
	echo -ne "$NOCOLOR"
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup 1
	else
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
		tput cup 2
	fi
	echo -ne "$BUFFER"

	if [ "$number_per_page" -lt "$TOTAL_QUEUE" ]; then
		number_per_page=$TOTAL_QUEUE
	fi

	if [ "$NO_VERTICAL_PADDING" == false ]; then
		if [ "$((COLUMNS-TOTAL_QUEUE-4))" -gt "0" ]; then
			empty_pane $((2+TOTAL_QUEUE))
		fi
	else
		if [ "$((COLUMNS-TOTAL_QUEUE-2))" -gt "0" ]; then
			empty_pane $((1+TOTAL_QUEUE))
		fi
	fi

	tput cup $((LINES-2))
}

empty_pane() {
	tput civis
	stty -ixon
	lineno=$1
	stop=$2
	pane=$((LINES-2))

	if [ -n "$stop" ]; then
		pane=$stop
	fi

	if [ "$NO_VERTICAL_PADDING" == false ]; then
		tput cup 1
		tput el
		tput cup "$pane"
		tput el
	fi

	if [ "$lineno" == "" ]; then
		lineno="1"
	fi

	for (( i=lineno; i <= pane; i++ )); do
		tput cup "$i"
		tput el
	done
}

draw_volume() {
	tput cup 0

	tmp_volume_left=${SYSTEM_VOLUME_LEFT%\%}
	tmp_volume_right=${SYSTEM_VOLUME_RIGHT%\%}
	if [ "$tmp_volume_left" == "" ]; then
		tmp_volume_left="0"
		tmp_volume_right="0"
	fi
	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	echo -ne "$NOCOLOR$BLUE_BLACK$PADDING$VOLUME$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_left$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_right"
	printf '%*s' $((COLUMNS - (${#CORNER_DIVIDER}*2) - ${#equal} -${#VOLUME} - (${#PADDING}*2) - ${#tmp_volume_left} - ${#tmp_volume_right})) ""
	echo -ne "$NOCOLOR"
}

draw_position() {
	RIGHT_BANNER_WIDTH=0
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
	tput cup $LINES $((COLUMNS-${#POSITION} - ${#TOTAL_QUEUE} - 1 - (${#CORNER_DIVIDER}*2) - ${#PADDING}))
	if [ "$LOOP" == true ]; then
		center="1"
	elif [ "$LOOP_ARTIST" == true ]; then
		center="2"
	elif [ "$TRACK_RANDOM" == true ]; then
		center="3"
	elif [ "$ONLY_LOCKED" == true ]; then
		center="4"
	else
		center="0"
	fi
	echo -ne "$BLUE_BLACK$POSITION$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$TOTAL_QUEUE$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$center$PADDING$NOCOLOR"
	return
}

toggle_panels() {
	if [ "$PANELS_ENABLED" == true ]; then
		gtts_speak "panels disabled"
		PANELS_ENABLED=false
		if [ "$THEME_ENABLED" == false ]; then
			BLUE_BLACK="${ESC}1;37m"
			WHITE_BLACK="${ESC}1;37m"
		else
			BLUE_BLACK="${BLUE}"
			WHITE_BLACK="${WHITE}"
		fi
	else
		gtts_speak "panels enabled"
		PANELS_ENABLED=true
		if [ "$THEME_ENABLED" == false ]; then
			BLUE_BLACK="${ESC}1;37;1;40m"
			WHITE_BLACK="${ESC}1;37;1;40m"
		else
			color="${COLOR_PANEL#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))
			BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
		fi
	fi
	reset_buffer
	draw_volume
	draw_equalizer
	if [ "$1" == true ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
}

invert_colors() {
	local orig_blue=$BLUE
	local orig_blue_black=$BLUE_BLACK
	BLUE=$WHITE
	WHITE=$orig_blue
	BLUE_BLACK=$WHITE_BLACK
	WHITE_BLACK=$orig_blue_black
	draw_wait false
	render_all_help_screens
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	gtts_speak "color inverted"
}

web_client_func() {
	if [ "$WEB_CLIENT" == "1" ]; then
		number_per_page="4"
		original_number_per_page="$number_per_page"

		BUFFER=""

		HALF="$((POSITION % number_per_page + (number_per_page/2 + 1)))"

		if [ "$POSITION" -lt "$number_per_page" ]; then
			HALF="1"
		elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
			number_per_page="$original_number_per_page"
		elif [ "$POSITION" -gt "$((number_per_page*2 - 1))" ]; then
			HALF="$((POSITION-original_number_per_page/2))"
		fi

		if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi

		half_page="$((number_per_page/2))"

		if [ "$POSITION" -gt "$half_page" ]; then
			if [ "$((number_per_page % 2))" != "" ]; then
				HALF=$((POSITION-half_page))
			else
				HALF=$((1+POSITION-half_page))
			fi

			if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				HALF="$((TOTAL_QUEUE-number_per_page+1))"
			fi
		fi

		HALF_OFFSET="0"
		if [ "$HALF" -lt "1" ]; then
			HALF_OFFSET="$((HALF * -1)) - 1"
			HALF="1"
		fi

		COLOR2="$BLUE"

		pos_on_page=0
		_last=$((HALF+number_per_page-HALF_OFFSET))
		if [ "$((_last-HALF))" -lt "5" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			if [ "$POSITION" == "$TOTAL_QUEUE" ] || [ "$POSITION" == "$((TOTAL_QUEUE-1))" ]; then
				HALF=$((_last-5))
			fi
		fi
		if [ "$HALF" == "1" ]; then
			HALF=2
			_last=$((_last+1))
		fi
		lines="$(printf '%s\n' "${queue_array[@]}" | sed -n "$((HALF-1)),$((_last-1))p")"
		diff=$((_last-HALF))
		if [ "$POSITION" -lt "3" ]; then
			pos=$POSITION
		else
			pos=2
		fi
		echo -ne "$lines" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/\n/<br\/>/g" >"$ALETHEIA/current_queue"
		if [ "$POSITION" -lt "3" ]; then
			pos=$((pos-1))
		elif [ "$POSITION" -gt "$((TOTAL_QUEUE-1))" ]; then
			pos=$((pos+1))
		fi
		if [ "$POSITION" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=4
		elif [ "$POSITION" == "$((TOTAL_QUEUE-1))" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=3
		fi
		echo -ne "$pos" >"$ALETHEIA/current_pos"
	fi
}

say_locked_and_loops() {
	if [ "$REPEAT_TOTAL" == "1" ]; then
		text="loop"
	else
		text="loops"
	fi
	gtts_speak_chain "locked" "$INTERVAL" "of" "$EDO" "and" "$REPEAT_TOTAL" "$text" &
}

say_unlocked_and_loops() {
	if [ "$REPEAT_TOTAL" == "1" ]; then
		text="loop"
	else
		text="loops"
	fi
	gtts_speak_chain "unlocked" "and" "$REPEAT_TOTAL" "$text" &
}

say_locked_and_no_loops() {
	gtts_speak_chain "locked" "$(echo -ne "$INTERVAL" | sed "s/\-/negative /g")" "of" "$EDO" "and" "no loops" &
}

say_unlocked_and_no_loops() {
	gtts_speak_chain "unlocked" "and" "no loops" &
}

jump_to_first_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | head -1 | cut -d':' -f1)"
	kill "$MPLAYER_PID" >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

jump_to_last_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | tail -1 | cut -d':' -f1)"
	kill "$MPLAYER_PID" >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

load_only_loops() {
	if [ "$LOOPS_ONLY" == false ] || [ "$1" == true ]; then
		draw_banner "$(get_local_phrase "WAIT")"
		artist="$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)"
		if [ "$LOOP_ARTIST" == true ]; then
			if [ "$(find "$MUSICDIR" | grep -e "^$artist - " | grep -e "\.repeats$")" == "" ]; then
				LOOP_ARTIST=false
			fi
		fi
		old_queue_array=("${queue_array[@]}")
		if [ "$ONLY_LOCKED" == true ]; then
			regex=".*\.\(${AUDIO_FORMATS//,/\.locked\\|}\.locked\)$"
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $(find "$MUSICDIR" -type f -regex "$regex" -and -not -iname "*.repeat.*" | sort); do
				var1="$(echo -ne "$i" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$var1.repeats" ]; then
					queue_array[index]="$var1"
					index=$((index+1))
				fi
			done
			unset IFS
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $(find "$MUSICDIR" -iname "*\.repeats" | shuf | sed -e "s/\.repeats$//g"); do
				if [ -e "$i" ]; then
					queue_array[index]="$i"
					index=$((index+1))
				fi
			done
			unset IFS
		fi
		if [ "$index" == "0" ]; then
			queue_array=("${old_queue_array[@]}")
			unset old_queue_array
			return 200
		fi
		SHUFFLED=true
		TOTAL_QUEUE="$index"
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1 | head -1)"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
	else
		draw_banner "$(get_local_phrase "WAIT")"
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
		unset queue_array
		IFS=$'\n'
		index=0
		for i in $(find "$MUSICDIR" -type f -regex "$regex" | shuf); do
			queue_array[index]="$i"
			index=$((index+1))
		done
		unset IFS
		SHUFFLED=true
		TOTAL_QUEUE=$index
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		reset_buffer
		redraw_buffer
	fi
}

process_key() {
	case "$1" in
	'[')
		system_volume_change false 1 0
		;;
	']')
		system_volume_change false 0 1
		;;
	'{')
		system_volume_change true 1 0
		;;
	'}')
		system_volume_change true 0 1
		;;
	esac
}

load_loop_file() {
	if [ "$LOOP_ON" == false ]; then
		LOOP_ON=true
		ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
		filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			gtts_speak "loading loop"
			if [ -e "$filename_without_ext.repeat.$ext.repeats" ]; then
				REPEATS="$(<"$filename_without_ext.repeat.$ext.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$filename_without_ext.repeat.$ext.locked" ]; then
				read_locked_file "$(<"$filename_without_ext.repeat.$ext.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			else
				INTERVAL=0
				EDO="$DEFAULT_EDO"
			fi
			INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
			INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")\nloadfile '$filename_without_ext.repeat.$ext'\nvolume $VOLUME 1\nloop 0 1" >"$ALETHEIA/pipe$$" &

			LOOP=true
			draw_pitch
			draw_position
		else
			LOOP_ON=false
			return 1
		fi
	else
		LOOP_ON=false
		if [ -e "$FILENAME" ]; then
			echo "volume 0 1" >"$ALETHEIA/pipe$$" &
			draw_banner "$(get_local_phrase "LOOP OFF")"
			gtts_speak "loop disabled"
			if [ -e "$FILENAME.repeats" ]; then
				REPEATS="$(<"$FILENAME.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$FILENAME.locked" ]; then
				read_locked_file "$(<"$FILENAME.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			fi
			INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
			INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")
			echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")\nloadfile \"$FILENAME\"\nvolume $VOLUME 1\nloop -1 1" >"$ALETHEIA/pipe$$" &
			LOOP=false
			draw_pitch
			draw_position
		fi
	fi
}

invert_int() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	INTERVAL="$((-(INTERVAL)))"
	echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	gtts_speak " $INTERVAL"
	draw_pitch
}

render_all_help_screens() {
	if [ "$NO_HELP" != true ]; then
		render_help_screen
		render_repeat_help_screen
		render_scale_help_screen
		render_queue_screen
		rendered=true
	else
		rendered=false
	fi
	render_setup_screen
}

get_metadata() {
	pos=$1
	local current_song=$2
	if [ "$USE_TAGS" == true ]; then
		if [ -e "$ALETHEIA/music.db" ]; then
			#   ,___,
			#  ( o,o )
			#  { `" }
			# -"---"--
			x="${queue_array[$((pos-1))]##*/}"
			x="${x//\'/\'\'}"
			query_result=$(sqlite3 "$ALETHEIA/music.db" "SELECT artist, song, album, time FROM music WHERE filename='$x';")

			IFS='|' read -r artist song album SONG_LENGTH <<< "$query_result"
			if [ "$current_song" == true ]; then
				CURRENT_SONG_LENGTH=$SONG_LENGTH
			fi
		else
			artist=""
			album=""
			song=""
			SONG_LENGTH=""
		fi

		if [ "$artist" == "" ] && [ "$song" == "" ]; then
			line="${queue_array[$((pos-1))]##*/}"
			line="${line%.*}"

			if [[ "$line" == *" - "* ]]; then
				artist="${line%% - *}"
				song="${line##* - }"
				#line="$artist - $song"
			else
				line="${queue_array[$((pos-1))]##*/}"
				line="${line%.*}"
			fi
		else
			if [ -z "$artist" ] && [ -n "$song" ]; then
				line="$song"
			elif [ -z "$song" ] && [ -n "$artist" ]; then
				line="$artist"
			else
				if [ "$album" == "" ] || [ "$DISPLAY_ALBUM" == false ]; then
					line="$artist  $song"
				else
					line="$artist  $album  $song"
				fi
			fi
		fi
	else
		line="${queue_array[$((pos-1))]}"
		line=${line##*/}
		line=${line%.*}

		if [[ "$line" == *" - "* ]]; then
			artist="${line%% - *}"
			song="${line##* - }"
			#line="$artist - $song"
		fi
		SONG_LENGTH=0
	fi
	echo -ne "$line"
}

toggle_feedback_level() {
	if [ "$VOICE_ENABLED" == true ]; then
		draw_banner "$(get_local_phrase "OFF")"
		gtts_speak "voice feedback disabled" true
		VOICE_ENABLED=false
	elif [ "$ONLY_VOICE_TITLES" == true ]; then
		ONLY_VOICE_TITLES=false
		VOICE_ENABLED=true
		draw_banner "$(get_local_phrase "VOICE ON")"
		gtts_speak "full voice feedback" true
	else
		ONLY_VOICE_TITLES=true
		draw_banner "$(get_local_phrase "ONLY TITLE")"
		gtts_speak "only artist and title" true
		VOICE_ENABLED=false
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

swap_lock() {
	if [ "$LOCK_TOTAL" == 0 ]; then
		gtts_speak "no locks"
		draw_banner "$(get_local_phrase "NONE")" false false true
		sleep "$BANNER_WAIT_TIME"
		return
	fi
	if [ "$1" == true ]; then
		if [ "$LOCK_SELECTION" -lt "$((LOCK_TOTAL-1))" ]; then
			((LOCK_SELECTION++))
		else
			LOCK_SELECTION=0
		fi
	else
		if [ "$LOCK_SELECTION" -gt 0 ]; then
			((LOCK_SELECTION--))
		else
			LOCK_SELECTION=$((LOCK_TOTAL-1))
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi

	new_line=$(echo -ne "$CONTENTS" | sed -n "$((LOCK_SELECTION+1))p")
	INTERVAL=$(echo -ne "$new_line" | cut -d'/' -f1)
	EDO=$(echo -ne "$new_line" | cut -d'/' -f2)
	_scaletempo_flag=$(echo -ne "$new_line" | cut -d'/' -f3)

	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")

	if [ "$_scaletempo_flag" == "" ]; then
		SCALETEMPO=false
		ONLY_PITCH=false
		echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	elif [ "$_scaletempo_flag" == "0" ]; then
		SCALETEMPO=false
		ONLY_PITCH=false
		echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	elif [ "$_scaletempo_flag" == "1" ]; then
		SCALETEMPO=true
		ONLY_PITCH=false
		echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		sleep 0.05
		echo -e "af_add scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
	elif [ "$_scaletempo_flag" == "2" ]; then
		SCALETEMPO=true
		ONLY_PITCH=true
		echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		sleep 0.05
		echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
	fi

	echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_banner "$(get_local_phrase "LOCK") $((LOCK_SELECTION+1))/$LOCK_TOTAL" false false true
	gtts_speak_chain "lock" "$((LOCK_SELECTION+1))" "of" "$LOCK_TOTAL" &
	sleep "$BANNER_WAIT_TIME"
}

unlock() {
	local tmp=
	ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
	filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
	if [ -e "$filename_without_ext.repeat.$ext" ]; then
		REP="$BLUE_BLACK"
	else
		REP=""
	fi
	if [ "$LOOP_ON" == true ]; then
		tmp="$filename_without_ext.repeat.$ext"
	else
		tmp="$FILENAME"
	fi
	if [ -e "$tmp.locked" ]; then
		if [ "$LOCK_TOTAL" == "0" ]; then
			draw_banner "$(get_local_phrase "UNLOCK") $((LOCK_SELECTION+1))/1" false false true
			gtts_speak_chain "unlocked" "$((LOCK_SELECTION+1))" "of" "1" &
		else
			draw_banner "$(get_local_phrase "UNLOCK") $((LOCK_SELECTION+1))/$LOCK_TOTAL" false false true
			gtts_speak_chain "unlocked" "$((LOCK_SELECTION+1))" "of" "$LOCK_TOTAL" &
		fi
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup $((LOCKING_POS+1)) 1
		else
			tput cup $((LOCKING_POS+2)) 1
		fi
		if [ "$LOCK_TOTAL" -gt 1 ]; then
			CONTENTS=$(echo -ne "$CONTENTS" | sed "$((LOCK_SELECTION+1))d")
			echo -ne "$CONTENTS" >"$tmp.locked"
			if [ -e "$tmp.repeats" ]; then
				echo -ne "${WHITE_BLACK}${REP}#"
			else
				echo -ne "$BLUE_BLACK$"
			fi
			LOCK_SELECTION=$((LOCK_SELECTION-1))
			LOCK_TOTAL=$((LOCK_TOTAL-1))
			if [ "$LOCK_SELECTION" -lt 0 ]; then
				LOCK_SELECTION=$((LOCK_TOTAL-1))
			fi
		else
			if [ -e "$tmp.repeats" ]; then
				echo -ne "${WHITE_BLACK}${REP}&"
			else
				echo -ne "$BLUE_BLACK "
			fi
			rm -f "$tmp".locked
			LOCKED=false
			LOCK_SELECTION=0
			LOCK_TOTAL=0
		fi
		sleep "$BANNER_WAIT_TIME"
	else
		gtts_speak "no locks"
		draw_banner "$(get_local_phrase "NONE")" false false true
		sleep "$BANNER_WAIT_TIME"
	fi
}

lock() {
	local tmp=
	ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
	filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
	if [ -e "$filename_without_ext.repeat.$ext" ]; then
		REP="$BLUE_BLACK"
	else
		REP=""
	fi
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup $((LOCKING_POS+1)) 1
	else
		tput cup $((LOCKING_POS+2)) 1
	fi
	if [ "$LOOP_ON" == true ]; then
		tmp="$filename_without_ext.repeat.$ext"
	else
		tmp="$FILENAME"
	fi
	if [ -e "$tmp.locked" ]; then
		flag="$CONTENTS\n"
		((LOCK_SELECTION++))
	else
		flag=""
	fi
	if [ "$SCALETEMPO" == true ]; then
		if [ "$ONLY_PITCH" == true ]; then
			echo "$INTERVAL/$EDO/2" >>"$tmp".locked
			CONTENTS="$flag$INTERVAL/$EDO/2"
		else
			echo "$INTERVAL/$EDO/1" >>"$tmp".locked
			CONTENTS="$flag$INTERVAL/$EDO/1"
		fi
	else
		echo "$INTERVAL/$EDO/0" >>"$tmp".locked
		CONTENTS="$flag$INTERVAL/$EDO/0"
	fi
	((LOCK_TOTAL++))
	LOCKED=true
	gtts_speak "locked"
	if [ -e "$tmp.repeats" ]; then
		echo -ne "${WHITE_BLACK}${REP}#"
	else
		echo -ne "${WHITE_BLACK}${REP}$"
	fi
	draw_banner "$(get_local_phrase "LOCK") $((LOCK_SELECTION+1))/$LOCK_TOTAL" false false true
	sleep "$BANNER_WAIT_TIME"
}

seek_left() {
	if [ "$PAUSE" == true ]; then
		PAUSE=false
		draw_position
		draw_pitch
	fi
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	echo "seek -5%" >"$ALETHEIA/pipe$$" &
}

seek_right() {
	if [ "$PAUSE" == true ]; then
		PAUSE=false
		draw_pitch
	fi
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	echo -e "seek +5%" >"$ALETHEIA/pipe$$" &
	return 200
}

delete() {
	local permanent=$1
	local yesno
	if [ -n "$2" ]; then
		local POSITION="$2"
		local FILENAME="$3"
		local TITLE="${FILENAME##*/}"
		TITLE="${TITLE%.*}"
	fi
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		yesno="$_input"
	else
		if [ "$permanent" == true ]; then
			draw_banner "$(get_local_phrase "DELETE")" true
			gtts_speak "delete file?"
		else
			draw_banner "$(get_local_phrase "ARCHIVE")" true
			gtts_speak "archive file?"
		fi
	fi

	if [ -z "$yesno" ]; then
		read -rsn1 yesno
		if [ "$yesno" == $'\e' ]; then
			read -rsn3 -t 0.001
		fi
	fi
	deleted=false
	if [ "$yesno" == "y" ] || [ "$yesno" == "Y" ]; then
		if [ ! -d "$ALETHEIA/deleted" ] || [ ! -d "$ALETHEIA/deleted/voices$VOICE_APPEND" ]; then
			mkdir "$ALETHEIA/deleted" >/dev/null 2>/dev/null
			mkdir "$ALETHEIA/deleted/voices$VOICE_APPEND" >/dev/null 2>/dev/null
		fi
		if [ "$permanent" == true ]; then
			rm -f "$FILENAME" >/dev/null 2>/dev/null

			if [ -e "$FILENAME.locked" ]; then
				rm -f "$FILENAME.locked" >/dev/null 2>/dev/null
			fi
			if [ -e "$FILENAME.repeats" ]; then
				rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
			fi
		else
			mv "$FILENAME" "$ALETHEIA/deleted/"
			if [ -e "$FILENAME.locked" ]; then
				mv "$FILENAME.locked" "$ALETHEIA/deleted/"
			fi
			if [ -e "$FILENAME.repeats" ]; then
				mv "$FILENAME.repeats" "$ALETHEIA/deleted/"
			fi
		fi
		path="${FILENAME%/*}"
		if [ "$(ls -1 "$path")" == "" ]; then
			rmdir "$path"
		fi
		if [ -e "$ALETHEIA/voices$VOICE_APPEND/$TITLE.mp3" ]; then
			if [ "$permanent" == true ]; then
				rm -f "$ALETHEIA/voices$VOICE_APPEND/$TITLE.mp3"
			else
				mv "$ALETHEIA/voices$VOICE_APPEND/$TITLE.mp3" "$ALETHEIA/deleted/voices$VOICE_APPEND/"
			fi
		fi
		draw_pitch
		deleted=true
	else
		draw_pitch
		draw_position
		if [ "$permanent" == true ]; then
			gtts_speak_chain "delete canceled" "main screen" &
		else
			gtts_speak_chain "archive canceled" "main screen" &
		fi
	fi
	tput el
	draw_position
	if [ "$deleted" == true ]; then
		if [ "$permanent" == true ]; then
			gtts_speak "deleted" true
		else
			gtts_speak "archived" true
		fi
		if [ "$POSITION" == "" ]; then
			return 0
		fi

		for i in $(seq "$POSITION" $((TOTAL_QUEUE-1))); do
			queue_array[i-1]=${queue_array[$i]}
		done

		if [ -z "$2" ]; then
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				TOTAL_QUEUE="$((TOTAL_QUEUE-1))"
				return $RETURN_JUMP
			else
				TOTAL_QUEUE="$((TOTAL_QUEUE-1))"
				return $RETURN_RESTART
			fi
		fi
	fi
	return 200
}

insert() {
	new_playlist false true
	if [ "$?" == "$RETURN_JUMP" ]; then
		return $RETURN_JUMP
	fi
	redraw_buffer
	draw_pitch
	draw_position
}

tag_mp3() {
	initial_screen=$1
	if [ -n "$2" ]; then
		local FILENAME="$2"
	fi
	if [ "$initial_screen" == true ]; then
		gtts_speak "nothing loaded" true
		draw_banner "N/A"
		sleep $BANNER_WAIT_TIME
	else
		local _ext="${FILENAME##*.}"
		_ext="${_ext,,}"
		if [ "$_ext" == "mp3" ]; then
			line="$(exiftool -Artist -Title -Album -Track -Genre -Year -Comment -AudioBitrate -OriginalReleaseYear "$FILENAME")"
			_artist="$(echo -ne "$line" | grep -E "^Artist" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_title="$(echo -ne "$line" | grep -E "^Title" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_album="$(echo -ne "$line" | grep -E "^Album" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_tracknumber="$(echo -ne "$line" | grep -E "^Track" | cut -d':' -f2 | sed -e 's/^ //' 2>/dev/null)"
			if [ "${_tracknumber//\// }" != "${_tracknumber}" ]; then
				_totaltracks="${_tracknumber#*/}"
				_tracknumber="${_tracknumber%/*}"
			fi
			_genre="$(echo -ne "$line" | grep -E "^Genre" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_year="$(echo -ne "$line" | grep -E "^Original Release Year" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_comment="$(echo -ne "$line" | grep -E "^Comment" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
			_bitrate="$(echo -ne "$line" | grep -E "^Audio Bitrate" | cut -d':' -f2 | sed -e 's/^ //')"
			if [ -z "$_artist" ]; then
				_artist=" "
			fi
			if [ -z "$_title" ]; then
				_title=" "
			fi
			if [ -z "$_album" ]; then
				_album=" "
			fi
			if [ -z "$_tracknumber" ]; then
				_tracknumber=" "
			fi
			if [ -z "$_genre" ]; then
				_genre=" "
			fi
			if [ -z "$_year" ]; then
				_year=" "
			fi
			if [ -z "$_genre" ]; then
				_genre=" "
			fi
			if [ -z "$_comment" ]; then
				_comment=" "
			fi
			if [ -z "$_totaltracks" ]; then
				_totaltracks=" "
			fi

			cat <<EOF >"$ALETHEIA/media.$$.tag"
#FILE  = ${FILENAME##*/}
#RATE  = $_bitrate

ARTIST = $_artist
TITLE  = $_title
ALBUM  = $_album
YEAR   = $_year
TRACK  = $_tracknumber
TOTAL  = $_totaltracks
GENRE  = $_genre
NOTES  = $_comment
EOF
			gtts_speak "opening vim"
			cp "$ALETHEIA/media.$$.tag" "$ALETHEIA/media.$$.tag.orig"
			vim -c "silent edit $ALETHEIA/media.$$.tag | source $ALETHEIA_DATA_DIR/vimrc/vimrc | execute 'norm! 4G9l'"
			tput civis
			stty -ixon
			if [ -e "$ALETHEIA/media.$$.tag" ] && [ -n "$(diff "$ALETHEIA/media.$$.tag" "$ALETHEIA/media.$$.tag.orig")" ]; then
				_append=()
				while read -r line; do
					item="${line%%=*}"
					item="${item%% *}"
					text="${line#*=}"
					text="${text# }"
					if [ "$text" = "" ]; then
						text=" "
					fi
					if [ "$item" == "ARTIST" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-a "$text")
						fi
						_artist="$text"
					elif [ "$item" == "TITLE" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-t "$text")
						fi
						_title="$text"
					elif [ "$item" == "ALBUM" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-A "$text")
						fi
						_album="$text"
					elif [ "$item" == "TRACK" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-n "$text")
						fi
						_tracknumber="$text"
					elif [ "$item" == "GENRE" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-G "$text")
						fi
						_genre="$text"
					elif [ "$item" == "YEAR" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-Y "$text")
						fi
						_year="$text"
					elif [ "$item" == "NOTES" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-c "$text")
						fi
						_comment="$text"
					elif [ "$item" == "TOTAL" ]; then
						if [[ "$text" =~ ^[\ \t]*$ ]]; then
							text=""
						else
							_append+=(-N "$text")
						fi
						_totaltracks="$text"
					fi
				done <"$ALETHEIA/media.$$.tag"
				eyeD3 --remove-frame TPE1 --remove-frame TORY --remove-frame TCON --remove-frame TIT2 --remove-frame TALB --remove-frame TRCK --remove-frame COMM --remove-frame TYER "$FILENAME" >/dev/null 2>/dev/null
				eyeD3 --encoding utf8 "${_append[@]}" "$FILENAME" >/dev/null 2>/dev/null
				_file=${FILENAME##*/}
				sqlite3 "$ALETHEIA/music.db" "UPDATE music SET artist = '${_artist//\'/\'\'}', song = '${_title//\'/\'\'}', album = '${_album//\'/\'\'}', number = '${_tracknumber//\'/\'\'}' WHERE filename = '${_file//\'/\'\'}';" >/dev/null 2>/dev/null
				if [ "$3" != true ]; then
					reset_buffer
				fi
				gtts_speak "tag updated" true
			fi
		else
			gtts_speak "not an mp3" true
			draw_banner "$(get_local_phrase "NOT MP3")"
			sleep $BANNER_WAIT_TIME
		fi
		rm -f "$ALETHEIA/media.$$.tag" "$ALETHEIA/media.$$.tag.orig"
	fi
}

update_cache() {
	if [ -n "$1" ]; then
		local FILENAME="$1"
	fi
	draw_banner "$(get_local_phrase "WAIT")"
	line="$(exiftool -Artist -Title -Album -Track "$FILENAME")"
	_artist="$(echo -ne "$line" | grep -E "^Artist" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
	_title="$(echo -ne "$line" | grep -E "^Title" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
	_album="$(echo -ne "$line" | grep -E "^Album" | cut -d':' -f2- | sed -e 's/^ //' 2>/dev/null)"
	_tracknumber="$(echo -ne "$line" | grep -E "^Track" | cut -d':' -f2 | sed -e 's/^ //' 2>/dev/null)"
	if [ "${_tracknumber//\// }" != "${_tracknumber}" ]; then
		_totaltracks="${_tracknumber#*/}"
		_tracknumber="${_tracknumber%/*}"
	fi
	_file=${FILENAME##*/}
	sqlite3 "$ALETHEIA/music.db" "UPDATE music SET artist = '${_artist//\'/\'\'}', song = '${_title//\'/\'\'}', album = '${_album//\'/\'\'}', number = '${_tracknumber//\'/\'\'}' WHERE filename = '${_file//\'/\'\'}';" >/dev/null 2>/dev/null
	if [ -z "$1" ]; then
		reset_buffer
		redraw_buffer
		draw_pitch
		draw_position
	fi
}

get_local_lang() {
	case "$1" in
		"af") echo -ne "Afrikaans" ;;
		"bs") echo -ne "Bosnian" ;;
		"ca") echo -ne "Catalan" ;;
		"cs") echo -ne "Czech" ;;
		"cy") echo -ne "Welsh" ;;
		"da") echo -ne "Danish" ;;
		"de") echo -ne "German" ;;
		"el") echo -ne "Greek" ;;
		"en") echo -ne "English" ;;
		"eo") echo -ne "Esperanto" ;;
		"hi") echo -ne "Hindi" ;;
		"ar") echo -ne "Arabic" ;;
		"es") echo -ne "Spanish" ;;
		"et") echo -ne "Estonian" ;;
		"fi") echo -ne "Finnish" ;;
		"fr") echo -ne "French" ;;
		"hr") echo -ne "Croatian" ;;
		"hu") echo -ne "Hungarian" ;;
		"hy") echo -ne "Armenian" ;;
		"id") echo -ne "Indonesian" ;;
		"it") echo -ne "Italian" ;;
		"nl") echo -ne "Dutch" ;;
		"pl") echo -ne "Polish" ;;
		"pt") echo -ne "Portuguese" ;;
		"ru") echo -ne "Russian" ;;
		"sk") echo -ne "Slovak" ;;
		"sq") echo -ne "Albanian" ;;
		"sr") echo -ne "Serbian" ;;
		"su") echo -ne "Sundanese" ;;
		"sv") echo -ne "Swedish" ;;
		"sw") echo -ne "Swahili" ;;
		"tr") echo -ne "Turkish" ;;
		*) echo -ne "$1" ;;
	esac
}

draw_pitch() {
	if [ "$PAUSE" == true ]; then
		draw_banner "$(get_local_phrase "PAUSE")"
		return
	elif [ "$MUTE" == true ]; then
		draw_banner "$(get_local_phrase "MUTE")"
		return
	fi

	tput cup $LINES

	if [ "$SCALETEMPO" == true ]; then
		if [ "$ONLY_PITCH" == true ]; then
			toggle=2
		else
			toggle=1
		fi
	else
		toggle=0
	fi

	echo -ne "$BLUE_BLACK$PADDING$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$toggle"

	POSITION_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))"
	if [ "$POSITION_WIDTH" -lt "$RIGHT_BANNER_WIDTH" ]; then
		printf '%*s' $((COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - RIGHT_BANNER_WIDTH)) ""
	else
		printf '%*s' $((COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - POSITION_WIDTH)) ""
	fi
	echo -ne "$NOCOLOR"
}

draw_equalizer() {
	stty -echo
	IFS=':' read -r bass _ _ _ mid _ _ treble _ _ _ <<< "$EQUALIZER"
	equal="$bass:$mid:$treble"
	tput cup 0 $((COLUMNS-${#bass}-${#mid}-${#treble}-(${#CORNER_DIVIDER}*2)-${#PADDING}))
	echo -ne "$BLUE_BLACK$bass$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$mid$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$treble$PADDING$NOCOLOR"
}

toggle_voice() {
	if [ "$VOICE_ENABLED" == false ]; then
		VOICE_ENABLED=true
		if [ "$1" != true ] && [ "$2" != true ]; then
			gtts_speak "on" false true
		fi
	else
		if [ "$1" != true ]; then
			if [ "$ONLY_VOICE_TITLES" == true ]; then
				gtts_speak "reading only artist and title" false true
			else
				gtts_speak "off" false true
			fi
		fi
		VOICE_ENABLED=false
		ONLY_VOICE_TITLES=false
	fi
}

queue_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak_chain "queue controls" &
	flagged=false

	width="$(echo -ne "$QUEUE_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#QUEUE_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page
		draw_banner "$(get_local_phrase "QUEUE")"
		draw_banner "$(get_local_phrase "HELP")" false true
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${QUEUE_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${QUEUE_HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if $NO_VERTICAL_PADDING; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$((number_per_page*2))
			else
				first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi
		local inputchar=
		read -rsn1 inputchar
		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$((page+1))" -lt "${#QUEUE_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
			fi
		elif [ "$inputchar" == "d" ]; then
			echo -e "$QUEUE_HELP" | sed -n "$first,${last}p;$pos,$((pos+number_per_page-1))p" | sed "s/$/\n/g;s/'/single quote/g;s/\"/double quote/g;s/[A-Z][A-Za-z]/\L&/g;s/\\/[A-Z]/\L&/g;s/[Aa] /&\n\n/g;s/I /I \n\n/g;s/  /\n\n/g;s/$/\n\n/g" | espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" --stdin --punct -v "$ESPEAK_LANGUAGE" -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$((page+1))" -lt "${#QUEUE_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				draw_volume
				draw_equalizer
				draw_banner "$(get_local_phrase "QUEUE")"
				draw_position
				return
				;;
			esac
		else
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "QUEUE")"
			draw_position
			return
		fi
	done
}

scale_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak_chain "scale controls" &
	draw_banner "$(get_local_phrase "HELP")" false true

	width="$(echo -ne "$SCALE_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#SCALE_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
			tput cup 1
		else
			number_per_page=$((LINES-4))
			tput cup 2
		fi
		original_number_per_page=$number_per_page

		echo -ne "$NOCOLOR${SCALE_HELP_BUFFER[page]}"

		helpbuflines=$(echo -ne "${SCALE_HELP_BUFFER[page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		local inputchar=
		read -rsn1 inputchar
		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			gtts_speak "page down"
			if [ "$((page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			echo "$SCALE_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g;s/EDO/e d o/g;s/INT/interval/g;s/PCM/p c m/g;s/|/vertical slash/g;s/?/question mark/g;s/[A-Z][A-Za-z]/\L&/g;s/\\/[A-Z]/\L&/g;s/[Aa] /&\n\n/g;s/I /I \n\n/g;s/  /\n\n/g;s/$/\n\n/g;s/-/ /g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" --stdin --punct -v "$ESPEAK_LANGUAGE" -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "$(get_local_phrase "SCALE")"
			draw_banner "$(get_local_phrase "HELP")" false true
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

add_downloaded() {
	regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	list=$(find "$MUSICDIR" -cnewer "$ALETHEIA/start$$" -regex "$regex")
	if [ "${list:0:1}" != "" ]; then
		mapfile -O "$TOTAL_QUEUE" -t queue_array < <(echo -ne "$list")
		DOWNLOAD_POSITION=$((TOTAL_QUEUE+1))
		TOTAL_QUEUE=${#queue_array[@]}
		if [ "$1" != true ]; then
			gtts_speak "queued downloads"
		fi
		if [ "$1" != "noposition" ]; then
			draw_position
		fi
		update_metadata_db
		reset_buffer
		redraw_buffer
	else
		unset IFS
		if [ "$1" != true ]; then
			gtts_speak "nothing downloaded"
			draw_banner "$(get_local_phrase "NONE")"
		fi
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
		return
	fi
	touch -m "$ALETHEIA/start$$"
}

read_corner() {
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	fi
	z=""
	draw_banner "$(get_local_phrase "READ")" false false true
	gtts_speak "read corner"
	read -rsn1 x
	if [ "$x" == "u" ]; then
		tmp="$(echo "$SYSTEM_VOLUME_LEFT" | cut -d'%' -f1)"
		tmp2="$(echo "$SYSTEM_VOLUME_RIGHT" | cut -d'%' -f1)"
		tmp3="$(echo "$VOLUME" | cut -d'%' -f1)"
		gtts_speak "$tmp3" true false true
		read -rn1 -t 0.05 z
		if [ -n "$z" ]; then return; fi
		gtts_speak "$tmp" true false true
		if [ "$SYSTEM_VOLUME_LEFT" != "$SYSTEM_VOLUME_RIGHT" ]; then
			read -rn1 -t 0.05 z
			if [ -n "$z" ]; then return; fi
			gtts_speak "$tmp2" true false true
		fi
	elif [ "$x" == "i" ]; then
			res="$(echo -ne "$equal" | sed -e "s/:/, /g")"
			if [ "$res" == "0, 0, 0" ]; then
				gtts_speak "equalizer off" true false true
			else
				VOICE_ENABLED=true gtts_speak_chain "$bass" "$mid" "$treble" &
			fi
	elif [ "$x" == "j" ]; then
			VOICE_ENABLED=true gtts_speak_chain "$INTERVAL" "of" "$EDO" &
	elif [ "$x" == "k" ]; then
		VOICE_ENABLED=true gtts_speak_chain "$POSITION" "of" "$TOTAL_QUEUE" &
	fi
}

sort_queue() {
	gtts_speak "sorted"

	IFS=$'\n'
	mapfile -t queue_array < <(printf "%s\n" "${queue_array[@]}" | awk -F '/' '{printf "%s", $NF; print $0}' | sort | cut -d'' -f2)
	unset IFS
	POSITION=$(printf '%s\n' "${queue_array[@]}" | grep --text -n "$FILENAME" | cut -d':' -f1 | head -1)
	web_client_func

	reset_buffer
	redraw_buffer
}

shuffle_queue() {
	gtts_speak "shuffled"

	IFS=$'\n'
	mapfile -t tmp_array < <(printf "%s\n" "${queue_array[@]}" | shuf | grep --text -v "$FILENAME")
	queue_array=("$FILENAME" "${tmp_array[@]}")
	unset IFS tmp_array

	POSITION=1
	TRACK_RANDOM=false
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))

	web_client_func
	reset_buffer
	redraw_buffer
}

render_queue_screen() {
	render $((QUEUE_HELP_LENGTH+1)) "$(echo -ne "$QUEUE_HELP" | wc -L)" "$QUEUE_HELP"
	QUEUE_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

render_setup_screen() {
	render $((SETUP_HELP_LENGTH+1)) "$(echo -ne "$SETUP_HELP" | wc -L)" "$SETUP_HELP"
	SETUP_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

render_scale_help_screen() {
	render $((SCALE_HELP_LENGTH+1)) "$(echo -ne "$SCALE_HELP" | wc -L)" "$SCALE_HELP"
	SCALE_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

setup_screen() {
	initial_screen=$1
	gtts_speak_chain "settings" &
	flagged=false

	width="$(echo -ne "$SETUP_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#SETUP_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page
		draw_banner "$(get_local_phrase "SETUP")"
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${SETUP_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${SETUP_HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if $NO_VERTICAL_PADDING; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$((number_per_page*2))
			else
				first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		local inputchar=
		read -rsn1 inputchar
		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$((page+1))" -lt "${#SETUP_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
			fi
		elif [ "$inputchar" == "J" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$VOICE_PITCH" -gt "-30" ]; then
				VOICE_PITCH="$((VOICE_PITCH-1))"
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == false ]; then
				if [ ! -e "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" ]; then
					draw_banner "$(get_local_phrase "WAIT")"
					if check_local_lang "$GTTS_LANGUAGE"; then
						lang="$GTTS_LANGUAGE"
					else
						lang="en"
					fi
					gtts-cli " $VOICE_PITCH" -l "$lang" -o "/tmp/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
					sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" speed "$(calc -pd "2^($VOICE_PITCH/60)")" >/dev/null 2>/dev/null
					rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"
					draw_banner "$(get_local_phrase "VOICE")"
					draw_position
				fi
				play -v "$VOICE_VOLUME" "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
			else
				espeak_say "$VOICE_PITCH" false false true
			fi
		elif [ "$inputchar" == "K" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$VOICE_PITCH" -lt "30" ]; then
				VOICE_PITCH="$((VOICE_PITCH+1))"
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == false ]; then
				if [ ! -e "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" ]; then
					draw_banner "$(get_local_phrase "WAIT")"
					if check_local_lang "$GTTS_LANGUAGE"; then
						lang="$GTTS_LANGUAGE"
					else
						lang="en"
					fi
					gtts-cli " $VOICE_PITCH" -l "$lang" -o "/tmp/voice-pitch${VOICE_PITCH}.mp3"
					sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" speed "$(calc -pd "2^($VOICE_PITCH/60)")"
					rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"
					draw_banner "$(get_local_phrase "VOICE")"
					draw_position
				fi
				play -v "$VOICE_VOLUME" "$ALETHEIA/voices$VOICE_APPEND/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
			else
				espeak_say "$VOICE_PITCH" false false true
			fi
		elif [ "$inputchar" == "" ]; then
			theme_submenu "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				GTTS_NATURAL_VOICE=false
				ESPEAK_DIGITAL_VOICE=true
				VOICE_ENGINE="espeak-ng"
				draw_banner "ESPEAK"
				gtts_speak "e speak"
			else
				GTTS_NATURAL_VOICE=true
				ESPEAK_DIGITAL_VOICE=false
				VOICE_ENGINE="gtts-cli"
				draw_banner "GTTS"
				gtts_speak "g t t s"
			fi
			sleep "$BANNER_WAIT_TIME"
		elif [ "$inputchar" == "" ]; then
			toggle_panels "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			invert_colors  "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			if [ "$USE_TAGS" == true ]; then
				draw_banner "$(get_local_phrase "FILENAME")"
				gtts_speak "display filename"
				USE_TAGS=false
			else
				draw_banner "$(get_local_phrase "TAGS")"
				gtts_speak "display tags"
				USE_TAGS=true
			fi
			sleep $BANNER_WAIT_TIME
			if [ "$initial_screen" != true ]; then
				reset_buffer
			fi
		elif [ "$inputchar" == "T" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			toggle_feedback_level
		elif [ "$inputchar" == "#" ]; then
			save_settings true
		elif [ "$inputchar" == "c" ]; then
			cache_metadata
			draw_volume
			draw_equalizer
			if [ "$initial_screen" == true ]; then
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
				return
			else
				if [ "$in_menu" != true ]; then
					reset_buffer
					redraw_buffer
					draw_pitch
				else
					draw_banner "$(get_local_phrase "MENU")"
				fi
				draw_position
				return
			fi
		elif [ "$inputchar" == "8" ]; then
			if [ "$(echo -e "$VOICE_VOLUME > 0.05" | bc)" == "1" ]; then
				VOICE_VOLUME="$(echo "$VOICE_VOLUME-0.05" | bc)"
				ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "9" ]; then
			if [ "$(echo -e "$VOICE_VOLUME < 1.0" | bc)" == "1" ]; then
				VOICE_VOLUME="$(echo "$VOICE_VOLUME+0.05" | bc)"
				ESPEAK_VOICE_VOLUME=$(bc <<<"$VOICE_VOLUME*100")
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "d" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			echo "$SETUP_HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g;s/EDO/e d o/g;s/PCM/p,c,m/g;s/[A-Z][A-Za-z]/\L&/g;s/\\/[A-Z]/\L&/g;s/[Aa] /&\n\n/g;s/I /I \n\n/g;s/  /\n\n/g;s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" --stdin --punct -v "$ESPEAK_LANGUAGE" -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "VOICE")"
			draw_position
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#SETUP_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				if [ "$1" == true ]; then
					gtts_speak "settings closed" true
					menu_start_over=true
					SKIP_SPEAK_MENU=false
				else
					gtts_speak_chain "settings closed" "main screen" &
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" != true ] && [ "$2" != true ]; then
					redraw_screen
				fi
				return
				;;
			esac
		else
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$2" == true ]; then
				gtts_speak "settings closed" true
				menu_start_over=true
				SKIP_SPEAK_MENU=false
			else
				gtts_speak_chain "settings closed" "main screen" &
			fi
			number_per_page="$original_number_per_page"
			menu_start_over=true
			if [ "$1" != true ]; then
				if [ "$2" != true ]; then
					redraw_screen
				fi
			fi
			return
		fi
	done
}

render() {
	TMP_BUFFER=()
	local length="$1"
	local width="$2"
	local text="$3"
	if [ "$NO_VERTICAL_PADDING" == true ] || [ "$LINES" -le "4" ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi
	original_number_per_page="$number_per_page"

	mapfile -t text_array <<< "$text"

	FLAGGED=false

	length=${#text_array[@]}

	if [ "$length" -le "$number_per_page" ]; then
		number_per_page="$length"
		FLAGGED=true
	fi
	
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		if [ "$FLAGGED" == true ]; then
			TWO_COLUMN=false
		else
			TWO_COLUMN=true
		fi
	else
		TWO_COLUMN=false
	fi

	pos=1
	while [ "$pos" -le "$length" ]; do
		unset buf
		if [ "$((length-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((length-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$length" ]; then
			return
		fi
		x=0
		for i in $(seq $pos $((pos + (number_per_page-1)))); do
			line="${text_array[$((i-1))]}"
			if [ "$TWO_COLUMN" == false ]; then
				pmt_line=""
			else
				pmt_line="${text_array[$((i+number_per_page-1))]}"
			fi
			if [ "${line:2:1}" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
					if [ "$TWO_COLUMN" == true ]; then
						if (( (i+number_per_page-2) < ${#text_array[@]} )); then
							if [ "${pmt_line:2:1}" != " " ]; then
								pmt1="$BLUE$pmt_line"
								pmt2=""
							else
								pmt1="$BLUE ${pmt_line:0:2}"
								pmt2="$WHITE${pmt_line#* * }"
								pmt_line=" $BLUE ${pmt_line:0:2} $WHITE${pmt_line# * * }"
							fi
						fi
					else
						pmt_line=""
					fi
			else
				tmp1="$BLUE ${line:0:2}"
				tmp2="$WHITE${line#* * }"
				if [ "$TWO_COLUMN" == true ]; then
					if (( (i+number_per_page-2) < ${#text_array[@]} )); then
						pmt1="$BLUE ${pmt_line:0:2}"
						pmt2="$WHITE${pmt_line#* * }"
					fi
				else
					pmt_line=""
				fi

				if [ "${pmt_line:2:1}" != " " ]; then
					pmt1="$BLUE$pmt_line"
					pmt2=""
				fi

			fi

			if [ "$TWO_COLUMN" == true ]; then
				difference=$((((COLUMNS/2) - width + 2) / 2))
			else
				difference=$(((COLUMNS - width + 2) / 2 ))
			fi

			if [ "$NO_VERTICAL_PADDING" == true ] || [ "$LINES" -le "4" ]; then
				offset=$((x+1))
			else
				offset=$((x+2))
			fi

			if [ "$pmt_line" != "" ] && [ "$line" != "" ]; then
				buf[x]="$(tput el; tput cuf $difference)$tmp1 $tmp2$(tput el)$(tput cup $offset $((COLUMNS/2+difference)))$pmt1 $pmt2$(tput el)\n"
			else
				buf[x]="$(tput el; tput cuf $difference)$tmp1 $tmp2$(tput el)\n"
			fi

			((x++))
		done

		until [ "$x" == "$original_number_per_page" ]; do
			buf[x]="\n"
			((x++))
		done

		TMP_BUFFER+=("$(printf '%s' "${buf[@]}")")

		if [ "$TWO_COLUMN" == false ]; then
			pos="$((pos+number_per_page))"
		else
			if [ "$((pos+(number_per_page*2)))" -lt "$length" ]; then
				pos="$((pos+(number_per_page*2)))"
			else
				return
			fi
		fi
	done
}

render_repeat_help_screen() {
	render $((REPEAT_HELP_LENGTH+1)) "$(echo -ne "$REPEAT_HELP" | wc -L)" "$REPEAT_HELP"
	REPEAT_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

loop_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak_chain "loop controls" &

	width="$(echo -ne "$REPEAT_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#REPEAT_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page

		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${REPEAT_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${REPEAT_HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		local inputchar=
		read -rsn1 inputchar
		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			gtts_speak "page down"
			if [ "$((page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			echo "$REPEAT_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g;s/EDO/e d o/g;s/INT/interval/g;s/PCM/p c m/g;s/|/vertical slash/g;s/?/question mark/g;s/-/minus /g;s/[A-Z][A-Za-z]/\L&/g;s/\\/[A-Z]/\L&/g;s/[Aa] /&\n\n/g;s/I /I \n\n/g;s/  /\n\n/g;s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" --stdin --punct -v "$ESPEAK_LANGUAGE" -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "$(get_local_phrase "HELP")" false false true
			tput cup $LINES $((COLUMNS-12))
			echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

render_help_screen() {
	render $((HELP_LENGTH+1)) "$(echo -ne "$HELP" | wc -L)" "$HELP"
	tput rc
	HELP_BUFFER=("${TMP_BUFFER[@]}")
}

help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak_chain "key controls" &
	local initial_screen=$1

	width="$(echo -ne "$HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	while true; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page

		tput cup 0
		echo -ne "$BLUE_BLACK${PADDING}PCM${WHITE_BLACK}:${BLUE_BLACK}LEF${WHITE_BLACK}:${BLUE_BLACK}RIG"
		printf '%*s' $((COLUMNS-22-${#PADDING}*2)) ""
		echo -ne "${BLUE_BLACK}BAS${WHITE_BLACK}:${BLUE_BLACK}MID${WHITE_BLACK}:${BLUE_BLACK}TRE$PADDING$NOCOLOR"

		tput cup $LINES
		echo -ne "${BLUE_BLACK}${PADDING}INT${WHITE_BLACK}:${BLUE_BLACK}EDO${WHITE_BLACK}:${BLUE_BLACK}TOG"
		printf '%*s' $((COLUMNS-22-${#PADDING}*2)) ""
		echo -ne "${BLUE_BLACK}POS${WHITE_BLACK}:${BLUE_BLACK}QUE${WHITE_BLACK}:${BLUE_BLACK}TOG$PADDING$NOCOLOR"

		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		read -rsn1 inputchar
		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$((page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			echo "$HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g;s/-EDO/ EDO/g;s/EDO/e d o/g;s/INT/interval/g;s/PCM/p c m/g;s/'/single quote/g;s/\"/double quote/g;s/\./period/g;s/|/vertical slash/g;s/-[0-9]/minus &/g;s/\([a-zA-Z]\)\/\([a-zA-Z]\)/\1 or \2/g;s/?/question mark/g;s/[A-Z][A-Za-z]/\L&/g;s/\\/[A-Z]/\L&/g;s/[Aa] /&\n\n/g;s/I /I \n\n/g;s/  /\n\n/g;s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng -p "$((VOICE_PITCH+50))" -a "$ESPEAK_VOICE_VOLUME" --stdin --punct -v "$ESPEAK_LANGUAGE" -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			empty_pane
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			number_per_page="$original_number_per_page"
			if [ "$initial_screen" == true ]; then
				gtts_speak "closed" true
				draw_volume
				draw_equalizer
				draw_banner "$(get_local_phrase "MENU")"
				draw_position
			else
				gtts_speak_chain "closed" "main screen" &
			fi
			return
		elif [ "$inputchar" == "m" ]; then
			man aletheia
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				number_per_page="$original_number_per_page"
				if [ "$initial_screen" == true ]; then
					gtts_speak "closed" true
					draw_volume
					draw_equalizer
					draw_banner "$(get_local_phrase "MENU")"
					draw_position
				else
					gtts_speak_chain "closed" "main screen" &
				fi
				return
				;;
			esac
		else
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
		fi
	done
}

start_search() {
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	draw_banner "$(get_local_phrase "SEARCH")"
	draw_position
	tput rc
	echo -ne "$BLUE_BLACK"
	gtts_speak "search keywords"
	if [ "$WEB_CLIENT" == "0" ]; then
		jump="$(read_line)"
	else
		read -r -t 0.1 jump <"$ALETHEIA/web_client_pipe$$"
		if [ "$jump" == "" ]; then
			jump="$(read_line)"
		fi
	fi
	jump_regex="${jump// /.*}"
	if [ "$jump" != "" ]; then
		if [ "$(is_num "$jump")" != "0" ]; then
			jump="${jump#"${jump%%[!0]*}"}"
			if [ "$jump" -lt "1" ]; then
				if [ "$1" == false ]; then
					redraw_buffer
				fi
			elif [ "$jump" -le "$TOTAL_QUEUE" ]; then
				if [ "$jump" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jump"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					if [ "$1" == false ]; then
						redraw_buffer
						draw_pitch
					fi
					draw_position
				fi
			else
				if [ "$1" == false ]; then
					redraw_buffer
					draw_pitch
				fi
				draw_position
			fi
		else
			#jump="$(echo -ne "$jump" | iconv -f utf-8 -t ascii//TRANSLIT)"
			#mapfile -t search_array < <(printf '%s\n' "${queue_array[@]}" | iconv -f utf-8 -t ascii//TRANSLIT | grep -niE "$jump_regex" | grep -v '.repeat.')
			mapfile -t search_array < <(printf '%s\n' "${queue_array[@]}" | grep -niE "$jump_regex" | grep -v '.repeat.')
			length=${#search_array[@]}
			if [ "$length" == "1" ]; then
				LOOP_ARTIST=false
				JUMP=${search_array[0]%%:*}
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				return $RETURN_JUMP
			elif [ "$length" == "0" ]; then
				if [ "$1" == false ]; then
					redraw_buffer
					draw_pitch
				else
					draw_banner "$(get_local_phrase "MENU")"
				fi
				draw_position
			else
				search_queue "$1"
				if [ "$?" == "$RETURN_JUMP" ]; then
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
		fi
	else
		if [ "$1" == true ]; then
			gtts_speak "search canceled"
		else
			gtts_speak_chain "search canceled" "main screen" &
			draw_pitch
			draw_position
			redraw_buffer
		fi
	fi
	echo -ne "$NOCOLOR"
}

new_playlist() {
	local initial_screen=$1
	KEYWORD=""
	gtts_speak "enter keywords to start new playlist"
	draw_banner "$(get_local_phrase "INSERT")"
	keyw="$(read_line)"
	if [ "$keyw" == "" ]; then
		if [ "$initial_screen" != true ]; then
			draw_pitch
		else
			draw_banner "$(get_local_phrase "MENU")"
		fi
	else
		KEYWORD="${keyw// /.*}"
		file_list="$(find "$MUSICDIR" -type f)"
		#matches="$(echo -e "$file_list" | grep -n "" | iconv -f utf-8 -t ascii//TRANSLIT | grep -iE ".*${KEYWORD}.*mp3$|.*${KEYWORD}.*flac$" | grep -v '.repeat.')"
		matches="$(echo -e "$file_list" | grep -n "" | grep -iE ".*${KEYWORD}.*mp3$|.*${KEYWORD}.*flac$" | grep -v '.repeat.')"
		if [ "$1" == true ] || [ "$2" == true ]; then
			IFS=$'\n'
			if [ "$2" == true ]; then
				index=$TOTAL_QUEUE
			else
				index=0
			fi
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$((index+1))
			done
			unset IFS
			if [ "$index" == "$TOTAL_QUEUE" ]; then
				gtts_speak "nothing found" true
				draw_pitch
				draw_position
				return
			else
				TOTAL_QUEUE=$index
				if [ "$2" != true ]; then
					return "$RETURN_JUMP"
				fi
			fi
		else
			if [ "$3" != true ]; then
				unset queue_array
				IFS=$'\n'
				index=0
				queue_array[index]="$FILENAME"
				((index++))
			else
				index=$TOTAL_QUEUE
			fi
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$((index+1))
			done
			unset IFS
			if [ "$index" == "0" ]; then
				gtts_speak "nothing found" true
				draw_pitch
				draw_position
				return
			fi
		fi
		VIDEO=false
		TOTAL_QUEUE="$index"
		echo -ne "$NOCOLOR"
		if [ "$2" == true ]; then
			gtts_speak "closed" true
			reset_buffer
		else
			POSITION="1"
			reset_buffer
		fi
	fi
}

search_queue() {
	page=0
	already_said=false
	total=${#search_array[@]}
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		local number_per_page="$((LINES-2))"
	else
		local number_per_page="$((LINES-4))"
		echo -ne "$NOCOLOR"
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
	fi
	local original_number_per_page="$number_per_page"

	local FLAGGED=false
	local REDRAWN=false
	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	new_page=false
	current_pos=1
	local pos=1
	while [ "$pos" -le "$total" ] || [ "$FLAGGED" == false ]; do
		BUFFER=""
		tput cup 0
		if [ "$((total-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((total-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		_last=$((pos+number_per_page))
		diff=$((_last-pos))
		for i in $(seq 1 $diff); do
			truepos=$i
			line="${search_array[$(((pos+i-1)-1))]}"
			m="$(echo -ne "$line" | cut -d':' -f1)"
			if [ "$m" == "" ]; then
				break
			fi

			line="${line##*/}"
			line="${line%.*}"
			tmp_buf[i-1]="$m$line"

			if (( m < 10 )); then
				pad=" "
			else
				pad=""
			fi

			line="${line:0:$((COLUMNS-${#m}-4-${#pad}))}"
			if (( ( pos + i - 1) == current_pos || m == POSITION)); then
				BUFFER="$BUFFER$BLUE_BLACK$PADDING ${m} $WHITE_BLACK$line$(tput el)$NOCOLOR\n"
			else
				BUFFER="$BUFFER$BLUE$PADDING ${m} $WHITE$line$(tput el)$NOCOLOR\n"
			fi
		done
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR$BUFFER"
		
		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((number_per_page+1))"
			else
				empty_pane "$((number_per_page+2))"
			fi
		fi
		phrase="$(get_local_phrase "SEARCH")"
		draw_banner "$phrase"
		printf '%*s' $((COLUMNS - (${#PADDING}*2) - ${#phrase} - 6)) ""
		tput rc
		if [ "$new_page" == true ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			new_page=false
			ind=$((current_pos-(page*number_per_page-1)-2))
			one=${tmp_buf[ind]%%*}
			two=${tmp_buf[ind]##*}
			gtts_speak_chain "$one" "$two" &
		fi

		if [ "$already_said" != true ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			chained=()
			index=0
			for i in $(seq 0 $((${#tmp_buf[@]}-1))); do
				chained[index]="${tmp_buf[i]%%*}"
				((index++))
				chained[index]="${tmp_buf[i]##*}"
				chained[index]=${chained[index]//\~/\-}
				((index++))
			done
			gtts_speak_chain "${chained[@]}" &
			already_said=true
		fi

		if [ "$WEB_CLIENT" == "0" ]; then
			read -rsn1 inputchar
		else
			read -rsn1 -t 0.1 inputchar <"$ALETHEIA/web_client_pipe$$"
			if [ "$inputchar" == "" ]; then
				read -rsn1 inputchar
			fi
		fi

		if [ "$inputchar" == "j" ]; then
			if (( (pos + number_per_page) <= total )); then
				already_said=false
				kill %% >/dev/null 2>/dev/null
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
					if [ -e "$ALETHEIA/espeak.pid" ]; then
						kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
					fi
				fi
				gtts_speak "page down"
				((page++))
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+original_number_per_page))"
				current_pos=$pos
			fi
		elif [ "$inputchar" == "k" ]; then
			already_said=false
			if (( (pos - number_per_page) <= 1 )); then
				pos=1
				current_pos=$pos
				continue
			else
				FLAGGED=false
			fi
			kill %% >/dev/null 2>/dev/null
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			gtts_speak "page up"
			((--page))
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos=$((pos-original_number_per_page))
			current_pos=$pos
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$inputchar" == "h" ]; then
			if (( current_pos < total )); then
				((current_pos++))
			else
				continue
			fi
			kill %% >/dev/null 2>/dev/null
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			if [ "$current_pos" -gt "${#tmp_buf[@]}" ]; then
				ind=$((current_pos-(page*original_number_per_page-1)-2))
				one=${tmp_buf[ind]%%*}
				two=${tmp_buf[ind]##*}
			else
				ind=$((current_pos-1))
				one=${tmp_buf[ind]%%*}
				two=${tmp_buf[ind]##*}
			fi
			if [ "$current_pos" -gt "$((pos+i-1))" ]; then
				((page++))
				new_page=true
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$((pos+original_number_per_page))" -le "$total" ]; then
					pos="$((pos+original_number_per_page))"
				fi
			else
				gtts_speak_chain "$one" "$two" &
			fi
		elif [ "$inputchar" == "l" ]; then
			if (( current_pos > 1 )); then
				((--current_pos))
			else
				continue
			fi
			kill %% >/dev/null 2>/dev/null
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			if [ "$current_pos" -gt "${#tmp_buf[@]}" ]; then
				one=${tmp_buf[$((current_pos-(page*original_number_per_page-1)-2))]%%*}
				two=${tmp_buf[$((current_pos-(page*original_number_per_page-1)-2))]##*}
			else
				one=${tmp_buf[$((current_pos-1))]%%*}
				two=${tmp_buf[$((current_pos-1))]##*}
			fi
			if [ "$current_pos" -lt "$pos" ]; then
				((--page))
				CHANGED=true
				new_page=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				current_pos="$((pos+number_per_page-1))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			else
				gtts_speak_chain "$one" "$two" &
			fi
		elif [ "$inputchar" == "" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			JUMP=${search_array[$((current_pos-1))]%%:*}
			return "$RETURN_JUMP"
		elif [ "$(is_num "$inputchar")" != "0" ]; then
			gtts_speak " $inputchar"
			up_down="$(read_line "$inputchar")"
			jumpto="$up_down"
			if [ "$jumpto" -le "$TOTAL_QUEUE" ]; then
				if [ "$jumpto" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jumpto"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					return
				fi
			fi
			return
		elif [ "$inputchar" == "s" ]; then
			start_search false
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			else
				BUFFER="$BUFFER_BACKUP"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				return
			fi
		elif [ "$inputchar" == "T" ]; then
			FLAGGED=false
		elif [ "$inputchar" == "d" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			gtts_speak_chain "${chained[@]}" &
			FLAGGED=false
		elif [ "$inputchar" == "q" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			if [ "$1" == false ]; then
				gtts_speak_chain "search canceled" "main screen" &
				redraw_buffer
			else
				gtts_speak "search canceled"
			fi
			if [ "$1" != true ]; then
				draw_pitch
				draw_position
			fi
			return
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "SEARCH")"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$((total-number_per_page-1))"
				fi
				;;
			'[A')
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				gtts_speak_chain "search canceled" "main screen" &
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position

				return
				;;
			esac
		fi
	done
}

queue_controls() {
	SEARCHBUFFER="$(ls -1 "$ALETHEIA/playlists/")"
	if [ "$SEARCHBUFFER" == "" ]; then
		draw_banner "$(get_local_phrase "NO QUEUES")"
		gtts_speak "no queues" true
		sleep "$BANNER_WAIT_TIME"
		if [ "$1" == true ]; then
			draw_banner "$(get_local_phrase "MENU")"
		else
			draw_pitch
			draw_position
		fi
		echo -ne "$NOCOLOR"
		return
	fi
	total="$(echo -e "$SEARCHBUFFER" | wc -l)"
	tmp_buf=()
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		local number_per_page="$((LINES-2))"
	else
		local number_per_page="$((LINES-4))"
	fi
	local original_number_per_page="$number_per_page"
	local FLAGGED=false
	local REDRAWN=false

	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$((pos-1))" -le "$total" ]; do
		if [ "$total" == "0" ]; then
			SEARCHBUFFER="\n"
			total="$(echo -e "$SEARCHBUFFER" | wc -l)"
		else
			SEARCHBUFFER="$(ls -1 "$ALETHEIA/playlists/")"
			total="$(echo -e "$SEARCHBUFFER" | wc -l)"
		fi
		BUFFER=""
		tput cup 0
		if [ "$((total-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((total-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		for i in $(seq $pos $((pos + (number_per_page-1)))); do
			line="$(echo -e "$SEARCHBUFFER" | sed -n "${i}p")"

			if [ "$i" -lt "10" ]; then
				pad=" "
			else
				pad=""
			fi

			line="$(echo "$line" | cut -b 1-$((COLUMNS-${#i}-3)))"
			if [ "$line" == "" ]; then
				line="(none)"
			fi

			tmp_buf[i]="$i$line"
			BUFFER="$BUFFER$BLUE ${i} $WHITE$line$(tput el)\n"
		done
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR$BUFFER"

		chained=()
		index=0
		for i in $(seq 0 $((${#tmp_buf[@]}))); do
			chained[index]="${tmp_buf[i]%%*}"
			((index++))
			chained[index]="${tmp_buf[i]##*}"
			((index++))
		done

		gtts_speak_chain "${chained[@]}" &

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((number_per_page+1))"
			else
				empty_pane "$((number_per_page+2))"
			fi
		fi
		draw_banner "$(get_local_phrase "SELECT LIST")"

		read -rsn1 inputchar

		if [ "$inputchar" == "j" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$((pos+number_per_page))"
			if [ "$pos" -gt "$total" ]; then
				pos="$((total-number_per_page-1))"
			fi
		elif [ "$inputchar" == "k" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$((pos-number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$(is_num "$inputchar")" == "1" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			jumpto="$(read_line "$inputchar" true)"
			if [ "$?" == "1" ]; then
				gtts_speak_chain "invalid number" "select playlist" &
				continue
			fi
			if [ "$jumpto" -le "$total" ]; then
				if [ "$jumpto" -gt "0" ]; then
					PICK="$(echo -ne "$SEARCHBUFFER" | sed -n "${jumpto}p")"
					if [ "$PICK" == "" ]; then
						gtts_speak "number not valid"
					else
						unset queue_array

						IFS=$'\n'
						index=0
						while read -r i; do
							queue_array[index]="$i"
							index=$((index+1))
						done < "$ALETHEIA/playlists/$PICK"
						unset IFS
						TOTAL_QUEUE=$((index-1))
						JUMP="1"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
					continue
				else
					continue
				fi
			else
				gtts_speak_chain "invalid number" "select playlist" &
				continue
			fi
			return
		elif [ "$inputchar" == "D" ]; then
			draw_banner "$(get_local_phrase "DELETE")"
			gtts_speak "enter number to delete"
			read -rn1 c
			if [ "$(is_num "$c")" == "1" ]; then
				c="$(read_line "$c" true)"
				if [ "$?" == "1" ]; then
					gtts_speak_chain "invalid number" "select playlist" &
					continue
				fi
				if [ "$c" -gt "0" ] && [ "$c" -le "$total" ]; then
					draw_banner "$(get_local_phrase "DELETE")" true

					gtts_speak "delete $c?"
					read -rsn1 z
					if [ "$z" == "y" ] || [ "$z" == "Y" ]; then
						pmt_PICK="$(echo -ne "$SEARCHBUFFER" | sed -n "${c}p")"
						rm "$ALETHEIA/playlists/$pmt_PICK"
						gtts_speak "deleted"
					else
						gtts_speak "delete canceled"
					fi
				fi
			else
				gtts_speak_chain "invalid number" "select playlist" &
				continue
			fi
		elif [ "$inputchar" == "" ]; then
			if [ "$VOICE_ENABLED" == true ]; then
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
			fi
			PICK="$(echo -ne "$SEARCHBUFFER" | head -1)"
			if [ "$PICK" == "" ]; then
				gtts_speak "no queues"
			else
				unset queue_array

				IFS=$'\n'
				index=0
				while read -r i; do
					queue_array[index]="$i"
					index=$((index+1))
				done < "$ALETHEIA/playlists/$PICK"
				unset IFS
				TOTAL_QUEUE=$((index-1))
				JUMP="1"
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				return $RETURN_JUMP
			fi
		elif [ "$inputchar" == "d" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			gtts_speak_chain "${chained[@]}" &
		elif [ "$inputchar" == "Z" ]; then
			if [ "$initial_screen" == true ]; then
				continue
			fi
			gtts_speak "save queue as?"
			draw_banner "$(get_local_phrase "SAVE QUEUE")"
			tmp="$(read_line)"
			if [ "$tmp" != "" ]; then
				if [ ! -e "$ALETHEIA/playlists/" ]; then
					mkdir "$ALETHEIA/playlists"
				fi
				echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
				gtts_speak "saved"
			else
				gtts_speak "canceled"
			fi
			draw_banner "$(get_local_phrase "SELECT LIST")"
			draw_position
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
			else
				draw_banner "$(get_local_phrase "MENU")"
				echo -ne "$NOCOLOR"
			fi
			gtts_speak "closed"
			return 200 
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "SELECT LIST")"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$((total-number_per_page-1))"
				fi
				;;
			'[A')
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					draw_volume
					draw_equalizer
					draw_pitch
					draw_position
				fi
				return 200
				;;
			esac
		fi
	done
}

set_equalizer() {
	echo -ne "$WHITE_BLACK"
	draw_banner "$(get_local_phrase "BASS")"
	gtts_speak "bass"
	bass="$(read_number)"
	if [ "$bass" == "" ]; then
		gtts_speak "closed"
		return
	fi
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup $((LINES-2))
	else
		tput cup $((LINES-4))
	fi
	draw_banner "$(get_local_phrase "MID")"
	gtts_speak "mid"
	mid="$(read_number)"
	if [ "$mid" == "" ]; then
		gtts_speak "closed"
		return
	fi
	draw_banner "$(get_local_phrase "TREBLE")"
	gtts_speak "treble"
	treble="$(read_number)"
	if [ "$treble" == "" ]; then
		gtts_speak "closed"
		return
	fi

	if [ "$bass" == "0" ] && [ "$mid" == "0" ] && [ "$treble" == "0" ]; then
		gtts_speak "equalizer off"
	else
		gtts_speak "equalizer on"
	fi

	bass="$bass:$bass:$bass"
	mid="$mid:$mid:$mid:$mid"
	treble="$treble:$treble:$treble"

	EQUALIZER="$bass:$mid:$treble"
	if [ "$1" != true ]; then
		echo -e "af_cmdline equalizer $EQUALIZER" >"$ALETHEIA/pipe$$" &
	fi

	equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
	equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
	equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"

	draw_volume
	draw_equalizer
	if [ "$1" != true ] && [ "$2" != true ]; then
		draw_pitch
		draw_position
	fi
}

print_queue() {
	if [ -n "$ESPEAK_PID" ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		unset ESPEAK_PID
	fi
	if [ "$GTTS_NATURAL_VOICE" == true ]; then
		pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	fi

	up() {
		already_said=false
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			if [ -e "$ALETHEIA/espeak.pid" ]; then
				kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			fi
		fi
		CHANGED=true
		if [ "$pos" == "1" ]; then
			return
		else
			FLAGGED=false
		fi
		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			number_per_page="$original_number_per_page"
		fi
		pos="$((pos-number_per_page))"
		if [ "$pos" -le "0" ]; then
			pos=1
		fi
		current=$pos
	}

	down() {
		already_said=false
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			if [ -e "$ALETHEIA/espeak.pid" ]; then
				kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			fi
		fi
		CHANGED=true
		if [ "$pos" -gt "$((TOTAL_QUEUE-number_per_page))" ]; then
			return
		fi
		if [ "$FLAGGED" == true ]; then
			return
		fi
		if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
			if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
				pos="$((TOTAL_QUEUE-number_per_page+1))"
			else
				pos="$((pos+number_per_page))"
			fi
		fi
		if [ "$current" -le "$truepos" ]; then
			current=$pos
		fi
	}

	top() {
		CHANGED=true
		pos=1
		current=1
		already_said=false
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			if [ -e "$ALETHEIA/espeak.pid" ]; then
				kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			fi
		fi
	}

	bottom() {
		CHANGED=true
		pos=$((TOTAL_QUEUE - number_per_page + 1))
		current=$TOTAL_QUEUE
		already_said=false
		if [ "$GTTS_NATURAL_VOICE" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
			if [ -e "$ALETHEIA/espeak.pid" ]; then
				kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			fi
		fi
	}

	already_said=false
	current=$POSITION
	BUFFER_BACKUP="$BUFFER"
	show_filename=false

	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi

	original_number_per_page="$number_per_page"

	FLAGGED=false
	REDRAWN=false

	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup 1
	else
		tput cup 2
	fi

	CHANGED=false

	stty -echo
	HALF="$((POSITION % number_per_page + (number_per_page/2) + 1))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
			HALF="1"
		else
			HALF="1"
		fi
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
			number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$((original_number_per_page*2 - 1))" ]; then
		HALF="$((POSITION-(original_number_per_page/2)))"
	fi

	if [ "$((TOTAL_QUEUE-POSITION))" -lt "$number_per_page" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page+3))"
	fi
	if [ "$((HALF+original_number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page))"
		number_per_page="$original_number_per_page"
	fi

	half_page="$((number_per_page/2))"
	if [ "$POSITION" -gt "$half_page" ]; then
		result="$((POSITION-half_page))"
		if [ "$((number_per_page % 2))" != "" ]; then
			HALF="$result"
		else
			HALF=$((1+result))
		fi

		if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$((TOTAL_QUEUE-number_per_page+1))"
		fi
	fi

	if [ "$HALF" -gt "$((TOTAL_QUEUE-number_per_page))" ]; then
		HALF="$((TOTAL_QUEUE-number_per_page+1))"
	fi
	if [ "$HALF" -lt "1" ]; then
		HALF=1
	fi

	pos=$HALF
	while [ "$pos" -le "$TOTAL_QUEUE" ]; do
		stty -echo
		echo -ne "$NOCOLOR"
		if [ "$((TOTAL_QUEUE-pos))" -lt "$number_per_page" ] && [ "$pos" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi
		if [ "$((pos+number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
			number_per_page="$original_number_per_page"
		fi
		if [ "$pos" -gt "$TOTAL_QUEUE" ]; then
			return 200
		fi
		if [ "$number_per_page" -gt "$TOTAL_QUEUE" ]; then
			number_per_page="$TOTAL_QUEUE"
		fi
		flaggy=false
		if [ "$pos" -le "$POSITION" ] && [ "$((pos+number_per_page-1))" -ge "$POSITION" ] || [ "$CHANGED" == true ] ; then
			if [ "$pos" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" != "1" ]; then
				number_per_page="$original_number_per_page"
				pos="$((pos-number_per_page))"
			fi
			x=0
			end=$((number_per_page-1))
			_last=$((pos+end))
			diff=$((_last-pos+1))
			truepos=$((i-1+pos))
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				tput cup 1
			else
				tput cup 2
			fi
			m=$pos
			new_buf=""
			tmp_buf=()
			for i in $(seq 1 "$number_per_page"); do
				_REP="$WHITE"
				if [ "$m" == "$POSITION" ] && [ "$PANELS_ENABLED" == true ]; then
					_REP="$WHITE_BLACK"
				fi

				n=${queue_array[$((m-1))]}
				ext=${n##*.}
				piece=${n%.*}
				piece=${piece%.*}
				if [ -e "${piece}.repeat.${ext}" ]; then
					if [ "$m" == "$POSITION" ] && [ "$PANELS_ENABLED" ]; then
						REP="$BLUE_BLACK"
					else
						REP="$BLUE"
					fi
				else
					REP=""
				fi
				if [ -e "$n.locked" ]; then
					if [ -e "$n.repeats" ]; then
						INDICATOR="${_REP}$REP#"
					else
						INDICATOR="${_REP}$"
					fi
				else
					if [ -e "$n.repeats" ]; then
						INDICATOR="${_REP}$REP&"
					else
						INDICATOR="${_REP} "
					fi
				fi
				if [ "$TOTAL_QUEUE" -gt "9" ]; then
					if [ "$m" -lt "10" ]; then
						pad=" "
					else
						pad=""
					fi
					display_pad="$pad"
				fi
				if [ "$POSITION" == "$m" ]; then
					rep=""
				else
					rep="$BLUE"
				fi
				if [ "$current" == "$m" ] || [ "$POSITION" == "$m" ]; then
					value=$((COLUMNS-(${#PADDING}*2)-3-${#m}-${#display_pad}))
					if [ "$show_filename" == true ]; then
						nline=${queue_array[m-1]##*/}
					else
						nline="$(get_metadata "$m")"
						nline=${nline///\~}
					fi
					if [ "${#nline}" -gt "$value" ]; then
						nline="${nline:0:value-1}"
					fi
					newline="${nline:0:$value}"
					padd="$(printf '%*s' $((value-${#newline})) "")"
					new_buf="$new_buf$BLUE_BLACK${PADDING}$INDICATOR$BLUE_BLACK $display_pad$BLUE_BLACK$m $rep$newline$padd$PADDING$NOCOLOR\n"
				else
					if [ "$show_filename" == true ]; then
						nline=${queue_array[m-1]##*/}
					else
						nline="$(get_metadata "$m")"
						nline=${nline///\~}
					fi
					value=$((COLUMNS-(${#PADDING}*2)-3-${#m}-${#display_pad}))
					if [ "${#nline}" -gt "$value" ]; then
						nline="${nline:0:value-1}"
					fi
					newline="${nline:0:$value}"
					new_buf="$new_buf${PADDING}$BLUE$INDICATOR$BLUE $display_pad$BLUE$m $WHITE$newline$(tput el)\n"
				fi
				tmp_buf[i-1]="$m$nline"
				m=$((m+1))
			done

			echo -ne "$new_buf"

			if [ "$already_said" == false ]; then
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
				fi
				if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
					if [ -e "$ALETHEIA/espeak.pid" ]; then
						kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
					fi
				fi
				chained=()
				index=0
				for i in $(seq 0 $((${#tmp_buf[@]}-1))); do
					chained[index]="${tmp_buf[i]%%*}"
					((index++))
					chained[index]="${tmp_buf[i]##*}"
					chained[index]=${chained[index]//\~/\-}
					((index++))
				done
				gtts_speak_chain "${chained[@]}" &
				already_said=true
			fi

			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				empty_pane "$((number_per_page+2))"
			fi
		else
			pos="$((pos+number_per_page))"
			continue
		fi

		draw_banner "$(get_local_phrase "QUEUE")"
		tput rc
		
		read -rsn1 inputchar
		tput civis
		stty -ixon
		if [ "$inputchar" == "k" ]; then
			up
		elif [ "$inputchar" == "j" ]; then
			down
		elif [ "$inputchar" == "h" ]; then
			if [ "$current" == "$TOTAL_QUEUE" ]; then
				continue
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			line="${queue_array[current]##*/}"
			line="${line%.*}"
			gtts_speak "$line"
			current=$((current+1))
			if [ "$current" -gt "$truepos" ]; then
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$((TOTAL_QUEUE-number_per_page+1))"
					else
						pos="$((pos+number_per_page))"
					fi
				fi
			fi

			skip=true
		elif [ "$inputchar" == "l" ]; then
			if [ "$current" == "1" ]; then
				continue
			fi
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			fi
			current=$((current-1))
			line="${queue_array[$(($((current-1))))]##*/}"
			line="${line%.*}"
			gtts_speak "$line"
			if [ "$current" -lt "$pos" ]; then
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			fi

			skip=true
		elif [ "$(is_num "$inputchar")" != "0" ]; then
			up_down="$(read_line "$inputchar")"
			if [ "$(is_num "$up_down")" != "0" ]; then
				up_down="${up_down#"${up_down%%[!0]*}"}"
				if [ "$up_down" -lt "1" ]; then
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				elif [ "$up_down" -le "$TOTAL_QUEUE" ]; then
					JUMP="$up_down"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				fi
			fi
		elif [ "$inputchar" == "b" ]; then
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM_BACK
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST_BACK
			elif [ "$ONLY_LOCKED" == true ]; then
				return $RETURN_ONLY_LOCKED_BACK
			else
				return $RETURN_BACK
			fi
		elif [ "$inputchar" == "n" ]; then
			if [ "$GTTS_NATURAL_VOICE" == true ]; then
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			fi
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				return $RETURN_NEXT
			fi
		elif [ "$inputchar" == "" ]; then
			if [ "$USE_TAGS" == true ]; then
				draw_banner "$(get_local_phrase "FILENAME")"
				USE_TAGS=false
			else
				draw_banner "$(get_local_phrase "TAGS")"
				USE_TAGS=true
			fi
			sleep $BANNER_WAIT_TIME
		elif [ "$inputchar" == "g" ]; then
			tag_mp3 false "${queue_array[current-1]}" true
			continue
		elif [ "$inputchar" == "" ]; then
			update_cache "${queue_array[current-1]}"
			continue
		elif [ "$inputchar" == "D" ]; then
			if [ "$current" == "$POSITION" ]; then
				delete false
			else
				delete false "$current" "${queue_array[current-1]}"
			fi
			ret=$?
			if [ "$ret" != "200" ]; then
				return "$ret"
			fi
			continue
		elif [ "$inputchar" == "" ]; then
			if [ "$current" == "$POSITION" ]; then
				delete true
			else
				delete true "$current" "${queue_array[current-1]}"
			fi
			ret=$?
			if [ "$ret" != "200" ]; then
				return "$ret"
			fi
			continue
		elif [ "$inputchar" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			CHANGED=true
			REDRAWN=true
			pos=1
			clear
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page=$((LINES-2))
			else
				number_per_page=$((LINES-4))
			fi
			original_number_per_page=$number_per_page
			draw_volume
			draw_equalizer
			draw_banner "$(get_local_phrase "QUEUE")"
			draw_position
			reset_buffer
			continue
		elif [ "$inputchar" == "?" ]; then
			queue_help_screen
			if [ "$TOTAL_QUEUE" -lt "$((LINES - 4))" ]; then
				empty_pane $((TOTAL_QUEUE + 2))
			fi
		elif [ "$inputchar" == "x" ]; then
			if [ "$TOTAL_QUEUE" == "1" ]; then
				continue
			fi
			for (( i=$((current-1)); i < ${#queue_array[@]}; i++ )); do
				queue_array[i]="${queue_array[i+1]}"
			done
			TOTAL_QUEUE=$((TOTAL_QUEUE-1))
			draw_position
			if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
				number_per_page=$TOTAL_QUEUE
			fi
			if [ "$((pos+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				if [ "$pos" -gt 1 ]; then
					pos=$((pos-1))
				fi
			fi
			if [ "$((current-1))" == "$TOTAL_QUEUE" ]; then
				current=$((current-1))
			fi
			if [ "$current" == "$POSITION" ]; then
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				POSITION=$((POSITION-1))
			elif [ "$current" -lt "$POSITION" ]; then
				POSITION=$((POSITION-1))
			fi
		elif [ "$inputchar" == "<" ]; then
			if [ "$current" -lt "$TOTAL_QUEUE" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$((POSITION+1))
				elif [ "$((current+1))" == "$POSITION" ]; then
					POSITION=$((POSITION-1))
				fi
				tmp="${queue_array[current]}"
				queue_array[current]="${queue_array[current-1]}"
				queue_array[current-1]="$tmp"
				current=$((current+1))
				if [ "$current" -gt "$truepos" ]; then
					if [ -n "$ESPEAK_PID" ]; then
						kill "$ESPEAK_PID" >/dev/null 2>/dev/null
						unset ESPEAK_PID
					fi
					CHANGED=true
					if [ "$FLAGGED" == true ]; then
						continue
					fi
					if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
						if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
							pos="$((TOTAL_QUEUE-number_per_page+1))"
						else
							pos="$((pos+number_per_page))"
						fi
					fi
				fi
			fi
		elif [ "$inputchar" == ">" ]; then
			if [ "$current" -gt "1" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$((POSITION-1))
				elif [ "$((current-1))" == "$POSITION" ]; then
					POSITION=$((POSITION+1))
				fi
				tmp="${queue_array[current-2]}"
				queue_array[current-2]="${queue_array[current-1]}"
				queue_array[current-1]="$tmp"
				current=$((current-1))
				if [ "$current" -lt "$((truepos-number_per_page+1))" ]; then
					if [ -n "$ESPEAK_PID" ]; then
						kill "$ESPEAK_PID" >/dev/null 2>/dev/null
						unset ESPEAK_PID
					fi
					CHANGED=true
					if [ "$pos" == "1" ]; then
						continue
					else
						FLAGGED=false
					fi
					if [ "$number_per_page" -lt "$original_number_per_page" ]; then
						number_per_page="$original_number_per_page"
					fi
					pos="$((pos-number_per_page))"
					if [ "$pos" -le "0" ]; then
						pos=1
					fi
				fi
			fi
		elif [ "$inputchar" == "p" ]; then
			if [ "$PAUSE" == true ]; then
				draw_position
				gtts_speak "unpaused"
			else
				gtts_speak "paused"
			fi
			toggle_pause true
			continue
		elif [ "$inputchar" == "d" ]; then
			toggle_voice
			already_said=false
		elif [ "$inputchar" == "'" ]; then
			top
		elif [ "$inputchar" == "c" ]; then
			if [ "$show_filename" == true ]; then
				show_filename=false
			else
				show_filename=true
			fi
		elif [ "$inputchar" == "\"" ]; then
			bottom
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[A')
				up
				;;
			'[B')
				down
				;;
			'[1')
				read -rsn2 -t 0.001
				;;
			'[2')
				read -rsn2 -t 0.001
				;;
			'[3')
				read -rsn2 -t 0.001
				;;
			'[5')
				read -rsn1 -t 0.001
				up
				;;
			'[6')
				read -rsn1 -t 0.001
				down
				;;
			'[H')
				top
				;;
			'[F')
				bottom
				;;
			*)
				if [ "${key:0:1}" == "O" ]; then
					read -rsn1 -t 0.001
				else
					if [ "$REDRAWN" == false ]; then
						BUFFER="$BUFFER_BACKUP"
					fi
					echo -ne "$NOCOLOR"
					reset_buffer
					draw_equalizer
					draw_volume
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				fi
				;;
			esac
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == ";" ] || [ "$inputchar" == $'\e' ]; then
			if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
				if [ -e "$ALETHEIA/espeak.pid" ]; then
					kill "$(<"$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				fi
			fi
			BUFFER="$BUFFER_BACKUP"
			echo -ne "$NOCOLOR"
			reset_buffer
			draw_volume
			draw_equalizer
			redraw_buffer
			draw_pitch
			draw_position
			gtts_speak_chain "queue closed" "main screen" &
			return 200
		elif [ "$inputchar" == "" ]; then
			if [ -n "$ESPEAK_PID" ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				unset ESPEAK_PID
			fi
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			JUMP="$current"
			draw_position
			return $RETURN_JUMP
		fi
	done
	redraw_screen true
}

_save_setting() {
	if [ "$(echo "$CONFIG" | grep -i "^$1[[:space:]]*=")" == "" ]; then
		if [ -z "$CONFIG" ]; then
			CONFIG="$1=$2"
		else
			CONFIG="$CONFIG\n$1=$2"
		fi
	else
		CONFIG="$(echo -ne "$CONFIG" | sed -e "/^$1[[:space:]]*=/s/.*/$1=$2/g")"
	fi
}

save_settings() {
	draw_banner "$(get_local_phrase "SAVE")" true
	gtts_speak "save settings?"
	while true; do
		read -rsn1 yesno
		if [ "$yesno" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "$(get_local_phrase "SAVE")" true
			redraw_screen false 1 1 0 0
		else
			break
		fi
	done
	if [ "$yesno" == "y" ]; then
		_save_setting "VOICE_PITCH" "$VOICE_PITCH"
		_save_setting "DEFAULT_VOLUME" "$DEFAULT_VOLUME"
		_save_setting "VOICE_VOLUME" "$VOICE_VOLUME"
		_save_setting "VOICE_ENABLED" "$VOICE_ENABLED"
		_save_setting "VOICE_ENGINE" "$VOICE_ENGINE"
		_save_setting "PANELS_ENABLED" "$PANELS_ENABLED"
		_save_setting "ONLY_VOICE_TITLES" "$ONLY_VOICE_TITLES"
		_save_setting "THEME_ENABLED" "$THEME_ENABLED"
		_save_setting "DEFAULT_EQUALIZER" "$DEFAULT_EQUALIZER"
		_save_setting "USE_TAGS" "$USE_TAGS"
		if [ "$VOICE_ENABLED" == true ]; then
			_save_setting "VOICE_ENABLED" "true"
		else
			_save_setting "VOICE_ENABLED" "false"
		fi
		echo -e "$CONFIG" >"$ALETHEIA/config"
		gtts_speak "saved" true
	else
		gtts_speak "canceled" true
	fi
	draw_pitch
	draw_position
}

main() {
	if [ -e "$ALETHEIA/pipe$$" ]; then
		rm -f "$ALETHEIA/pipe$$"
	fi
	mkfifo "$ALETHEIA/pipe$$"
	exec 3<> "$ALETHEIA/pipe$$"
	PAUSE=false
	MUTE=false
	LOCKED=false
	SCALETEMPO=false
	FLAGS=""
	START_MARKER="0.0"
	END_TIME=""
	space=0
	SAVED_INTERVAL=""
	SAVED_POSITION=()
	CURRENT_POSITION=""
	SAVED_TOTAL=""
	CONTENTS=
	LOCK_SELECTION=0
	LOCK_TOTAL=0

	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LOWER_LIMIT=$(bc <<<"$EDO*2.6")
	INTERVAL_UPPER_LIMIT=$(bc <<<"$EDO*2.1")

	if [ -e "$FILENAME.locked" ]; then
		LOCKED=true

		if [ "$LOCKED_OFF" == false ]; then
			read_locked_file "$(<"$FILENAME.locked")"
			if [ "$?" == "1" ]; then
				LOCKED=false
			fi
		fi

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi

		FLAGS="-speed $(calc -pd "2^($INTERVAL/$EDO)") -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"

		if [ "$_scaletempo_flag" == "1" ]; then
			FLAGS="$FLAGS,scaletempo=speed=tempo"
			SCALETEMPO=true
		elif [ "$_scaletempo_flag" == "2" ]; then
			FLAGS="$FLAGS,scaletempo=speed=pitch"
			SCALETEMPO=true
			ONLY_PITCH=true
		else
			SCALETEMPO=false
		fi
	else
		FLAGS="-speed $(calc -pd "2^($DEFAULT_INTERVAL/$DEFAULT_EDO)") -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"
	fi

	if [ -e "$FILENAME.repeats" ]; then
		REPEATS="$(<"$FILENAME.repeats")"
		REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
		if [ "$BACK" == true ]; then
			REPEAT_CURRENT="$REPEAT_TOTAL"
		else
			REPEAT_CURRENT=1
		fi
	else
		REPEATS=""
		REPEAT_CURRENT=0
		REPEAT_TOTAL=0
	fi

	LOOP=false
	echo -ne "$NOCOLOR"
	reset_buffer
	redraw_buffer
	draw_equalizer
	draw_volume

	if [[ "$TITLE" == *" - "* ]]; then
		ARTISTSONG="$ARTIST - $SONG"
	else
		ARTISTSONG="$TITLE"
	fi
	if [ "$ONLY_VOICE_TITLES" == true ]; then
		gtts_speak "$ARTISTSONG" false false true
	else
		gtts_speak "$ARTISTSONG"
	fi

	LOCKED_EDO="$EDO"

	if [ "$VIDEO" == false ]; then
		FLAGS+=" -novideo"
	fi
	if [ "$FULLSCREEN" == true ]; then
		FLAGS+=" -fs"
	fi
	if [ "$ALWAYS_ON_TOP" == true ]; then
		FLAGS+=" -ontop"
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		FLAGS+=" -volume 0"
	fi

	rm -f "$ALETHEIA/mplayer_output$$" >/dev/null 2>/dev/null

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
		var1="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev).repeat.$ext"
		if [ ! -e "$var1" ]; then
			var1="$FILENAME"
		fi
	else
		var1="$FILENAME"
	fi

	# shellcheck disable=SC2086
	# Uses word splitting to expand $FLAGS for use by mplayer
	"${MPLAYER_PATH}"mplayer -slave -osdlevel 0 -softvol -softvol-max 100 -hr-mp3-seek -quiet -input file="$ALETHEIA/pipe$$" -noconfig all $FLAGS "$var1" >"$ALETHEIA/mplayer_output$$" 2>"$ALETHEIA/mplayer_output_stderr$$" </dev/null &

	MPLAYER_PID="$!"

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		SELECT_REPEAT_FILE=false
	fi
	
	if [ "$REPEAT_ONLY" == true ]; then
		repeat
		repeat_tmp=$?
		if [ "$repeat_tmp" != "200" ]; then
			return $repeat_tmp
		else
			gtts_speak_chain "loop closed" "main screen" &
		fi
	else
		draw_pitch
		draw_position
	fi

	old_LINES=$LINES
	old_COLUMNS=$COLUMNS

	stty -echo
	while true; do
		if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
			clear
			draw_wait false
			reset_dimensions
			redraw_screen false
			if [ "$MUTE" == true ]; then
				draw_banner "$(get_local_phrase "MUTE")"
			elif [ "$PAUSE" == true ]; then
				draw_banner "$(get_local_phrase "PAUSE")"
			fi
			gtts_speak "screen redrawn"
			old_LINES=$LINES
			old_COLUMNS=$COLUMNS
		fi
		if [ "$WEB_CLIENT" == "0" ]; then
				IFS= read -rsn1 -t "$MAIN_REFRESH_TIME" input
				if [ "$input" == $'\e' ]; then
					read -rsn2 -t 0.001 tmpkey
					if [ "$tmpkey" == "[1" ]; then
						read -rsn2 -t 0.001
						continue
					elif [ "$tmpkey" == "[2" ]; then
						read -rsn2 -t 0.001 tmpkey2
						if [ "$tmpkey2" == "~" ]; then
							insert
						fi
						continue
					elif [ "$tmpkey" == "[3" ]; then
						read -rsn1 -t 0.001
						delete
						ret=$?
						if [ "$ret" != "200" ]; then
							return "$ret"
						fi
						continue
					elif [ "$tmpkey" == "[5" ]; then
						read -rsn1 -t 0.001
						continue
					elif [ "$tmpkey" == "[6" ]; then
						read -rsn1 -t 0.001
						continue
					elif [ "${tmpkey:0:1}" == "O" ]; then
						continue
					elif [ "$tmpkey" == "[A" ]; then
						pitch_up
						ret=$?
						if [ "$OUTPUT" != "" ]; then
							input=$OUTPUT
						fi
						if [ "$ret" != "200" ]; then
							return $ret
						fi
						continue
					elif [ "$tmpkey" == "[B" ]; then
						pitch_down
						ret=$?
						if [ "$OUTPUT" != "" ]; then
							input=$OUTPUT
						fi
						if [ "$ret" != "200" ]; then
							return $ret
						fi
						continue
					elif [ "$tmpkey" == "[D" ]; then
						seek_left
					elif [ "$tmpkey" == "[C" ]; then
						seek_right
						ret="$?"
						if [ "$ret" != "200" ]; then
							return "$ret"
						fi
						continue
					fi
				fi
		#else
		#	read -rsn1 -t 0.2 input
			#if [ "$input" == "" ] && [ "$WEB_CLIENT" == "1" ]; then
			#	read -rsn1 -t 0.3 input <"$ALETHEIA/web_client_pipe$$"
			#fi
		fi

		if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				return $RETURN_NEXT
			fi
		fi

		case "$input" in
			'j')
				pitch_down
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'k')
				pitch_up
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'o')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				;;
			'm')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				;;
			'i')
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'p')
				toggle_pause
				;;
			' ')
				toggle_pause
				;;
			'n')
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					return $RETURN_NEXT
				fi
				;;
			'b')
				if [ "$POSITION" == "0" ]; then
					POSITION=1
				fi
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ -n "$ESPEAK_PID" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					unset ESPEAK_PID
				fi
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices.*" >/dev/null 2>/dev/null
				fi
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM_BACK
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST_BACK
				elif [ "$ONLY_LOCKED" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					return $RETURN_BACK
				fi
				;;
			'8')
				system_volume_change false 3 3
				;;
			'9')
				system_volume_change true 3 3
				;;
			'y')
				set_default_edo
				;;
			'h')
				seek_left
				;;
			'l')
				seek_right
				ret="$?"
				if [ "$ret" != "200" ]; then
					return "$ret"
				fi
				;;
			';')
				BUFFER_BACKUP="$BUFFER"
				print_queue
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
				;;
			'?')
				help_screen
				draw_volume
				draw_equalizer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'q')
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$_input" != "" ]; then
					if [ "$_input" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					fi
				fi
				draw_banner "$(get_local_phrase "QUIT")" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "do you want to quit?"
				fi
				input_char=""
				while true; do
					read -rn1 input_char
					if [ "$input_char" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					elif [ "$input_char" == "q" ] || [ "$input_char" == $'\e' ]; then
						if [ -n "$ESPEAK_PID" ]; then
							kill "$ESPEAK_PID" >/dev/null 2>/dev/null
							unset ESPEAK_PID
						fi
						if [ "$GTTS_NATURAL_VOICE" == true ]; then
							pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
						fi
						draw_pitch
						draw_position
						break
					elif [ "$input_char" == "n" ]; then
						draw_pitch
						draw_position
						break
					fi
				done
				gtts_speak_chain "quit canceled" "main screen" &
				;;
			'P')
				old_percent=0
				percentbreak=false
				gtts_speak_chain "progress bar enabled" &
				local tmp_SONG_LENGTH=
				tmp_SONG_LENGTH="$(date -u -d @"$CURRENT_SONG_LENGTH" +%H:%M:%S)"
				IFS=':' read -r hours minutes seconds <<< "$tmp_SONG_LENGTH"
				if ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
					echo "pausing_keep_force get_percent_pos" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					percent_pos="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d'=' -f2)"
					if [ "$(is_num "$percent_pos")" == "0" ]; then
						percent_pos=1
					fi
					if [ "$hours" == "00" ]; then
						available_space=$((COLUMNS-(${#PADDING}*2)-14))
					else
						available_space=$((COLUMNS-(${#PADDING}*2)-17))
					fi
					PAUSE=false
					tput cup $LINES
					echo -ne "$BLUE_BLACK${PADDING}00$WHITE_BLACK:${BLUE_BLACK}00 [$WHITE_BLACK"
					percent_pos=$(calc -pd "$percent_pos/100*$available_space+1")
					percent_pos="${percent_pos%%.*}"
					if [ "$percent_pos" -gt "$available_space" ]; then
						percent_pos="$available_space"
					fi
					printf '%*s' "$percent_pos" "" | tr " " "="
					printf '%*s' $((available_space - percent_pos)) ""
					if [ "$hours" == "00" ]; then
						tput cup $LINES $((COLUMNS-${#PADDING}-8))
						echo -ne "$BLUE_BLACK ] $minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING"
					else
						tput cup $LINES $((COLUMNS-${#PADDING}-11))
						echo -ne "$BLUE_BLACK ] $hours$WHITE_BLACK:$BLUE_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING"
					fi
					if [ "${hours:0:1}" == "0" ]; then
						hours="${hours:1:1}"
					fi
					if [ "${minutes:0:1}" == "0" ]; then
						minutes="${minutes:1:1}"
					fi
					if [ "${seconds:0:1}" == "0" ]; then
						seconds="${seconds:1:1}"
					fi
					if [ "$hours" == "0" ]; then
						total_seconds=$((minutes * 60 + seconds))
						tput cup $LINES $((COLUMNS-5-${#PADDING}))
					else
						total_seconds=$(((hours * 60 * 60) + (minutes * 60) + seconds))
						tput cup $LINES $((COLUMNS-8-${#PADDING}))
					fi
					if [ "$INTERVAL" -lt "0" ]; then
						int="$(echo -ne "$INTERVAL" | cut -c 2-)"
						neg=true
						skip=false
					elif [ "$INTERVAL" -gt "0" ]; then
						int="$INTERVAL"
						neg=false
						skip=false
					else
						skip=true
					fi
					if [ "$skip" == false ]; then
						if [ "$neg" == true ]; then
							adjusted_total_seconds="$(calc -pd "$total_seconds * ($int / $EDO) + $total_seconds")"
							adjusted_total_seconds="${adjusted_total_seconds%%.*}"
						else
							adjusted_total_seconds="$(calc -pd "$total_seconds * (($int / $EDO)/2)")"
							adjusted_total_seconds="${adjusted_total_seconds%%.*}"
							adjusted_total_seconds=$((total_seconds-adjusted_total_seconds))
						fi
						if [ "${adjusted_total_seconds:0:1}" == "-" ]; then
							adjusted_hours=0
							adjusted_minutes=0
							adjusted_seconds=0
						else
							adjusted_hours=$((adjusted_total_seconds / 3600))
							adjusted_minutes=$(((adjusted_total_seconds % 3600) / 60))
							adjusted_seconds=$((( (adjusted_total_seconds % 3600) % 60) % 60))
						fi
					else
						adjusted_hours=$hours
						adjusted_minutes=$minutes
						adjusted_seconds=$seconds
					fi
					if [ "$adjusted_hours" == "0" ]; then
						tput cup $LINES $((COLUMNS-5-${#PADDING}))
					else
						tput cup $LINES $((COLUMNS-8-${#PADDING}))
					fi
					adjusted_hours="$(printf '%02d' "$adjusted_hours")"
					adjusted_minutes="$(printf '%02d' "$adjusted_minutes")"
					adjusted_seconds="$(printf '%02d' "$adjusted_seconds")"
					if [ "$adjusted_hours" == "00" ]; then
						echo -ne "$BLUE$adjusted_minutes$WHITE:$BLUE$adjusted_seconds"
					else
						echo -ne "$BLUE$adjusted_hours$WHITE:$BLUE$adjusted_minutes$WHITE:$BLUE$adjusted_seconds"
					fi
					tput cup $LINES $((7+${#PADDING}))
					l=0
					input_char=""
					until [ "$input_char" != "" ]; do
						if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
							if [ "$TRACK_RANDOM" == true ]; then
								return $RETURN_TRACK_RANDOM
							elif [ "$LOOP_ARTIST" == true ]; then
								return $RETURN_LOOP_ARTIST
							else
								return $RETURN_NEXT
							fi
						fi
						echo -e "pausing_keep_force get_percent_pos\npausing_keep_force get_time_pos" >"$ALETHEIA/pipe$$" &
						sleep $MPLAYER_WAIT_TIME
						percent_pos="$(tail -2 "$ALETHEIA/mplayer_output$$" | head -1)"
						percent_pos="${percent_pos#*=}"
						time_pos="$(tail -1 "$ALETHEIA/mplayer_output$$")"
						time_pos="${time_pos#*=}"
						time_pos="${time_pos%%.*}"
						tput cup $LINES ${#PADDING}
						if [ "$(is_num "$percent_pos")" == "0" ]; then
							percent_pos=1
						fi
						if [ "$(is_num "$time_pos")" == "1" ]; then
							current_time="$(date -u -d @"$time_pos" +%H:%M:%S)"
							time_unavailable=false
						else
							current_time="00:00:00"
							percent_pos=$available_space
							time_unavailable=true
						fi
						if [ "${current_time%%:*}" == "00" ]; then
							time_notation="${current_time#*:}"
							echo -ne "$BLUE_BLACK${time_notation%%:*}$WHITE_BLACK:$BLUE_BLACK${time_notation##*:} ["
							available_space=$((COLUMNS-(${#PADDING}*2)-14))
						else
							time_notation="${current_time#*:}"
							echo -ne "$BLUE${current_time%%:*}$WHITE_BLACK:$BLUE_BLACK${time_notation%%:*}$WHITE_BLACK:$BLUE_BLACK${time_notation##*:} ["
							available_space=$((COLUMNS-(${#PADDING}*2)-17))
						fi
						if [ "$time_unavailable" == false ]; then
							if [ "$INTERVAL" -lt "0" ]; then
								int="$(echo -ne "$INTERVAL" | cut -c 2-)"
								neg=true
								skip=false
							elif [ "$INTERVAL" -gt "0" ]; then
								int="$INTERVAL"
								neg=false
								skip=false
							else
								skip=true
							fi
							if [ "$skip" == false ]; then
								if [ "$neg" == true ]; then
									adjusted_total_seconds="$(calc -pd "$total_seconds * ($int / $EDO) + $total_seconds")"
									adjusted_total_seconds="${adjusted_total_seconds%%.*}"
								else
									adjusted_total_seconds="$(calc -pd "$total_seconds * (($int / $EDO)/2)")"
									adjusted_total_seconds="${adjusted_total_seconds%%.*}"
									adjusted_total_seconds=$((total_seconds-adjusted_total_seconds))
								fi
								if [ "${adjusted_total_seconds:0:1}" == "-" ]; then
									adjusted_hours=0
									adjusted_minutes=0
									adjusted_seconds=0
								else
									adjusted_hours=$((adjusted_total_seconds / 3600))
									adjusted_minutes=$(((adjusted_total_seconds % 3600) / 60))
									adjusted_seconds=$((((adjusted_total_seconds % 3600) % 60) % 60))
								fi
							else
								adjusted_hours=$hours
								adjusted_minutes=$minutes
								adjusted_seconds=$seconds
							fi
							adjusted_hours="$(printf '%02d' "$adjusted_hours")"
							adjusted_minutes="$(printf '%02d' "$adjusted_minutes")"
							adjusted_seconds="$(printf '%02d' "$adjusted_seconds")"
							if [ "${current_time%%:*}" == "00" ]; then
								if [ "$adjusted_hours" == "00" ]; then
									available_space=$((COLUMNS-(${#PADDING}*2)-14))
								else
									available_space=$((COLUMNS-(${#PADDING}*2)-17))
								fi
								tput cup $LINES $((7+${#PADDING}))
							else
								if [ "$adjusted_hours" == "00" ]; then
									available_space=$((COLUMNS-(${#PADDING}*2)-17))
								else
									available_space=$((COLUMNS-(${#PADDING}*2)-20))
								fi
								tput cup $LINES $((10+${#PADDING}))
							fi

							if [ "$(is_num "$percent_pos")" == "0" ]; then
								percent_pos=$available_space
							fi
							percent_pos=$(calc -pd "$percent_pos/100*$available_space+1")
							percent_pos="${percent_pos%%.*}"
							if [ "$percent_pos" -gt "$available_space" ]; then
								percent_pos="$available_space"
							fi

							echo -ne "$WHITE_BLACK"
							printf '%*s' "$percent_pos" "" | tr " " "="
							printf '%*s' $((available_space - percent_pos)) ""
							if [ "$adjusted_hours" == "00" ]; then
								echo -ne "$BLUE_BLACK] $adjusted_minutes$WHITE_BLACK:$BLUE_BLACK$adjusted_seconds"
							else
								echo -ne "$BLUE_BLACK] $adjusted_hours$WHITE_BLACK:$BLUE_BLACK$adjusted_minutes$WHITE_BLACK:$BLUE_BLACK$adjusted_seconds"
							fi
						fi
						read -rn1 -t 1 input_char
						if [ "$input_char" == "l" ]; then
							if [ "$old_percent" -gt "$percent_pos" ]; then
								percentbreak=true
								break
							fi

							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									return $RETURN_NEXT
								fi
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							input_char=""
						elif [ "$input_char" == "h" ]; then
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_position
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							input_char=""
						elif [ "$input_char" == "j" ]; then
							pitch_down false true
							input_char=""
						elif [ "$input_char" == "k" ]; then
							pitch_up false true
							input_char=""
						fi
						l=0
						old_percent=$percent_pos
					done
					if [ "$percentbreak" == true ]; then
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST
						else
							return $RETURN_NEXT
						fi
					fi

					if [ "$MUTE" == true ]; then
						draw_banner "$(get_local_phrase "MUTE")"
					else
						draw_pitch
					fi
					draw_position
					gtts_speak_chain "progress bar disabled" "main screen" &
				fi
				;;
			'$')
				gtts_speak "position saved"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.05
				draw_banner "$(get_local_phrase "POS SAVED")"
				sleep $BANNER_WAIT_TIME
				if [ "${#SAVED_POSITION[@]}" == "0" ]; then
					SAVED_TOTAL=1
					SAVED_POSITION[1]="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d '=' -f2)"
					CURRENT_POSITION=1
				else
					SAVED_TOTAL=$((SAVED_TOTAL+1))
					SAVED_POSITION[SAVED_TOTAL]="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d '=' -f2)"
				fi
					
				draw_pitch
				draw_position
				;;
			'|')
				vanish
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'`')
				draw_banner "$(get_local_phrase "COMMAND")"
				gtts_speak "enter command"
				command="$(read_line)"
				if [ "$command" == "about" ]; then
					about
					read -rsn1 _
				elif [ "${command%% *}" == "say" ]; then
					command="${command#* }"
					gtts_speak "$command"
				elif [ "$command" != "" ]; then
					echo -e "$command" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					empty_pane
					tput cup $((LINES-3))
					echo -ne "$PADDING$WHITE$(tail -1 "$ALETHEIA/mplayer_output$$")"
					tput el
					read -rn1 input_char
				fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			"\\")
				SAVED_POSITION=()
				CURRENT_POSITION=""
				if [ "$VIDEO" == true ] || [ "$VIDEO_FLAGGED" == true ]; then
					JUMP="$POSITION"
					kill "$MPLAYER_PID" 2>/dev/null >/dev/null
					if [ "$VIDEO" == false ]; then
						VIDEO_FLAGGED=false
					fi
					return $RETURN_JUMP
				else
					echo "seek 0 2" >"$ALETHEIA/pipe$$" &
					if [ "$PAUSE" == true ]; then
						PAUSE=false
						draw_pitch
						draw_position
					fi
				fi
				;;
			'5')
				draw_banner "$(get_local_phrase "START")"
				gtts_speak "start"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d '=' -f2)"
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep "$(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)"
				fi
				draw_pitch
				draw_position
				;;
			'%')
				if [ -e "$FILENAME.repeats" ]; then
					draw_banner "$(get_local_phrase "DELETE LOOPS")" true
					gtts_speak "delete loops?"
					read -rsn1 tmp_
					if [ "$tmp_" == "y" ] || [ "$tmp_" == "Y" ]; then
						rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
						gtts_speak_chain "loops deleted" "main screen" &
						if [ "$NO_VERTICAL_PADDING" == true ]; then
							tput cup $((LOCKING_POS+1)) 1
						else
							tput cup $((LOCKING_POS+2)) 1
						fi
						if [ -e "$FILENAME.locked" ]; then
							INDICATOR="${WHITE_BLACK}&"
						else
							INDICATOR="$BLUE_BLACK "
						fi
						echo -ne "$INDICATOR"
					else
						gtts_speak_chain "delete canceled" "main screen" &
					fi
					draw_pitch
					draw_position
				else
					gtts_speak_chain "no loops to delete" "main screen" &
				fi
				;;
			'7')
				draw_banner "$(get_local_phrase "END")"
				gtts_speak "end"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_TIME="$(tail -1 "$ALETHEIA/mplayer_output$$" | cut -d '=' -f2)"
				END_MARKER=$END_TIME
				space=0
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep "$(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)"
				fi
				draw_pitch
				draw_position
				;;
			'&')
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					SELECT_REPEAT_FILE=true
					JUMP="$POSITION"
					kill "$MPLAYER_PID"
					return $RETURN_JUMP
				else
					gtts_speak "none"
					draw_banner "$(get_local_phrase "NONE")"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'6')
				repeat
				repeat_tmp="$?"
				gtts_speak_chain "loop closed" "main screen" &
				if [ "$repeat_tmp" != "200" ] && [ "$repeat_tmp" != "300" ]; then
					return $repeat_tmp
				fi
				;;
			'0')
				get_system_volume
				tmp_volume_left="$(echo "$SYSTEM_VOLUME_LEFT" | cut -d'%' -f1)"
				tmp_volume_right="$(echo "$SYSTEM_VOLUME_RIGHT" | cut -d'%' -f1)"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					total="$tmp_volume_left"
				elif [ "$tmp_volume_right" -gt "$tmp_volume_left" ]; then
					total="$tmp_volume_right"
				else
					continue
				fi

				gtts_speak "balancing volume"

				draw_banner "$(get_local_phrase "BALANCING")"

				flaggy=false
				while [ "$tmp_volume_left" != "$tmp_volume_right" ]; do
					if [ "$tmp_volume_left" -lt "$total" ]; then
						tmp_volume_left=$((tmp_volume_left+1))
					elif [ "$tmp_volume_left" -gt "$total" ]; then
						tmp_volume_left=$((tmp_volume_left-1))
					fi

					if [ "$tmp_volume_right" -lt "$total" ]; then
						tmp_volume_right=$((tmp_volume_right+1))
					elif [ "$tmp_volume_right" -gt "$total" ]; then
						tmp_volume_right=$((tmp_volume_right-1))
					fi

					get_system_volume
					pactl set-sink-volume @DEFAULT_SINK@ "${tmp_volume_left}"% "${tmp_volume_right}"%
					draw_volume 2 3
					read -rsn1 -t 0.08 c
					ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					if [ "$c" == $'\e' ] || [ "$c" == "q" ] || [ "$c" == "0" ]; then
						flaggy=true
						break
					elif [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 0 1
						draw_banner "$(get_local_phrase "BALANCING")"
					fi
				done
				draw_pitch
				if [ "$flaggy" == true ]; then
					get_system_volume
					continue
				fi
				;;
			')')
				get_system_volume
				tmp_volume_left="$(echo "$SYSTEM_VOLUME_LEFT" | cut -d'%' -f1)"
				tmp_volume_right="$(echo "$SYSTEM_VOLUME_RIGHT" | cut -d'%' -f1)"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					SYSTEM_VOLUME_RIGHT="${tmp_volume_left}%"
				else
					SYSTEM_VOLUME_LEFT="${tmp_volume_right}%"
					tmp_volume_left=$tmp_volume_right
				fi

				pactl set-sink-volume @DEFAULT_SINK@ "$SYSTEM_VOLUME_LEFT" "$SYSTEM_VOLUME_RIGHT"
				draw_volume
				gtts_speak "$tmp_volume_left"
				;;
			'G')
				oscillate
				;;
			'')
				update_cache
				;;
			'')
				if [ "$INTERVAL" == "0" ]; then
					continue
				fi
				if [ "$PAUSE" == true ]; then
					echo -e "pause" >"$ALETHEIA/pipe$$" &
					PAUSE=false
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				draw_banner "$(get_local_phrase "INVERT")" false true
				old_int="$INTERVAL"
				INTERVAL="$((-(INTERVAL)))"
				gtts_speak "scaling"
				if [ "$INTERVAL" -lt "0" ]; then
					result="$old_int"
				else
					result="$INTERVAL"
				fi
				result="$((result*2))"
				x=0
				if [ "$old_int" -gt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				while [ "$x" -lt "$result" ]; do
					read -rsn1 -t "$SCALE_SPEED" c
					ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					secondary_scale_func "$c" "$(get_local_phrase "INVERT")"
					if [ "$c" == "c" ]; then
						x=$((result-x))
						if [ "$NEGATIVE" == true ]; then
							NEGATIVE=false
						else
							NEGATIVE=true
						fi
					#FIXME
					elif [ "$c" == "o" ]; then
						old_int=$((old_int*2))
					elif [ "$c" == "m" ]; then
						old_int=$INTERVAL
					elif [ "$c" == "z" ]; then
						x2=$x
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "$(get_local_phrase "INVERT")" false true
						x=$x2
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
						draw_banner "$(get_local_phrase "INVERT")" false true
					elif [ "$c" == "q" ] || [ "$c" == $'\e' ] || [ "$c" == "m" ]; then
						break
					elif [ "$c" == "" ]; then
						if [ "$NEGATIVE" == false ]; then
							INTERVAL="$((old_int-1))"
							old_int="$((old_int-1))"
						else
							INTERVAL="$((old_int+1))"
							old_int="$((old_int+1))"
						fi
						echo -e "speed_set $(calc -pd "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x="$((x+1))"
					fi

				done
				gtts_speak " $INTERVAL"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'M')
				invert_int
				;;
			'f')
				swap_lock true
				draw_pitch
				draw_position
				;;
			'F')
				swap_lock
				draw_pitch
				draw_position
				;;
			'W')
				add_downloaded
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				;;
			'J')
				edo_down
				;;
			'I')
				read_corner
				draw_pitch
				draw_position
				;;
			'K')
				edo_up
				;;
			'<')
				if [ "$VIDEO" == true ]; then
					gtts_speak "video disabled"
					VIDEO=false
					draw_banner "$(get_local_phrase "OFF")"
					echo "vo_ontop 0" >"$ALETHEIA/pipe$$" &
				else
					gtts_speak "video enabled"
					VIDEO=true
					VIDEO_FLAGGED=true
					draw_banner "$(get_local_phrase "VIDEO ON")"
					echo "vo_ontop 1" >"$ALETHEIA/pipe$$" &
				fi
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				JUMP="$POSITION"
				return "$RETURN_JUMP"
				;;
			'>')
				if [ "$FULLSCREEN" == false ]; then
					echo "pausing_keep vo_fullscreen 1" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=true
					gtts_speak "video fullscreen"
					draw_banner "$(get_local_phrase "FULLSCREEN")"
				else
					gtts_speak "video normal"
					echo "pausing_keep vo_fullscreen 0" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=false
					draw_banner "$(get_local_phrase "OFF")"
				fi
				stty -echo
				sleep $BANNER_WAIT_TIME
				stty echo
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'U')
				scale_edo
				;;
			'Z')
				gtts_speak "save queue as?"
				draw_banner "$(get_local_phrase "SAVE QUEUE")"
				tmp="$(read_line)"
				if [ "$tmp" != "" ]; then
					if [ ! -e "$ALETHEIA/playlists/" ]; then
						mkdir "$ALETHEIA/playlists"
					fi
					echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
					gtts_speak "saved"
				else
					gtts_speak "canceled"
				fi
				draw_pitch
				draw_position
				;;
			'c')
				toggle_mute
				;;
			't')
				zero_interval
				if [ "$?" == "$RETURN_QUIT" ]; then
					return $RETURN_QUIT
				fi
				;;
			'H')
				less_precise
				;;
			'L')
				more_precise
				;;
			'Y')
				zero_interval_jump
				;;
			'x')
				lock
				draw_pitch
				draw_position
				;;
			'X')
				unlock
				draw_pitch
				draw_position
				;;
			'a')
				PAUSE=false
				set_equalizer
				draw_pitch
				;;
			'')
				if [ "$CURRENT_POSITION" != "" ]; then
					CURRENT_POSITION=$((CURRENT_POSITION+1))
					if [ "$CURRENT_POSITION" -gt "$SAVED_TOTAL" ]; then
						CURRENT_POSITION=1
					fi
					echo "seek ${SAVED_POSITION[$CURRENT_POSITION]} 2" >"$ALETHEIA/pipe$$" &
				fi
				;;
			'v')
				toggle_scale_tempo
				;;
			'')
				theme_submenu
				;;
			'')
				gtts_speak " $INTERVAL" false false true
				;;
			'')
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "$(get_local_phrase "NONE")"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'')
				if [ "$USE_TAGS" == true ]; then
					draw_banner "$(get_local_phrase "FILENAME")"
					USE_TAGS=false
				else
					draw_banner "$(get_local_phrase "TAGS")"
					USE_TAGS=true
				fi
				sleep $BANNER_WAIT_TIME
				reset_buffer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'')
				add_downloaded true
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "$(get_local_phrase "NONE")"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'd')
				toggle_voice
				draw_pitch
				;;
			':')
				if [ "$DIMENSIONS_RESET" == true ]; then
					render_all_help_screens
					DIMENSIONS_RESET=false
				fi
				setup_screen
				;;
			'/')
				set_custom_edo
				;;
			'4')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_all_tuning
				;;
			'w')
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_to_locked
				;;
			'T')
				toggle_feedback_level
				;;
			'z')
				check_config
				if [ "$THEME_FILE" != "" ]; then
					check_colors true
				fi
				tput civis
				stty -ixon
				draw_wait false
				reset_dimensions
				redraw_screen false
				if [ "$MUTE" == true ]; then
					draw_banner "$(get_local_phrase "MUTE")"
				elif [ "$PAUSE" == true ]; then
					draw_banner "$(get_local_phrase "PAUSE")"
				fi
				gtts_speak "screen redrawn"
				;;
			'O')
				edit_submenu false true
				if [ "$?" == "$RETURN_JUMP" ]; then
					return "$RETURN_JUMP"
				fi
				;;
			',')
				if [ "$GTTS_NATURAL_VOICE" == true ]; then
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				fi
				gtts_speak "$TITLE" true
				;;
			'')
				NO_WAIT=true
				if [ "$LOCKED" == true ]; then
					if [ "$REPEAT_CURRENT" -lt "1" ]; then
						say_locked_and_no_loops
					else
						say_locked_and_loops
					fi
				else
					if [ "$REPEAT_CURRENT" -lt "1" ]; then
						say_unlocked_and_no_loops
					else
						say_unlocked_and_loops
					fi
				fi
				NO_WAIT=false
				draw_pitch
				draw_position
				;;
			'D')
				delete
				ret=$?
				if [ "$ret" != "200" ]; then
					return "$ret"
				fi
				;;
			'')
				delete true
				ret=$?
				if [ "$ret" != "200" ]; then
					return "$ret"
				fi
				;;
			"'")
				jump_to_first_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'"')
				jump_to_last_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'N')
				if [ "$SHUFFLED" == false ]; then
					if [ "$ARTIST" != "" ]; then
						last="$(echo -ne "${queue_array[$((TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/ - //" | cut -d'' -f1)"
					else
						last="$(echo -ne "${queue_array[$((TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev)"
					fi
					if [ "$ARTIST" != "$last" ]; then
						IFS=$'\n'
						if [ "$ARTIST" != "" ]; then
							tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$ARTIST - " | tail -1 | cut -d':' -f1)"
						else
							tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$TITLE" | tail -1 | cut -d':' -f1)"
						fi
						unset IFS
						JUMP="$((tmpq+1))"
						unset tmpq
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				fi
				;;
			'B')
				if [ "$SHUFFLED" == false ]; then
					IFS=$'\n'
					if [ "$ARTIST" != "" ]; then
						tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$ARTIST - " | head -1 | cut -d':' -f1)"
					else
						tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$TITLE" | head -1 | cut -d':' -f1)"
					fi
					if [ "$tmpq" -gt "1" ]; then
						last_artist="$(echo -ne "${queue_array[$((tmpq-2))]}" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev)"
						if [ "$(echo -ne "$last_artist" | grep " - ")" != "" ]; then
							last_artist="$(echo -ne "$last_artist" | sed "s/ - //g" | cut -d'' -f1)"
							JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$last_artist - " | head -1 | cut -d':' -f1)"
						else
							JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -n "/$last_artist" | head -1 | cut -d':' -f1)"
						fi
					fi
					unset IFS
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			's')
				start_search false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'S')
				new_playlist false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'	')
				insert
				if [ "$?" == "$RETURN_JUMP" ]; then
					return "$RETURN_JUMP"
				fi
				;;
			'Q')
				queue_controls false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'#')
				save_settings
				;;
			'r')
				draw_banner "$(get_local_phrase "RENAME")" true
				gtts_speak "rename file?"
				read -rsn1 yesno
				if [ "$yesno" == "y" ]; then
					ext="$(echo "$FILENAME" | rev | cut -d'.' -f1 | rev)"
					path="$(echo "$FILENAME" | rev | cut -d'/' -f2- | rev)"
					if [ "$(echo "$path" | grep '/')" == "" ]; then
						path="."
					fi
					gtts_speak "enter the new title"
					tput rc
					echo -ne "$WHITE_BLACK"
					printf '%*s' $((COLUMNS - 14)) ""
					tput rc
					echo -ne "$WHITE_BLACK"
					newname="$(read_line)"
					if [ "$newname" == "" ]; then
						redraw_buffer
						draw_pitch
						draw_position
						gtts_speak_chain "rename canceled" "main screen" &
						continue
					fi
					mv "$FILENAME" "${path}/$newname.$ext" >/dev/null 2>/dev/null
					if [ -e "$ALETHEIA/voices$VOICE_APPEND/$TITLE.mp3" ]; then
						rm -f "$ALETHEIA/voices$VOICE_APPEND/$TITLE.mp3"
					fi
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "${path}/$newname.$ext.locked" >/dev/null 2>/dev/null
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "${path}/$newname.$ext.repeats" >/dev/null 2>/dev/null
					fi
					gtts_speak "$newname" true
					if [ "$POSITION" == "" ]; then
						POSITION=1
					fi

					export TITLE="$newname"
					export FILENAME="${path}/$newname.$ext" >/dev/null 2>/dev/null
					queue_array[POSITION-1]="$FILENAME"

					reset_buffer
					draw_volume
					draw_equalizer
					redraw_buffer
					draw_pitch
					draw_position
					continue
				else
					gtts_speak_chain "rename canceled" "main screen" &
				fi
				redraw_screen true
				;;
			'*')
				system_volume_change false 1 1
				;;
			'(')
				system_volume_change true 1 1
				;;
			'!')
				pcm_volume_change "$input"
				ret="$?"
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'1')
				pcm_volume_change "$input"
				ret="$?"
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'2')
				pcm_volume_change "$input"
				;;
			'@')
				pcm_volume_change "$input"
				;;
			'3')
				fade_volume
				;;
			'V')
				set_loop_artist
				;;
			'e')
				track_toggle
				if [ "$?" == 200 ]; then
					JUMP=1
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$GTTS_NATURAL_VOICE" == true ]; then
						pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
					fi
					return $RETURN_JUMP
				fi
				;;
			'g')
				tag_mp3 false
				redraw_buffer
				;;
			'')
				invert_colors
				;;
			'')
				update_metadata_db
				reset_buffer
				redraw_buffer
				;;
			'')
				toggle_pause false true
				;;
			'')
				if [ "$LOCKED_OFF" == true ]; then
					LOCKED_OFF=false
					gtts_speak "locked on"
					draw_banner "$(get_local_phrase "LOCK ON")"
				else
					LOCKED_OFF=true
					gtts_speak "locked off"
					draw_banner "$(get_local_phrase "LOCK OFF")"
				fi
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				;;
			'')
				load_loop_file
				;;
			'')
				REPEAT_ONLY=true
				gtts_speak "loop mode" true
				JUMP="$POSITION"
				kill "$MPLAYER_PID"
				return $RETURN_JUMP
				;;
			'E')
				set_loop
				;;
			'~')
				set_sleep
				;;
			'R')
				shuffle_queue
				SHUFFLED=true
				draw_pitch
				draw_position
				;;
			'A')
				sort_queue
				SHUFFLED=false
				draw_position
				;;
			'.')
				set_custom_int
				;;
			'u')
				scale
				;;
			'C')
				set_scale_speed
				;;
			'')
				set_random
				;;
			'-')
				scale_octave "-" true
				;;
			'=')
				scale_octave "+" true
				;;
			'_')
				scale_octave "-"
				;;
			'+')
				scale_octave "+"
				;;
			*)
				process_key "$input"
				;;
		esac
	done
}

if [ ! -d "$ALETHEIA/voices$VOICE_APPEND/" ]; then
	mkdir "$ALETHEIA/voices$VOICE_APPEND/"
fi

if [ ! -d "$ALETHEIA/playlists/" ]; then
	mkdir "$ALETHEIA/playlists"
fi

if [ ! -d "$MUSICDIR" ]; then
	mkdir -p "$MUSICDIR"
fi

if [ ! -d "$SOUNDDIR" ]; then
	mkdir -p "$SOUNDDIR"
fi

if [ ! -d "$VIDEODIR" ]; then
	mkdir -p "$VIDEODIR"
fi

for pid in "$ALETHEIA/mplayer_output_stderr"*; do
	_pid="${pid##*/}"
	_pid="${_pid//mplayer_output_stderr/}"
	if ! pgrep -x "aletheia" | grep -wq "$_pid"; then
		rm -f "$pid" >/dev/null 2>&1
	fi
done

for pid in "$ALETHEIA/mplayer_output"*; do
	_pid="${pid##*/}"
	_pid="${_pid//mplayer_output/}"
	if ! pgrep -x "aletheia" | grep -wq "$_pid" && ! grep -q "stderr" <<<"$_pid"; then
		rm -f "$pid" >/dev/null 2>&1
	fi
done

for pid in "$ALETHEIA/pipe"*; do
	_pid="${pid##*/}"
	_pid="${_pid//pipe/}"
	if ! pgrep -x "aletheia" | grep -wq "$_pid"; then
		rm -f "$pid" >/dev/null 2>&1
	fi
done

for pid in "$ALETHEIA/start"*; do
	_pid="${pid##*/}"
	_pid="${_pid//start/}"
	if ! pgrep -x "aletheia" | grep -wq "$_pid"; then
		rm -f "$pid" >/dev/null 2>&1
	fi
done

if [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	rm -f "$ALETHEIA/web_client_pipe"*
	mkfifo "$ALETHEIA/web_client_pipe$$"
fi

tput sc

if [ "$2" != "" ]; then
	KEYWORDS="$(echo "$@" | cut -d' ' -f2-)"
fi

rendered=false

if [ "$1" == "--music" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$MUSICDIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	SHUFFLED=true
elif [ "$1" == "--sound" ] || [ "$WEB_CLIENT" == "1" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$SOUNDDIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	SHUFFLED=true
	if [ "$WEB_CLIENT" == "1" ]; then
		node "$HOME/webserver.js" >/dev/null 2>/dev/null &
		NODE_PID="$!"
	fi
elif [ "$1" == "--video" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${VIDEO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$VIDEODIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	VIDEO=false
elif [ "$1" == "--directory" ]; then
	if [ "$2" != "" ]; then
		if [ -d "$2" ]; then
			if [ "$3" != "" ]; then
				KEYWORD="${*:3}"
				KEYWORD="${KEYWORD// /.*}"
				regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
			else
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
			fi
			mapfile -t queue_array < <(find "$2" -type f -iregex "$regex" | shuf)
			TOTAL_QUEUE=${#queue_array[@]}
			nodir=false
		else
			nodir=true
		fi
	else
		nodir=true
	fi
	if [ "$nodir" == true ]; then
		clear
		tput cup $LINES
		echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
		exit 1
	fi
elif [ "$1" == "--file" ]; then
	if [ "$2" == "" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}No file specified."
		exit 1
	elif [ -e "$2" ]; then
		queue_array[0]="$(realpath "$2")"
		TOTAL_QUEUE=1
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}'$2' does not exist."
		exit 1
	fi
elif [ "$1" == "--playlist" ]; then
	if [ -e "$2" ]; then
		mapfile -t queue_array < "$2"
		TOTAL_QUEUE=${#queue_array[@]}
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Playlist file '$2' does not exist."
		exit 1
	fi
elif [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	node "$HOME/webserver.js" >/dev/null 2>/dev/null &
	NODE_PID="$!"

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" == "--mplayer-path" ]; then
	if [ "$2" == "" ]; then
		echo -e "${RED}Error: ${WHITE}--mplayer-path <path>"
		exit 1
	else
		if [ -d "$2" ]; then
			MPLAYER_PATH="$2/"
		else
			if [ -e "$2" ]; then
				echo -e "${RED}Error: ${WHITE}$2 is not a directory.$NOCOLOR"
				exit 1
			else
				echo -e "${RED}Error: ${WHITE}Directory $2 does not exist.$NOCOLOR"
				exit 1
			fi
		fi
	fi
	render_all_help_screens
	empty_pane

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" != "" ]; then
	KEYWORD="${*}"
	KEYWORD="${KEYWORD// /.*}"
	regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
	mapfile -t queue_array < <(find "$MUSICDIR" "$SOUNDDIR" "$VIDEODIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
else
	if [ "$WEB_CLIENT" == "1" ]; then
		node "$HOME/webserver.js" >/dev/null 2>/dev/null &
		NODE_PID="$!"
	fi

	render_all_help_screens
	empty_pane

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
fi

if [ "$TOTAL_QUEUE" == "0" ]; then
	tput cup $LINES
	if [ "$2" == "" ]; then
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found."
	else
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
	fi
	exit 1
fi

if [ "$rendered" == false ]; then
	render_all_help_screens
	empty_pane
fi

if [ "$start_at_pos" == "" ]; then
	start_at_pos=1
fi

POSITION=$start_at_pos
RUNTHROUGH=false

while (( (POSITION <= TOTAL_QUEUE) && (POSITION >= 1) )); do
	FILENAME="${queue_array[$((POSITION-1))]}"
	TITLE="${FILENAME##*/}"
	TITLE="${TITLE%.*}"
	LOOP_ON=false

	if [ ! -e "$FILENAME" ]; then
		draw_banner "$(get_local_phrase "MISSING")"
		sleep $BANNER_WAIT_TIME
		for i in $(seq "$POSITION" $((TOTAL_QUEUE-1))); do
			queue_array[i-1]=${queue_array[$i]}
		done
		continue
	fi

	if [[ "$TITLE" == *" - "* ]]; then
		ARTIST="${TITLE%% - *}"
		SONG="${TITLE##* - }"
	else
		ARTIST=""
		SONG=""
	fi

	if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
		RUNTHROUGH=true
	fi

	if [ "$ONLY_LOCKED" == true ]; then
		if [ ! -e "$FILENAME.locked" ]; then
			if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					if [ "$RUNTHROUGH" == false ]; then
						JUMP="1"
						RETURN="$RETURN_JUMP"
						RUNTHROUGH=true
					else
						web_client_func
						main
						RETURN="$?"
					fi
				else
					RETURN="0"
				fi
			fi
		else
			if [ "$REPEAT_ONLY" == true ]; then
				if [ ! -e "$FILENAME.repeats" ]; then
					if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
						RETURN="0"
					fi
				else
					web_client_func
					main
					RETURN="$?"
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		fi
	else
		if [ "$REPEAT_ONLY" == true ]; then
			if [ ! -e "$FILENAME.repeats" ]; then
				if [ "$LOOP_ARTIST" == true ]; then
					RETURN="$RETURN_LOOP_ARTIST"
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						if [ "$RUNTHROUGH" == false ]; then
							JUMP="1"
							RETURN="$RETURN_JUMP"
							RUNTHROUGH=true
						else
							web_client_func
							main
							RETURN="$?"
						fi
					else
						if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
							RETURN="0"
						fi
					fi
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		else
			web_client_func
			main
			RETURN="$?"
		fi
	fi

	if [ "$RETURN" == "$RETURN_QUIT" ]; then
		echo -ne "$NOCOLOR"
		exit 0
	elif [ "$RETURN" == "$RETURN_BACK" ]; then
		if [ "$POSITION" == "1" ]; then
			POSITION=$TOTAL_QUEUE
		else
			POSITION=$((POSITION - 1))
		fi
		TRACK_RANDOM=false
	elif [ "$RETURN" == "$RETURN_RESTART" ]; then
		continue
	elif [ "$RETURN" == "$RETURN_JUMP" ]; then
		POSITION="$JUMP"
		POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
		RIGHT_BANNER_WIDTH=$POSITION_WIDTH
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST" ]; then
		new_POSITION="$(printf '%s\n' "${queue_array[@]}" | sed "1,${POSITION}d" | grep -ni "/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$((new_POSITION+POSITION))"
		else
			if [ "$ARTIST" == "" ]; then
				LOOP_ARTIST=false
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					POSITION=1
				else
					POSITION=$((POSITION+1))
				fi
			else
				POSITION="$(printf '%s\n' "${queue_array[@]}" | grep -ni "/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
			fi
		fi
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST_BACK" ]; then
		if [ "$ARTIST" == "" ]; then
			LOOP_ARTIST=false
			if [ "$POSITION" != "1" ]; then
				POSITION=$((POSITION-1))
			fi
		else
			new_POSITION="$(printf '%s\n' "${queue_array[@]}" | sed "${POSITION},${TOTAL_QUEUE}d" | tac | grep -ni "/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
			if [ "$new_POSITION" != "" ]; then
				POSITION="$((POSITION-new_POSITION))"
			else
				POSITION="$(printf '%s\n' "${queue_array[@]}" | grep -ni "/$LOOP_ARTIST_NAME -" | tail -1 | cut -d':' -f1)"
			fi
		fi
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM" ]; then
		POSITION="$((1 + RANDOM % TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM_BACK" ]; then
		POSITION="$((1 + RANDOM % TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_ONLY_LOCKED_BACK" ]; then
		POSITION="$((POSITION-1))"
		if [ "$POSITION" == "0" ]; then
			POSITION="$TOTAL_QUEUE"
		elif [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=0
		fi
	else
		if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=1
		else
			POSITION=$((POSITION+1))
		fi
	fi
done

echo -ne "$NOCOLOR"
exit 0
