#!/bin/bash

# aletheia: a media player with pitch controls and voice feedback
#
# Copyright 2021-2023 Brad Hermanson <apeitheo@gmail.com>
#
# Aletheia is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License, version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details,
# available at https://www.gnu.org/licenses/
#
# Support: https://www.patreon.com/aletheia_project

OS=$(uname -s)
# MacOS needs work
OS="Linux"
PROGRAM_NAME="aletheia"
SCRIPT_NAME=$(echo "$0" | rev | cut -d'/' -f1 | rev)
SCRIPT_PATH=$(realpath "$0")
VERSION="0.9.6"
ESPEAK_DIGITAL_VOICE=${ESPEAK_DIGITAL_VOICE:-false}
MAIN_REFRESH_TIME=${REFRESH_TIME:-0.2}

if [ "$1" == "--version" ]; then
	echo "$VERSION"
	exit 0
elif [ "$1" == "--help" ]; then
	space="`printf '%*s' ${#PROGRAM_NAME}`"
	echo -e "Usage: $PROGRAM_NAME [option] [<file/directory>|keyword]"
	echo
	echo -e "        $space--file <file>"
	echo -e "        $space--directory <directory>"
	echo -e "        $space--playlist <file>"
	echo
	echo -e "        $space--music [keyword]"
	echo -e "        $space--sound [keyword]"
	echo -e "        $space--video [keyword]"
	echo
	echo -e "        $space--server"
	echo -e "        $space--version"
	echo
	echo -e "See \`man $PROGRAM_NAME\` for more help."
	exit 0
fi

tput init
tput civis
stty -echo
stty -ixon
clear

ALETHEIA="$HOME/.aletheia"
MUSICDIR=${MUSICDIR:-"$HOME/Music/"}
SOUNDDIR=${SOUNDDIR:-"$HOME/Sounds/"}
VIDEODIR=${VIDEODIR:-"$HOME/Videos/"}

WEB_CLIENT=${WEB_CLIENT:-0}

HELP_BUFFER=()
VOICE_HELP_BUFFER=()
TMP_BUFFER=()
TWO_COLUMN=false
VOICE_TWO_COLUMN=false
SCALE_SPEED=0.2
DEFAULT_SCALE_SPEED=$SCALE_SPEED
DIMENSIONS_RESET=false
QUEUE_BUFFER=()
QUEUE_RENDERED=false
OUTPUT=""
SELECT_REPEAT_FILE=false
LOOP_ON=false
SAVED_POSITION=""
CURRENT_POSITION=""
PANELS_ENABLED=true
VOLUME_CONTROL_DISABLED=false
MENTIONED=false
BANNER_WAIT_TIME=0.6
MPLAYER_WAIT_TIME=0.1

LINE_CHAR="\033(0"
LINE_CHAR_END="\033(B"
TOP_BAR_MENU="${LINE_CHAR}lqqqqqqqqk$LINE_CHAR_END"
BOTTOM_BAR_MENU="${LINE_CHAR}mqqqqqqqqj$LINE_CHAR_END"
BAR="${LINE_CHAR}x${LINE_CHAR_END}"
DARK_BACKGROUND=${DARK_BACKGROUND:-true}
NOCOLOR="\033[0m"

if [ "$DARK_BACKGROUND" == true ]; then
	WHITE='\033[1;37m'
	LIGHTWHITE='\033[0;37m'
	WHITE_BLACK='\033[1;37;1;40m'
else
	WHITE='\033[1;30m'
	LIGHTWHITE='\033[0;30m'
	WHITE_BLACK='\033[1;30;1;40m'
fi

COLOR_PANEL="#162934"

if [ "$COLORS_ENABLED" == false ]; then
	GREEN_BLACK='\033[1;37;1;40m'
	BLUE_BLACK='\033[1;37;1;40m'
	RED_BLACK='\033[1;37;1;40m'
	CYAN_BLACK='\033[1;37;1;40m'
	YELLOW_BLACK='\033[1;37;1:40m'
	RED='\033[1;37m'
	LIGHTRED='\033[0;37m'
	GREEN='\033[1;37m'
	BLUE='\033[1;37m'
	YELLOW='\033[1;37m'
	LIGHTBLUE='\033[1;37m'
	PURPLE='\033[1;37m'
	CYAN='\033[1;37m'
else
	RED='\033[1;31m'
	LIGHTRED='\033[0;31m'
	GREEN='\033[1;32m'
	BLUE='\033[1;34m'
	YELLOW='\033[1;33m'
	LIGHTBLUE='\033[1;34m'
	PURPLE='\033[1;35m'
	CYAN='\033[1;36m'
	LIGHTCYAN='\033[0;36m'
	LIGHTRED='\033[0;31m'
	if [ "$PANELS_ENABLED" == true ]; then
		GREEN_BLACK='\033[1;32;1;40m'
		BLUE_BLACK='\033[1;34;1;40m'
		RED_BLACK='\033[1;31;1;40m'
		CYAN_BLACK='\033[1;36;1;40m'
		WHITE_BLACK='\033[1;37;1;40m'
		YELLOW_BLACK='\033[1;33;1:40m'
		LIGHTRED_BLACK='\033[0;31m;1;40m'
	else
		GREEN_BLACK='\033[1;32m'
		BLUE_BLACK='\033[1;34m'
		RED_BLACK='\033[1;31m'
		CYAN_BLACK='\033[1;36m'
		WHITE_BLACK='\033[1;37m'
		YELLOW_BLACK='\033[1;33m'
		LIGHTRED='\033[0;31m'
	fi
fi

RETURN_QUIT="1"
RETURN_BACK="2"
RETURN_RESTART="3"
RETURN_JUMP="4"
RETURN_LOOP_ARTIST="5"
RETURN_LOOP_ARTIST_BACK="6"
RETURN_TRACK_RANDOM="7"
RETURN_TRACK_RANDOM_BACK="8"
RETURN_ONLY_LOCKED_BACK="9"

DEFAULT_INTERVAL="0"
DEFAULT_EDO="60"
DEFAULT_VOLUME="50"
DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
EQUALIZER="$DEFAULT_EQUALIZER"
LOCKED_EDO=$DEFAULT_EDO
VOLUME=""
LOCKED_OFF=false
ONLY_PITCH=false

LOCKING_POS=0
EDO_LIMIT="1000000"
INTERVAL_LIMIT=`calc "$DEFAULT_EDO * 2.6"`
INTERVAL_UPPER_LIMIT=`calc "$DEFAULT_EDO * 2.1"`
SAVED_INTERVAL=""
SAVED_EDO=""

SEARCH=false
KEYWORD=""
FILENAME=""
ARTIST=""
SONG=""

SLEEPING=false
SUSPEND=false

LOOP=false
LOOP_ARTIST=false
TRACK_RANDOM=false
ONLY_LOCKED=false
REPEAT_ONLY=false
LOOPS_ONLY=false
SHUFFLED=false
REPEAT_ONLY_INDEX=""

JUMP=0
POSITION=0
TOTAL_QUEUE=0
LOOP_ARTIST_NAME=""
RIGHT_BANNER_WIDTH=0
LEFT_BANNER_WIDTH=0
CORNER_DIVIDER=":"

VIDEO=false
VIDEO_FLAGGED=false
FULLSCREEN=true
ALWAYS_ON_TOP=true
NO_QUEUE_FLAG=false

ARTIST=""
SONG=""
PICK=""
PLAY_PID=""
DOWNLOAD_POSITION=""
SONG_LENGTH=""
PADDING=" "

VOICE_ENABLED=false
VOICE_PITCH=0
VOICE_VOLUME=.85
ONLY_VOICE_TITLES=false

POSITION_WIDTH=0

get_system_volume() {
	if [ "$MENTIONED" == true ] || [ "$(echo -ne "$OS" | grep -i linux)" != "" ]; then
		IFS='/' read _ SYSTEM_VOLUME_LEFT _ SYSTEM_VOLUME_RIGHT _ <<<"$(pactl get-sink-volume @DEFAULT_SINK@)"
		SYSTEM_VOLUME_LEFT=${SYSTEM_VOLUME_LEFT// /}
		SYSTEM_VOLUME_RIGHT=${SYSTEM_VOLUME_RIGHT// /}
	elif [ "$OS" == "Darwin" ]; then
		volume_text=$(osascript -e 'output volume of (get volume settings) as text')
		# not sure it supports changing left and right channel separately;
		# at least with osascript?
		SYSTEM_VOLUME_LEFT=$volume_text
		SYSTEM_VOLUME_RIGHT=$volume_text
	else
		clear
		tput cup $(($LINES-3))
		echo "NOTE"
		echo "Aletheia does not currently support audio control using the '8' and '9' keys for adjusting system volume on your OS. Contact the developer for information on how to port to your OS of choice."
		echo "Do you want to continue [Y/n]? "
		read -rsn1 yn
		if [ "$yn" == "Y" ] || [ "$yn" == "y" ]; then
			SYSTEM_VOLUME_LEFT=100
			SYSTEM_VOLUME_RIGHT=100
			VOLUME_CONTROL_DISABLED=true
		else
			exit 0
		fi
	fi
	if [ "$MENTIONED" == false ]; then
		MENTIONED=true
	fi
}

get_system_volume

read_config() {
	echo -ne "`echo \"$CONFIG\" | grep -i "$1" | cut -d'=' -f2 | sed -e \"s/^ *//g\" | sed -e \"s/* $//g\" | tr '[:upper:]' '[:lower:]'`"
}

if [ -e "$ALETHEIA/config" ]; then
	CONFIG="`cat \"$ALETHEIA/config\"`"

	if [ "$CONFIG" != "" ]; then
		value="`read_config \"DEFAULT_VOLUME\"`"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		value="`read_config \"DEFAULT_INTERVAL\"`"
		if [ "$value" != "" ]; then
			DEFAULT_INTERVAL="$value"
		fi

		value="`read_config \"DEFAULT_EDO\"`"
		if [ "$value" != "" ]; then
			DEFAULT_EDO="$value"
		fi

		value="`read_config \"DEFAULT_EQUALIZER\"`"
		if [ "$value" != "" ]; then
			DEFAULT_EQUALIZER="$value"
		fi

		value="`read_config \"DEFAULT_VOLUME\"`"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		value="`read_config \"VOICE_ENABLED\"`"
		if [ "$value" != "" ]; then
			VOICE_ENABLED="$value"
		fi

		value="`read_config \"ONLY_VOICE_TITLES\"`"
		if [ "$value" != "" ]; then
			ONLY_VOICE_TITLES="$value"
		fi

		value="`read_config \"VOICE_PITCH\"`"
		if [ "$value" != "" ]; then
			VOICE_PITCH="$value"
		fi

		value="`read_config \"VOICE_VOLUME\"`"
		if [ "$value" != "" ]; then
			VOICE_VOLUME="$value"
		fi

		value="`read_config \"PANELS_ENABLED\"`"
		if [ "$value" != "" ]; then
			PANELS_ENABLED="$value"
		fi

		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;32;1;40m'
			BLUE_BLACK='\033[1;34;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32m'
			BLUE_BLACK='\033[1;34m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			WHITE_BLACK='\033[1;37m'
		fi

		value="`read_config \"DARK_BACKGROUND\"`"
		if [ "$value" != "" ]; then
			DARK_BACKGROUND="$value"
		fi

		value="`read_config \"COLORS_ENABLED\"`"
		if [ "$value" != "" ]; then
			COLORS_ENABLED="$value"
		fi

		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			RED='\033[1;37m'
			LIGHTRED='\033[0;37m'
			GREEN='\033[1;37m'
			BLUE='\033[1;37m'
			YELLOW='\033[1;37m'
			LIGHTBLUE='\033[1;37m'
			PURPLE='\033[1;37m'
			CYAN='\033[1;37m'
		else
			RED='\033[1;31m'
			LIGHTRED='\033[0;31m'
			GREEN='\033[1;32m'
			BLUE='\033[1;34m'
			YELLOW='\033[1;33m'
			LIGHTBLUE='\033[1;34m'
			PURPLE='\033[1;35m'
			CYAN='\033[1;36m'
			LIGHTCYAN='\033[0;36m'
			LIGHTRED='\033[0;31m'
			if [ "$PANELS_ENABLED" == true ]; then
				GREEN_BLACK='\033[1;32;1;40m'
				RED_BLACK='\033[1;31;1;40m'
				CYAN_BLACK='\033[1;36;1;40m'
				BLUE_BLACK='\033[1;34;1;40m'
				WHITE_BLACK='\033[1;37;1;40m'
			else
				GREEN_BLACK='\033[1;32m'
				RED_BLACK='\033[1;31m'
				CYAN_BLACK='\033[1;36m'
				BLUE_BLACK='\033[1;34m'
				WHITE_BLACK='\033[1;37m'
			fi
		fi
		if [ "$DARK_BACKGROUND" == true ]; then
			WHITE='\033[1;37m'
			LIGHTWHITE='\033[0;37m'
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK='\033[1;37;1;40m'
			else
				WHITE_BLACK='\033[1;37m'
			fi
		else
			WHITE='\033[1;30m'
			LIGHTWHITE='\033[0;30m'
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK='\033[1;30;1;40m'
			else
				WHITE_BLACK='\033[1;30m'
			fi
		fi

		value="`read_config \"COLOR_HIGHLIGHT\"`"
		if [ "$value" != "" ]; then
			COLOR_HIGHLIGHT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			BLUE="\033[1;38;2;${red};${green};${blue}m"
			ORIG_BLUE=$BLUE
		fi
		ORIG_BLUE_BLACK=$BLUE_BLACK

		value="`read_config \"COLOR_UNSELECTED\"`"
		if [ "$value" != "" ]; then
			COLOR_UNSELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			WHITE="\033[1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="\033[1;38;2;${red};${green};${blue};1;40m"
			else
				WHITE_BLACK="\033[1;38;2;${red};${green};${blue}m"
			fi
			ORIG_WHITE=$WHITE
			ORIG_WHITE_BLACK=$WHITE_BLACK
		fi

		value="`read_config \"COLOR_PANEL\"`"
		if [ "$value" != "" ]; then
			COLOR_PANEL="$value"

			colorblue="${COLOR_PANEL#"#"}"
			bred=$((16#${colorblue:0:2}))
			bgreen=$((16#${colorblue:2:2}))
			bblue=$((16#${colorblue:4:2}))

			colorwhite="${COLOR_UNSELECTED#"#"}"
			wred=$((16#${colorwhite:0:2}))
			wgreen=$((16#${colorwhite:2:2}))
			wblue=$((16#${colorwhite:4:2}))
			
			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${WHITE%m};48;2;$bred;$bgreen;${bblue}m"
				BLUE_BLACK="${BLUE%m};48;2;$bred;$bgreen;${bblue}m"
			fi
			COLOR_ACCENT="\033[1;38;2;$bred;$bgreen;${bblue}m"
		fi

		value="`read_config \"COLOR_SELECTED\"`"
		if [ "$value" != "" ]; then
			COLOR_SELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			GREEN="\033[1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				GREEN_BLACK="\033[1;38;2;${red};${green};${blue};1;40m"
			else
				GREEN_BLACK="\033[1;38;2;${red};${green};${blue}m"
			fi
		fi
	fi
fi

compute() {
	# if no pitch change requested, eliminate the overhead of calling sox to
	# change the default pitch of Google's digital voice
	if [ "$VOICE_PITCH" == "0" ]; then
		gtts-cli " $1" -o "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
	else
		gtts-cli " $1" -o "/tmp/_$2-tmp.mp3" >/dev/null 2>/dev/null
		sox "/tmp/_$2-tmp.mp3" "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" speed `calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-` >/dev/null 2>/dev/null
		rm -f "/tmp/_$2-tmp.mp3"
	fi
	play -v "$VOICE_VOLUME" "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
}

gtts_speak() {
	if [ "$VOICE_ENABLED" == true ] || [ "$2" == true ] || [ "$4" == true ]; then
		if [ "$ONLY_VOICE_TITLES" == false ] && [ "$VOICE_ENABLED" == false ] && [ "$4" != true ]; then
			return
		fi
		if [ ! -e "$ALETHEIA/voices/" ]; then
			mkdir "$ALETHEIA/voices"
		fi
		if [ "$5" != true ]; then
			#killall gtts-cli >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
		fi
		line_count="`echo -ne \"$1\" | wc -l`"
		if [ "$line_count" -gt 1 ]; then
			clip="`echo -ne \"$1\" | head -1` - $line_count"
		else
			if [ "`echo -ne \"$1\" | cut -c 1`" == " " ]; then
				clip="`echo -ne \"$1\" | cut -c 2-`"
			else
				clip="$1"
			fi
			if [ "`echo -ne \"$1\" | cut -c 1`" == "\-" ]; then
				clip="\\$clip"
			fi
		fi
		if [ -e "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" ]; then
			if [ "`echo -ne \"$clip\" | rev | cut -c 1`" == "?" ]; then
				clip="`echo -ne \"$clip\" | rev | cut -c 2- | rev`\\?"
			fi
			if [ "`echo -e \"$VOICE_VOLUME > 1.0\" | bc`" == "1" ]; then
				VOICE_VOLUME=.85
			fi
			if [ "$2" == false ] || [ "$2" == "" ]; then
				play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
				PLAY_PID="$!"
			else
				play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
			fi
		else
			if [ "$line_count" -gt 1 ]; then
				if [ "$2" == false ] || [ "$2" == "" ]; then
					compute "$1" "$clip" >/dev/null 2>/dev/null &
				else
					compute "$1" "$clip" >/dev/null 2>/dev/null
				fi
			else
				if [ "$2" == false ] || [ "$2" == "" ]; then
					compute "$clip" "$clip" >/dev/null 2>/dev/null &
				else
					compute "$clip" "$clip" >/dev/null 2>/dev/null
				fi
			fi
		fi
	fi
}

if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
	gtts_speak() {
		# think this should work for now until I have time to take a deeper look,
		# but it's important to be available in case people want to run this on
		# older machines. sox is nearly instant on my machine, but aletheia
		# ideally should run on older hardware as well; at least the final release.
		# I initially removed the support in lieu of the natural voice, but some
		# will find this useful.
		espeak_say "$1" "$2" "$3" &
	}
fi

vanish() {
	feedback_enabled=$VOICE_ENABLED
	inputnew=""
	display=""
	escape_pressed=false
	char_count=0
	line_count=1
	word_count=0
	saved_spot=""
	width=$(($COLUMNS-((${#char_count}+2+${#word_count}+${#line_count})*2)-(${#PADDING}*2)-20))
	tput cup $LINES
	tput el
	tput cup $LINES
	echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE --"
	LEFTBANNER_WIDTH="$((6+6))"
	tput cup $LINES $(($COLUMNS/2))
	echo -ne "${BLUE}_"
	tput sc
	visible=true
	char=""
	draw_indicator() {
		tput cup $LINES $(($COLUMNS-${#char_count}-2-${#word_count}-${#line_count}-${#PADDING}))
		echo -ne "$BLUE${char_count}$WHITE:$BLUE${word_count}$WHITE:$BLUE${line_count}$PADDING"
	}
	draw_indicator
	tput rc
	tmpflag=true
	quit=false
	while true; do
		tput cup $LINES
		echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE -- "
		LEFTBANNER_WIDTH="$((6+6))"
		draw_indicator
		if [ "$tmpflag" == false ]; then
			IFS=$'\n'
			char=""
			until [ "$char" != "" ]; do
				read -rsn1 -t 0.6 char
				if [ "$char" == "" ]; then
						tput cup $LINES $(($saved_spot+${#newdisplay}))
					if [ "$visible" == true ]; then
						echo -ne "${BLUE} "
						visible=false
					else
						echo -ne "${BLUE}_"
						visible=true
					fi
				fi
			done
			unset IFS
		else
			tmpflag=false
		fi
		preword=false
		if [[ $char == $'\e' ]]; then
			tput cup $LINES
			old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
			LEFTBANNER_WIDTH="$((3+6))"

			if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
				printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
			fi
			tput cup $LINES
			gtts_speak "command mode"
			echo -ne "${PADDING}$WHITE-- ${BLUE}VANISH$WHITE --"
			while true; do
				read -rsn1 newchar
				if [ "$newchar" == "q" ]; then
					if [ "$1" != true ]; then
						draw_pitch
						draw_position
					else
						echo
					fi
					quit=true
					break
				elif [ "$newchar" == "h" ]; then
					if [ "$width" -gt "$((($COLUMNS*5)/8))" ]; then
						continue
					fi
					width="$(($width+2))"
					newdisplay="`echo -ne \"$display\" | tail -c $width`"
					if [ "${char_count}" -le "$(($width))" ]; then
						tput cup $LINES $((($COLUMNS/2)-$((${char_count}/2))))
					else
						tput cup $LINES $((($COLUMNS/2)-($width/2)))
					fi

					echo -ne "$WHITE${newdisplay}${BLUE}_"
					#FIXME
					tput el
					draw_indicator
				elif [ "$newchar" == "l" ]; then
					width="$(($width-2))"
					if [ "$width" -lt "0" ]; then
						width=0
					fi
					newdisplay="`echo -ne \"$display\" | tail -c $width`"
					if [ "${char_count}" -le "$(($width))" ]; then
						tput cup $LINES $((($COLUMNS/2)-$((${char_count}/2))))
					else
						tput cup $LINES $((($COLUMNS/2)-($width/2)))
					fi
					tput cub1
					echo -ne " "
					echo -ne "$WHITE${newdisplay}${BLUE}_"
					tput el
					draw_indicator
				elif [ "$newchar" == "p" ]; then
					toggle_pause true
				elif [ "$newchar" == "w" ]; then
					gtts_speak "saved"
					inputnew=$(fold -w 80 -s <<< "$inputnew")
					echo -ne "\n\n`date`\n\n$inputnew\n" >>"$HOME/Documents/journal"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="$((5+6))"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
					fi
					tput cup $LINES
					echo -ne "$PADDING$WHITE-- ${BLUE}SAVED$WHITE --"
					sleep $BANNER_WAIT_TIME
				elif [ "$newchar" == "n" ]; then
					gtts_speak "new entry"
					inputnew=""
					display=""
					char_count=0
					tput cup $LINES
					tput el
					draw_indicator
					break
				elif [ "$newchar" == "d" ]; then
					if [ "$VOICE_ENABLED" == true ]; then
						gtts_speak "off"
						VOICE_ENABLED=false
						feedback_enabled=false
					else
						VOICE_ENABLED=true
						gtts_speak "on"
						feedback_enabled=true
					fi
				elif [ "$newchar" == "v" ]; then
					fold -w $COLUMNS -s <<< "$inputnew" | less
					gtts_speak "insert mode"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="$((6+6))"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $(($old_LEFTBANNER_WIDTH+1))
					fi
					tput cup $LINES
					echo -ne "${PADDING}$WHITE-- ${BLUE}INSERT$WHITE -- "
					tput el
					draw_indicator
					break
				elif [ "$newchar" == "i" ]; then
					draw_indicator
					gtts_speak "insert mode"
					break
				fi
			done
			if [ "$quit" == true ]; then
				break
			fi
		elif [ "$char" == $'' ]; then
			if [ "$char_count" -gt "0" ]; then
				newchar="`echo -ne \"$inputnew\" | rev | cut -c 1`"
				if [ "$newchar" == " " ]; then
					if [ "$inword" == true ]; then
						inword=false
						word_count=$(($word_count-1))
						draw_indicator
					fi
					preword=true
				elif [ "$newchar" != " " ]; then
					inword=true
				elif [ "$preword" == true ]; then
					inword=true
					preword=false
			fi
			inputnew="`echo -ne \"$inputnew\" | rev | cut -c2- | rev`"
			display="`echo -ne \"$display\" | rev | cut -c2- | rev`"
			char_count=$(($char_count-1))
			draw_indicator
			if [ "$word" != "" ]; then
				word="`echo -ne \"$word\" | rev | cut -c2- | rev`"
			fi
			if [ "${char_count}" -lt "$(($width))" ]; then
				saved_spot=$((($COLUMNS/2)-$((${char_count}/2))-1))
				tput cup $LINES $saved_spot
				echo -ne " "
			fi
			fi
		elif [ "$char" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			espeak-ng -v en-us+m1 " $inputnew" &
		elif [ "$char" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
		else
			char_count=$(($char_count+1))
			if [ "$char" == " " ]; then
				preword=false
				inputnew="${inputnew} "
				display="${display} "
				if [ "$feedback_enabled" == true ]; then
					espeak-ng -v en-us+m1 "$word" &
				fi
				if [ "$inspace" == false ]; then
					word_count=$(($word_count+1))
				fi
				inspace=true
				word=""
			else
				preword=false
				inputnew="${inputnew}${char}"
				display="${display}${char}"
				if [ "$inspace" == true ]; then
					inspace=false
					inword=true
				fi
				if [ "$char" == "." ] || [ "$char" == "?" ] || [ "$char" == "," ] || [ "$char" == "!" ]; then
					if [ "$feedback_enabled" == true ]; then
						espeak-ng -v en-us+m1 "$word" &
					fi
					word_count=$(($word_count+1))
					inword=false
					word=""
				else
					word="$word$char"
				fi
			fi
		fi
		newdisplay="`echo -ne \"$display\" | tail -c $width`"
		tput sc
		if [ "${char_count}" -le "$(($width))" ]; then
			saved_spot=$((($COLUMNS/2)-$((${char_count}/2))))
			tput cup $LINES $saved_spot
		else
			saved_spot=$((($COLUMNS/2)-($width/2)))
			tput cup $LINES $saved_spot
		fi
		echo -ne "$WHITE${newdisplay}${BLUE}_ \b"
		draw_indicator
		tput rc
	done
}

if [ "$1" == "--vanish" ]; then
	vanish true
	clear
	tput cnorm
	stty echo
	exit 0
fi

if [ "$LINES" -lt "7" ] || [ "$COLUMNS" -lt "33" ]; then
	if [ "$BYPASS_WARNING" != true ]; then
		echo -e "${RED}Error:${NOCOLOR} Terminal dimensions too small (Requires >= 33x7)"
		sleep 5
	fi
fi

REPEAT_HELP="Loop Controls
6  Switch Loops
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
S  Start -0.01
F  Start +0.01
s  Start -0.05
f  Start +0.05
H  End -0.01
L  End +0.01
h  End -0.05
l  End +0.05
,  Gap -1
.  Gap +1
e  Play Transition
^H  Seek to Start
5  Start Position
7  End Position"

VOICE_HELP="Voice Controls
d  Toggle Voice
T  Toggle Title Only
Voice Volume Settings
8  Volume Down
9  Volume Up
Voice Pitch Settings
J  Down
K  Up"

QUEUE_HELP="Queue Controls
j  Page Down
k  Page Up
h  Selection Down
l  Selection Up
D  Remove Song
<  Move Song Up
>  Move Song Down
s  Keyword Search
d  Speak Controls"

SCALE_HELP="Scale Controls
j  Scale Down
k  Scale Up
o  Double EDO
m  Halve EDO
c  Reverse Direction
y  $DEFAULT_EDO-EDO
v  Toggle Pitch"

HELP="Basic Controls
i  Menu
?  Key Controls
j  Page Down
k  Page Up
;  Queue
p  Pause
n  Next Song
b  Previous Song
m  Man Page
q  Quit
Voice Feedback
d  Toggle Voice
T  Only Voice Titles
#  Save Settings
I  Speak Status
,  Speak Title
Volume Controls
*  1% Down
(  1% Up
8  3% Down
9  3% Up
!  PCM 1% Down
@  PCM 1% Up
1  PCM 5% Down
2  PCM 5% Up
c  Mute
3  Fade Up/Down
Interval Controls
j  Pitch Down
k  Pitch Up
x  Lock/Unlock
m  Half EDO
o  Double EDO
.  Set INT
/  Set EDO
w  Reset to Locked
H  Least Precise
L  Fully Precise
J  EDO Down
K  EDO Up
y  $DEFAULT_EDO-EDO
4  Reset INT/EDO
^U  Toggle Locked
Pitch Jump Controls
_  Octave Down
+  Octave Up 
M  Inverse INT
Y  Zero INT
Pitch Fade Controls
X  Scale Speed
t  Zero INT
u  INT Up/Down
U  EDO Up/Down
-  Octave Down
=  Octave Up
g  Inverse INT
G  Oscillate
Balance Controls
{  1% Left Up
}  1% Right Up
[  1% Left Down
]  1% Right Down
0  Reset Fade
)  Reset
Track Controls
h  Seek Backward
l  Seek Forward
b  Queue Backward
n  Queue Forward
p  Pause
\\  Restart 
r  Rename
D  Delete
P  Progress Bar
a  Equalizer
Queue Controls
;  Queue
O  Edit
R  Shuffle
A  Sort
\"  Last of Artist
'  First of Artist
N  Next Artist
B  Previous Artist
Z  Export As
e  Loop Toggle
$  Only Locked
^R  Random Mode
Loop Toggle Controls
E  Loop Song
V  Loop Artist
Search Controls
S  New Search
s  Jump To
^F  Add Songs
Loop Editor Controls
5  Start Position
7  End Position
6  Enter Loop 
6  Switch Loops
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
^E  Play Only Loops
^H  Seek to Start
Video Controls
<  Enable Video
>  Fullscreen Video
^T  Always on Top
Download Controls
W  Add Downloads
^W  Jump Downloads
^N  Add and Jump
Advanced Controls
^P  Toggle Panels
^O  Invert Color
^Y  Color On/Off
^A  Select Color
z  Redraw Screen
~  Sleep mode
|  Vanish Editor"

HELP_LENGTH="`echo -e \"$HELP\"| wc -l`"
VOICE_HELP_LENGTH="`echo -e \"$VOICE_HELP\"| wc -l`"
SCALE_HELP_LENGTH="`echo -e \"$SCALE_HELP\"| wc -l`"
REPEAT_HELP_LENGTH="`echo -e \"$REPEAT_HELP\"| wc -l`"
QUEUE_HELP_LENGTH="`echo -e \"$QUEUE_HELP\"| wc -l`"

espeak_say() {
	if [ "$voice_enabled" == true ] || [ "$2" == true ]; then
		killall espeak-ng >/dev/null 2>/dev/null
		if [ "$3" == true ] && [ "$1" != " " ]; then
			espeak-ng -v en-us+m1 " $1"
		elif [ "$1" != " " ]; then
			espeak-ng -v en-us+m1 " $1" &
		fi
	fi
}

draw_banner() {
	if [ "$3" != true ]; then
		LEFT_BANNER_WIDTH="$((${#i}+2))"
	else
		RIGHT_BANNER_WIDTH="$((${#i}+2))"
	fi
	if [ "$2" == false ] || [ "$2" == "" ]; then
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length="$POSITION_WIDTH"
		warning=false
	else
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length=12
		warning=true
	fi
	
	if [ "$3" == false ] || [ "$3" == "" ]; then
		tput cup $LINES
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1$COLOR1 --$COLOR2 "
		tput sc
		if [ "$RIGHT_BANNER_WIDTH" != "0" ]; then
			if [ "$4" == true ]; then
				length="$RIGHT_BANNER_WIDTH"
			fi
		fi
		if [ "$((${#1} + 6 + $RIGHT_BANNER_WIDTH + (${#PADDING}*2)))" -lt "$COLUMNS" ]; then
			printf '%*s' $(($COLUMNS - ${#1} - 7 - (${#PADDING}*2) - $length))
		fi
	else
		tput cup $LINES $(($COLUMNS - ${#1} - 8))
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1$COLOR1 --$COLOR1 "
		RIGHT_BANNER_WIDTH=$((${#1}+6))
	fi

	if [ "$warning" == true ]; then
		echo -ne "$COLOR1${COLOR2}y${COLOR1}: ${WHITE_BLACK}yes $COLOR1${COLOR2}n${COLOR1}: ${WHITE_BLACK}no$PADDING"
	fi

	if [ "$4" != true ]; then
		if [ "$3" != true ]; then
			tput rc
		fi
	fi
}

set_loop() {
	if [ "$LOOP" == false ] || [ "$1" == true ]; then
		gtts_speak "loop song"
		LOOP=true
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
		draw_banner "LOOP SONG"
	else
		gtts_speak "loop off"
		LOOP=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_loop_artist() {
	if [ "$LOOP_ARTIST" == false ] || [ "$1" == true ]; then
		LOOP=false
		LOOP_ARTIST=true
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		LOOP_ARTIST_NAME="`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1 | tr '[:upper:]' '[:lower:]'`"
		LOOP_ARTIST_NAME2="`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		gtts_speak "loop artist"
		draw_banner "LOOP ARTIST"
	else
		gtts_speak "loop off"
		LOOP=false
		LOOP_ARTIST=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_random() {
	if [ "$TRACK_RANDOM" == false ] || [ "$1" == true ]; then
		gtts_speak "random mode"
		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=true
		ONLY_LOCKED=false
		draw_banner "RANDOM MODE"
		reset_buffer
		redraw_buffer
	else
		gtts_speak "random mode off"
		TRACK_RANDOM=false
		draw_banner "RANDOM OFF"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_only_locked() {
	if [ "$ONLY_LOCKED" == false ] || [ "$1" == true ]; then
		if [ "$3" != true ]; then
			gtts_speak "only locked"
		fi

		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		if [ "$5" != true ]; then
			ONLY_LOCKED=true
		fi
		if [ "$4" != true ]; then
			if [ "$PICK" == "" ]; then
				old_queue_array=("${queue_array[@]}")
				unset queue_array
				IFS=$'\n'
				index=0
				for i in `find "$MUSICDIR" -iname "*.locked" | shuf`; do
					if [ "$(echo -ne "$i" | grep '.repeat.')" == "" ]; then
						queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
						index=$(($index+1))
					fi
				done
				unset IFS
				if [ "$index" == "0" ]; then
					#if [ "$5" == true ]; then
						queue_array=("${old_queue_array[@]}")
						unset old_queue_array
						return 50 
					#fi
				else
					TOTAL_QUEUE=$index
				fi
					
			else
				unset queue_array
				c=$'\n'
				IFS=$'\n'
				index=0
				for i in `printf '%s\n' "${queue_array[@]}"`; do
					if [ -e "$i.locked" ]; then
						new_queue_array[$index]="$i"
						index=$(($index+1))
					fi
				done
				unset IFS
				queue_array=("${new_queue_array[@]}")
				TOTAL_QUEUE=$(($index-1))
			fi
			if [ -e "$FILENAME.locked" ]; then
				new_list=""
				minusone=0
				IFS=$'\n'
				o_list="$FILENAME$IFS"
				for i in `seq 1 $TOTAL_QUEUE`; do
					if [ "$i" != "$POSITION" ]; then
						new_list="$new_list${queue_array[$(($i-1-$minusone))]}$IFS"
					else
						minusone=1
					fi
				done
				new_list="`echo -ne \"$new_list\" | grep -v \"$FILENAME\" | shuf`"
				o_list="$o_list$new_list"
				index=0
				for i in `echo -ne "$o_list"`; do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				unset IFS
				POSITION=1
				ret=false
				flagp=true
			else
				JUMP=1
				ret=true
				flagp=false
			fi

			if [ "$flagp" == false ]; then
				POSITION=0
				tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1 | head -1`"
				if [ "$tmp" != "" ]; then
					POSITION="$tmp"
				fi
			fi
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			if [ "$5" != true ]; then
				draw_banner "ONLY LOCKED"
			fi
			reset_buffer
			redraw_buffer
			if [ "$ret" == true ]; then
				return 200
			fi
		else
			return 200
		fi
	elif [ "$2" == true ]; then
		if [ "$selected_locks" == true ]; then
			break
		fi
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	elif [ "$3" == true ]; then
		if [ "$selected_locks" == true ]; then
			break
		fi
		ONLY_LOCKED=false
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	else
		if [ "$selected_locks" == true ]; then
			break
		fi
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="`printf '%s\n' \"${queue_array[@]}\" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

track_toggle() {
	if [ "$LOOP" == false ] && [ "$LOOP_ARTIST" == false ]; then
		set_loop true
	elif [ "$LOOP_ARTIST" == false ]; then
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		set_loop_artist true
	else
		gtts_speak "reset"
		LOOP=false
		LOOP_ARTIST=false
		draw_banner "RESET"
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
	fi
}

about() {
	tput cup 0
	echo -ne "$BLUE_BLACK"
	printf '%*s' $COLUMNS
	echo -ne "$NOCOLOR"
	draw_banner "LOADING"
	tput cup $LINES $(($COLUMNS-${#PADDING}))
	echo -ne "$BLUE_BLACK${PADDING}"
	empty_pane
	lines_divided=$(($LINES/2))
	cols_divided=$(($COLUMNS/2))

	if [ "$(($COLUMNS%2))" == "0" ]; then
		even=true
		pad="_"
	else
		even=false
		pad=""
	fi
	if [ "$even" == true ]; then
		tput cup $(($lines_divided-2)) $(( ($COLUMNS/2) - 4))
	else
		tput cup $(($lines_divided-2)) $(( ($COLUMNS/2) - 3))
	fi
	echo -ne "${WHITE}ἀ${BLUE}λ${WHITE}ήθεια${BLUE}_"
	tput sc

	tput cup $lines_divided $(( ($COLUMNS/2) - 7))
	if [ "$even" == true ]; then
		echo -ne "${WHITE}GPL${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2023"
		tput cup $(($lines_divided+2)) $(( $cols_divided - 3))
	else
		echo -ne "${WHITE}GPL ${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2023"
		tput cup $(($lines_divided+2)) $(( $cols_divided - 2))
	fi
	if [ "$even" == true ]; then
		echo -ne "${BLUE}v"
	fi
	echo -ne "$(echo -ne "$WHITE$VERSION" | sed "s/\./$(echo -ne "$BLUE").$(echo -ne "$WHITE")/g")"
	tput cup $(($lines_divided-2)) $(( $cols_divided - 4))
}

set_scale_speed() {
	local reset=false
	tmp=""
	if [ "$SCALE_SPEED" != "$DEFAULT_SCALE_SPEED" ]; then
		reset=true
		draw_banner "RESET"
		stty -echo
		sleep $BANNER_WAIT_TIME
		stty echo
		draw_pitch
		draw_position		
		tmp="$DEFAULT_SCALE_SPEED"
	else
		gtts_speak "set scale speed"
		draw_banner "SPEED"
	fi

	if [ "$tmp" == "" ]; then
		tmp="`read_line`"
	fi

	if [ "`isnum \"$tmp\"`" != "0" ]; then
		SCALE_SPEED=$tmp
		gtts_speak "scale speed set"
	else
		draw_pitch
		gtts_speak "closed" true
		return
	fi

	if [ "$reset" == true ]; then
		gtts_speak "speed reset"
	fi
	draw_pitch
}

less_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$EDO" -gt "$LOCKED_EDO" ]; do
		INTERVAL="$(($INTERVAL/2))"
		EDO="$(($EDO/2))"
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		sleep 0.01
	done
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	gtts_speak "less precise"
}

more_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		MUTE=false
		echo "mute" >"$ALETHEIA/pipe$$" &
	fi
	while [ "$EDO" -lt "$EDO_LIMIT" ]; do
		if [ "$INTERVAL" -lt "$EDO_LIMIT" ]; then
			INTERVAL="$(($INTERVAL*2))"
			EDO="$(($EDO*2))"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			sleep 0.01
		else
			break
		fi
	done
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	gtts_speak "precise"
}

zero_interval_jump() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$INTERVAL" != "0" ]; then
		SAVED_INTERVAL="$INTERVAL"
		SAVED_EDO="$EDO"
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$SAVED_EDO"
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			INTERVAL="$SAVED_INTERVAL"
			EDO="$SAVED_EDO"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		else
			return
		fi
	fi
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	draw_pitch
}

draw_loop() {
	tput cup $LINES $(($COLUMNS-$RIGHT_BANNER_WIDTH-${#PADDING}))
	echo -ne "$BLUE_BLACK$START_MARKER$WHITE_BLACK:$BLUE_BLACK$END_MARKER$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
}

repeat() {
	echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
	echo "get_time_length" >"$ALETHEIA/pipe$$" &
	sleep $MPLAYER_WAIT_TIME
	TOTAL_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
	if [ "`isnum \"$TOTAL_TIME\"`" == "0" ] || [ "`echo -e \"$TOTAL_TIME < 0.1\" | bc`" == "1" ]; then
		TOTAL_TIME=0.1
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	if [ "$REPEAT_ONLY" == false ]; then
		gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
	fi
	if [ "$END_TIME" == "" ]; then
		if [ "$REPEATS" != "" ]; then
			repeats=$REPEATS
			START_MARKER="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f1`"
			if [ "`isnum \"$START_MARKER\"`" == "0" ] || [ "`echo -e \"$START_MARKER < 0\" | bc`" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_START_MARKER=$START_MARKER
			if [ "$START_MARKER" == "" ]; then
				START_MARKER=0.0
			fi
			END_TIME="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f2`"
			if [ "`isnum \"$END_TIME\"`" == "0" ] || [ "`echo -e \"$END_TIME < 0\" | bc`" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_END_TIME=$END_TIME
			if [ "$END_TIME" == "" ]; then
				END_TIME=5.0
			fi
			space="`echo -ne \"$repeats\" | head -1 | cut -d '/' -f3 | cut -d'.' -f1`"
			if [ "`isnum \"$space\"`" != "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_space=$space
			if [ "$space" == "" ]; then
				space=0
			fi
		else
			draw_banner "NO LOOPS"
			gtts_speak "no loops"
			sleep $BANNER_WAIT_TIME
			draw_pitch
			draw_position
			if [ "$LOOP" == false ]; then
				echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			fi
			return 200
		fi
	fi
	if [ "$END_TIME" != "" ]; then
		END_MARKER=$END_TIME
		date_time=`/usr/bin/time -p date +%s.%N 2>&1 | head -1`
		date_time=$(calc "$date_time/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		timespent_timed=`/usr/bin/time -p calc "10 + (1687968170.908741168-1687968192.276557242) * (0.35) + ($date_time * 0.35)" 2>&1 | head -1`
		timespent_timed=$(calc "$timespent_timed/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		s="`calc \"1/(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		orig_old_s=$old_s
		time="`calc \"($END_TIME-$START_MARKER)*($s)\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
		input_char=""
		START_MARKER="`printf '%.2f' $START_MARKER`"
		END_MARKER="`printf '%.2f' $END_MARKER`"
		RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
		if [ "$REPEAT_TOTAL" == "0" ]; then
			draw_banner "LOOP 0/$REPEAT_TOTAL"
		else
			draw_banner "LOOP 1/$REPEAT_TOTAL" false false true
		fi
		draw_loop
		scale=false
		until [ "$input_char" == "q" ] || [ "$input_char" == "" ]; do
			if [ "$input_char" == "" ]; then
				timespent=0
				x=0
				if [ "$input_char" == "" ]; then
					if [ "$space" -gt "0" ]; then
						echo -e "pause" >"$ALETHEIA/pipe$$" &
						read -rsn1 -t `calc "$space/20" | sed -e "s/\t//g" | cut -d'~' -f2` input_char
						echo -e "pause" >"$ALETHEIA/pipe$$" &
					fi
				fi
				if [ "$input_char" != "" ]; then
					continue
				fi
				new_flaggy=false
				echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
				time_before=`date +%s.%N`
				if [ "$scale" == true ]; then
					num="`echo -ne \"$time\" | cut -d'.' -f1`"
					skip=false
					while [ "$num" -gt "0" ]; do
						old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
						if [ "$skip" == false ]; then
							if [ "$scale_down" == true ]; then
								INTERVAL=$(($INTERVAL-1))
							elif [ "$scale_down" == false ]; then
								INTERVAL=$(($INTERVAL+1))
							fi
						fi
						old_time_before=$time_before
						time_before=`date +%s.%N`
						if [ "$skip" == false ]; then
							echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						else
							skip=false
						fi
						time_after=`date +%s.%N`
						draw_pitch
						orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
						time_x=`date +%s.%N`
						if [ "$new_flaggy" == true ]; then
							new_text="($timespent_timed)"
						else
							new_text="0"
						fi
						timespent="`calc \"$timespent +($time_before-$old_time_before)*($old_s)+($time_x-$time_after)*($orig_old_s)+($date_time*2)*$old_s+($date_time*2)*$orig_old_s+$timespent_timed\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
						s=$orig_old_s
						old_s=$s
						s="`calc \"1/$s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"

						time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						numberz=`calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						if [ "`echo \"$numberz <= 0\" | bc`" == "1" ]; then
							numberz=0
						fi
						if [ "`echo -e \"$numberz >= 0\" | bc`" == "1" ]; then
							if [ "$numberz" == "0" ]; then
								input_char=""
								skip=true
							else
								if [ "`echo \"($numberz/$num) < 1\" | bc`" == "1" ]; then
									skip=true
								fi
								time_y=`date +%s.%N`
								timespent="`calc \"$timespent + (($time_y-$time_x) * ($old_s)) + ($date_time * $old_s)\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
								new_flaggy=true
								if [ "$WEB_CLIENT" == "0" ]; then
									read -rsn1 -t "`echo \"$numberz/$num\" | bc`" input_char_
								else
									read -rsn1 -t "`echo \"$numberz/$num\" | bc`" input_char <"$ALETHEIA/web_client_pipe$$"
								fi
								time_after=`date +%s.%N`
							fi
						fi
						if [ "$input_char" != "" ]; then
							if [ "$input_char" == "q" ] || [ "$input_char" == "u" ] || [ "$input_char" == "" ]; then
								scale=false
								gtts_speak "scale closed"
								draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
								break
							elif [ "$input_char" == "c" ]; then
								if [ "$scale_down" == true ]; then
									scale_down=false
								else
									scale_down=true
								fi
								skip=true
							elif [ "$input_char" == "m" ]; then
								half_precise
								skip=true
							elif [ "$input_char" == "t" ]; then
								set_default_edo
								skip=true
							elif [ "$input_char" == "o" ]; then
								double_precise
								skip=true
							elif [ "$input_char" == "8" ]; then
								system_volume_change "-3% -3%"
								skip=true
							elif [ "$input_char" == "9" ]; then
								system_volume_change "+3% +3%"
								skip=true
							elif [ "$input_char" == "*" ]; then
								system_volume_change "-1% -1%"
								skip=true
							elif [ "$input_char" == "(" ]; then
								system_volume_change "+1% +1%"
								skip=true
							fi
						fi
						num=$(($num-1))
					done
				else
					if [ "`echo \"$time <= 0\" | bc`" == "1" ]; then
						time=0.01
						END_MARKER="`echo \"$START_MARKER+0.01\" | bc`"
					fi
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t $time input_char
					else
						read -rsn1 -t $time input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				time_after=`date +%s.%N`
			fi
			if [ "$input_char" == "" ]; then
				continue
			fi
			if [ "$input_char" == "l" ] || [ "$input_char" == "h" ] || [ "$input_char" == "L" ] || [ "$input_char" == "H" ]; then
				case $input_char in
				'l')
					if [ "`echo -e \"($END_MARKER+0.05)<$TOTAL_TIME\" | bc`" == "1" ]; then
						END_MARKER=`calc "$END_MARKER+0.05" | sed -e "s/\t//g"`
					else
						END_MARKER=$TOTAL_TIME
					fi
					;;
				'h')
					if [ "`echo -e \"(($END_MARKER-0.05) > $START_MARKER)\" | bc`" == "1" ]; then
						END_MARKER=`calc "$END_MARKER-0.05" | sed -e "s/\t//g"`
					fi
					;;
				'L')
					if [ "`echo -e \"($END_MARKER < $TOTAL_TIME-0.05)\" | bc`" == "1" ]; then
						END_MARKER=`calc "$END_MARKER+0.01" | sed -e "s/\t//g"`
					fi
					;;
				'H')
					if [ "`echo -e \"($END_MARKER > $START_MARKER+0.05)\" | bc`" == "1" ]; then
						END_MARKER=`calc "$END_MARKER-0.01" | sed -e "s/\t//g"`
					fi
					;;
				esac

				time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`

				START_MARKER="`printf '%.2f' $START_MARKER`"
				END_MARKER="`printf '%.2f' $END_MARKER`"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop

				if [ "`echo -e \"$(calc \"$END_MARKER-$START_MARKER\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t $time input_char
					else
						read -rsn1 -t $time input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek `calc \"$END_MARKER-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char
					else
						read -rsn1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "s" ] || [ "$input_char" == "f" ] || [ "$input_char" == "S" ] || [ "$input_char" == "F" ]; then
				case $input_char in
				's')
					if [ "`echo -e \"(($START_MARKER-0.05) >= 0.0)\" | bc`" == "1" ]; then
						START_MARKER=`calc "$START_MARKER-0.05" | sed -e "s/\t//g"`
					fi
					;;
				'f')
					if [ "`echo -e \"(($START_MARKER+0.05) < $END_MARKER)\" | bc`" == "1" ]; then
						START_MARKER=`calc "$START_MARKER+0.05" | sed -e "s/\t//g"`
					fi
					;;
				'S')
					if [ "`echo -e \"(($START_MARKER-0.01) >= 0.0)\" | bc`" == "1" ]; then
						START_MARKER=`calc "$START_MARKER-0.01" | sed -e "s/\t//g"`
					fi
					;;
				'F')
					if [ "`echo -e \"(($START_MARKER+0.01) <= ($END_MARKER-0.05))\" | bc`" == "1" ]; then
						START_MARKER=`calc "$START_MARKER+0.01" | sed -e "s/\t//g"`
					fi
					;;
				esac
				truth="`echo \"$START_MARKER < 0.0\" | bc`"
				if [ "$truth" == "1" ]; then
					START_MARKER="0.0"
				fi
				time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				START_MARKER="`printf '%.2f' $START_MARKER`"
				END_MARKER="`printf '%.2f' $END_MARKER`"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "d" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				toggle_voice
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "" ] || [ "$input_char" == "\\" ]; then
				input_char=""
				flagged=false
			elif [ "$input_char" == "u" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				gtts_speak "scale"
				draw_banner "SCALE"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$scale" == true ]; then
					scale=false
					if [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					fi
				else
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 inputchar
					else
						read -rsn1 inputchar <"$ALETHEIA/web_client_pipe$$"
					fi
					if [ "$inputchar" == "j" ]; then
						scale_down=true
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "k" ]; then
						scale_down=false
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ] || [ "$inputchar" == "" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					fi
				fi
			elif [ "$input_char" == "q" ]; then
				draw_pitch
				draw_position
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "a" ]; then
				toggle_pause
				set_equalizer
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "T" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				set_only_display_song
				redraw_buffer
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				load_loop_file
				if [ "$?" != "1" ]; then
					draw_pitch
					draw_position
					REPEAT_ONLY=false
					return 200
				fi
				flagged=true
			elif [ "$input_char" == "Z" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "WAIT" false false true
				gtts_speak "wait"
				ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
				filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
				rm -f "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
				rm -f "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
				ffmpeg -i "$FILENAME" -ss $START_MARKER -t $(calc "$END_MARKER-$START_MARKER+0.265") -c copy "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
				len="`ffprobe -i \"$filename_without_ext.repeat0.$ext\" -show_entries format=duration -v quiet -of csv='p=0'`"
				sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat1.$ext" trim 0 -0.180 >/dev/null 2>/dev/null
				delay="$(echo "($space/20)" | bc)"
				ffmpeg -i "$filename_without_ext.repeat1.$ext" -af "apad=pad_dur=$delay" "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
				rm -f "$filename_without_ext.repeat0.$ext"
				rm -f "$filename_without_ext.repeat1.$ext"
				cp "$FILENAME.locked" "$filename_without_ext.repeat.$ext.locked" >/dev/null 2>/dev/null
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				gtts_speak "finished"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "$BLUE_BLACK${REP}$"
					fi
				else
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "${WHITE_BLACK} "
					fi
				fi
				flagged=true
			elif [ "$input_char" == "A" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				sort_queue
				SHUFFLED=false
				flagged=true
			elif [ "$input_char" == "R" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				shuffle_queue
				SHUFFLED=true
				flagged=true
			elif [ "$input_char" == "I" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				say_status
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "Y" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				zero_interval_jump
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				input_char=""
				flagged=false
			elif [ "$input_char" == "w" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				reset_to_locked
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "q" ] || [ "$input_char" == "" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				draw_pitch
				draw_position
				REPEAT_ONLY=false
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				return 200
			elif [ "$input_char" == "W" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				add_downloaded "noposition"
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					gtts_speak "playing downloaded"
					JUMP="$DOWNLOAD_POSITION"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
				fi
				flagged=true
			elif [ "$input_char" == "?" ]; then
				toggle_pause true
				RIGHT_BANNER_WIDTH="$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))"
				draw_banner "HELP" false false true
				tput cup $LINES $(($COLUMNS-12))
				echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
				loop_help_screen
				killall espeak-ng >/dev/null 2>/dev/null
				toggle_pause true
				old_time_before=$time_before
				time_before=`date +%s.%N`
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				redraw_buffer
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "i" ]; then
				toggle_pause true
				orig_POSITION_WIDTH=$POSITION_WIDTH
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				main_menu
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				toggle_pause true
				old_time_before=$time_before
				time_before=`date +%s.%N`
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "M" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				orig_orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				INTERVAL="$((-($INTERVAL)))"
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				draw_pitch
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				switch=true
				flagged=true
			elif [ "$input_char" == "v" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				toggle_scale_tempo
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "z" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_wait
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				reset_dimensions
				draw_volume
				draw_equalizer
				reset_buffer
				redraw_buffer
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "," ]; then
				if [ "$space" -gt "0" ]; then
					space=$(($space-1))
				fi
				gtts_speak "$space"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "`echo -e \"$(calc \"$END_MARKER-$START_MARKER\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time input_char
					else
						read -n1 -t $time input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek `calc \"$END_MARKER-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "." ]; then
				space=$(($space+1))
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				gtts_speak "$space"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "`echo -e \"$(calc \"$END_MARKER-$START_MARKER\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time input_char
					else
						read -n1 -t $time input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek `calc \"$END_MARKER-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "k" ] || [ "$input_char" == "j" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				orig_orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				if [ "$input_char" == "k" ]; then
					pitch_up true
				else
					pitch_down true
				fi
				orig_old_s="`calc \"(2^($INTERVAL/$EDO))\" | sed -e \"s/\t//g\"`"
				switch=true
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "2" ] || [ "$input_char" == "1" ] || [ "$input_char" == "!" ] || [ "$input_char" == "@" ] || [ "$input_char" == "9" ] || [ "$input_char" == "8" ] || [ "$input_char" == "*" ] || [ "$input_char" == "(" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$input_char" == "2" ]; then
					if [ "$VOLUME" -le "95" ]; then
						VOLUME=$(($VOLUME+5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "1" ]; then
					if [ "$VOLUME" -ge "5" ]; then
						VOLUME=$(($VOLUME-5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "@" ]; then
					if [ "$VOLUME" -le "99" ]; then
						VOLUME=$(($VOLUME+1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "!" ]; then
					if [ "$VOLUME" -ge "1" ]; then
						VOLUME=$(($VOLUME-1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "8" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change "-3% -3%"
				elif [ "$input_char" == "9" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change "+3% +3%"
				elif [ "$input_char" == "*" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change "-1% -1%"
				elif [ "$input_char" == "(" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change "+1% +1%"
				fi
				flagged=true
			elif [ "$input_char" == "6" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEAT_TOTAL" == "1" ]; then
					flagged=true
					gtts_speak "no more loops"
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$(($REPEAT_CURRENT+1))
						if [ "$REPEAT_CURRENT" -gt "$REPEAT_TOTAL" ]; then
							REPEAT_CURRENT=1
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f1`"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f2`"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="`printf '%.2f' $START_MARKER`"
						END_MARKER="`printf '%.2f' $END_MARKER`"
						
						time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						space="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f3`"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					else
						gtts_speak "none"
						START_MARKER=0.00
						END_MARKER=5.00
						END_TIME=$END_MARKER
						space=0
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "LOOP 0/$REPEAT_TOTAL"
					else
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "e" ]; then
				if [ "`echo -e \"$(calc \"$END_MARKER-$START_MARKER\") < 1.5\" | bc`" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $time input_char
					else
						read -n1 -t $time input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek `calc \"$END_MARKER-1.5\"` 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char
					else
						read -n1 -t `calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2` input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "" ]; then
				load_loop_file
				break
			elif [ "$input_char" == "q" ]; then
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "5" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "7" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_MARKER="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "n" ]; then
				RIGHT_BANNER_WIDTH=0
				ps -p $MPLAYER_PID >/dev/null
				if [ "$?" != "1" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
							JUMP="1"
							POSITION="1"
							draw_position
							return $RETURN_JUMP
						else
							return 0
						fi
					fi
				fi
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEAT_ONLY" == false ]; then
					REPEAT_ONLY=true
					draw_loop
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				else
					REPEAT_ONLY=false
					if [ "$ONLY_LOCKED" == true ]; then
						unset queue_array
						IFS=$'\n'
						index=0
						for i in `find "$MUSICDIR" -iname "*.mp3.locked" -o -iname "*.flac.locked" | shuf`; do
							queue_array[$index]="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
							index=$(($index+1))
						done
						unset IFS
						gtts_speak "only locked"
					else
						unset queue_array
						IFS=$'\n'
						index=0
						for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						gtts_speak "all"
					fi
					SHUFFLED=true
					TOTAL_QUEUE=$index
					tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
					if [ "$tmp" != "" ]; then
						POSITION="$tmp"
					else
						POSITION=1
					fi
					reset_buffer
					redraw_screen
					RIGHT_BANNER_WIDTH=$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))
					POSITION_WIDTH=$RIGHT_BANNER_WIDTH
					draw_pitch
					draw_position
					if [ "$LOOP" == false ]; then
						echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
					fi
					break
				fi
				flagged=true
			elif [ "$input_char" == "b" ]; then
				RIGHT_BANNER_WIDTH=0
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$REPEAT_ONLY" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM_BACK
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST_BACK
					elif [ "$ONLY_LOCKED" == true ]; then
						return $RETURN_ONLY_LOCKED_BACK
					else
						return $RETURN_BACK
					fi
				fi
			elif [ "$input_char" == "y" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				set_default_edo
				time_x=`date +%s.%N`
				LOCKED=false
				flagged=true
			elif [ "$input_char" == "p" ]; then
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				toggle_pause
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 input_char
				else
					read -n1 input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				old_time_before=$time_before
				time_before=`date +%s.%N`
				toggle_pause
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				time_x=`date +%s.%N`
				flagged=true
			elif [ "$input_char" == "o" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				flagged=true
			elif [ "$input_char" == "m" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				flagged=true
			elif [ "$input_char" == "x" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					gtts_speak "unlocked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "$BLUE_BLACK "
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/1" >"$FILENAME".locked
					else
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/0" >"$FILENAME".locked
					fi
					LOCKED=true
					gtts_speak "locked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "${WHITE_BLACK}${REP}$"
					fi
				fi
				flagged=true
			elif [ "$input_char" == "%" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEAT_TOTAL" -ge "1" ]; then
					gtts_speak "unlocked $REPEAT_CURRENT"
					draw_banner "UNLOCKED $REPEAT_CURRENT"
					draw_loop
					if [ "$WEB_CLIENT" == "0" ]; then
						read -n1 -t $BANNER_WAIT_TIME t
					else
						read -n1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
					fi
					input_char="$t"
					if [ "$REPEAT_TOTAL" == "1" ]; then
						rm -f "$FILENAME.repeats"
						REPEATS=""
						REPEAT_CURRENT=0
						REPEAT_TOTAL=0
					else
						sed -i "${REPEAT_CURRENT}d" "$FILENAME.repeats"
						REPEATS="`echo -ne \"$REPEATS\" | sed \"${REPEAT_CURRENT}d\"`"
						REPEAT_TOTAL=$(($REPEAT_TOTAL-1))
						REPEAT_CURRENT=$(($REPEAT_CURRENT-1))
					fi

					if [ "$REPEAT_TOTAL" == "0" ]; then
						tput cup $(($LOCKING_POS+2)) $((1))
						if [ -e "$FILENAME.locked" ]; then
							echo -ne "${WHITE}$"
						else
							echo -ne "${BLUE} "
						fi
					fi
					if [ "$REPEATS" != "" ]; then
						if [ "$REPEAT_CURRENT" == "0" ]; then
							REPEAT_CURRENT=1
						fi
						START_MARKER="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f1`"
						END_MARKER="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f2`"
						END_TIME=$END_MARKER
						time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
						space="`echo -ne \"$REPEATS\" | sed -n \"${REPEAT_CURRENT}p\" | cut -d '/' -f3`"
					fi
				else
					gtts_speak "no repeats"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEATS" != "" ]; then
					REPEATS="`echo -ne \"$REPEATS\" | sed -e \"s/$orig_START_MARKER\/$orig_END_TIME\/$orig_space/$START_MARKER\/$END_MARKER\/$space/g\"`"
					echo -ne "$REPEATS" >"$FILENAME.repeats"
					gtts_speak "saved loop"
				else
					gtts_speak "no loops"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "SAVED" false false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 -t $BANNER_WAIT_TIME input_char
				else
					read -n1 -t $BANNER_WAIT_TIME input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "&" ]; then
				old_time_before=$time_before
				time_before=`date +%s.%N`
				if [ "$REPEATS" != "" ]; then
					echo "$START_MARKER/$END_MARKER/$space" >>"$FILENAME.repeats"
					REPEATS="$REPEATS\n$START_MARKER/$END_MARKER/$space"
					REPEAT_CURRENT=$(($REPEAT_CURRENT+1))
					REPEAT_TOTAL=$(($REPEAT_TOTAL+1))
					gtts_speak "locked $REPEAT_TOTAL"
					tput cup $(($LOCKING_POS+2)) $((1))
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
				else
					REPEATS="$START_MARKER/$END_MARKER/$space`echo -ne \"\n\"`"
					echo "$START_MARKER/$END_MARKER/$space" >"$FILENAME.repeats"
					gtts_speak "locked"
					tput cup $(($LOCKING_POS+2)) $((1))
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
					REPEAT_CURRENT=1
					REPEAT_TOTAL=$(($REPEAT_TOTAL+1))
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOCKED $REPEAT_TOTAL"
				draw_loop
				if [ "$WEB_CLIENT" == "0" ]; then
					read -n1 -t $BANNER_WAIT_TIME t
				else
					read -n1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				input_char="$t"
				flagged=true
			else
				old_time_before=$time_before
				time_before=`date +%s.%N`
				process_key "$input_char"
				flagged=true
			fi
			if [ "$flagged" == true ]; then
				time_x=`date +%s.%N`
				flagged=false
				if [ "$switch" == true ]; then
					switch=false
					timespent="`calc \"$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*3)*$orig_old_s+($date_time*1)*$orig_orig_old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				else
					timespent="`calc \"$timespent +($time_after-$old_time_before)*($orig_old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*4)*$orig_old_s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
				fi
				s=$orig_old_s
				old_s=$s
				s="`calc \"1/$s\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"

				time=`calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				input_char=""
				numberz=`calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2`
				if [ "`echo \"$numberz <= 0\" | bc`" == "1" ]; then
					numberz=0
				fi
				if [ "`echo -e \"$numberz >= 0\" | bc`" == "1" ]; then
					if [ "$numberz" == "0" ]; then
						input_char=""
					else
						time_y=`date +%s.%N`
						time_before=$time_y
						timespent="`calc \"$timespent +(($time_y-$time_x)*($old_s))\" | sed -e \"s/\t//g\" | cut -d'~' -f2`"
						if [ "$WEB_CLIENT" == "0" ]; then
							read -n1 -t "$numberz" input_char
						else
							read -n1 -t "$numberz" input_char <"$ALETHEIA/web_client_pipe$$"
						fi
						time_after=`date +%s.%N`
					fi
				fi
			fi

		done
		scale=false
		REPEAT_ONLY=false
		if [ ! -e "$FILENAME.locked" ]; then
			gtts_speak "loop closed"
		fi

		END_TIME="$END_MARKER"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		if [ "$LOOP" == false ]; then
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		fi
		return 200
	fi
}

zero_interval() {
	reverse=false
	zero=false
	if [ "$INTERVAL" != "0" ]; then
		draw_banner "ZERO" false true
		zero=true
		SAVED_INTERVAL=$INTERVAL
		SAVED_EDO=$EDO
		gtts_speak "scaling to original pitch"
		old_int="$INTERVAL"
		old_edo="$EDO"
		new_INTERVAL="$DEFAULT_INTERVAL"
		new_EDO="$EDO"
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			draw_banner "RESET" false true
			gtts_speak "scaling back"
			old_int="0"
			old_edo="$EDO"
			new_INTERVAL="$SAVED_INTERVAL"
			new_EDO="$SAVED_EDO"
			reverse=true
		else
			old_int="0"
			new_INTERVAL="$DEFAULT_INTERVAL"
			new_EDO="$EDO"
		fi
	fi
	
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi

	if [ "$old_int" -gt "$new_INTERVAL" ]; then
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -lt "$old_int" ]; do
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
			elif [ "$c" == "q" ]; then				
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "quit"
				fi
				read -n1 input_char
				if [ "$input_char" == "y" ]; then
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					clear
					stty echo
					return $RETURN_QUIT
				elif [ "$input_char" == "q" ]; then
					flaggy=true
					draw_pitch
					break
				fi
			elif [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$(($old_int-1))"
				INTERVAL="$(($INTERVAL-1))"
				echo -e "speed_set `calc \"2^($old_int/$old_edo)\"`" >"$ALETHEIA/pipe$$" &
			fi
			draw_pitch 1
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	else
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -gt "$old_int" ]; do
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$(($old_int+1))"
				INTERVAL="$(($INTERVAL+1))"
				echo -e "speed_set `calc \"2^($old_int/$old_edo)\"`" >"$ALETHEIA/pipe$$" &
				draw_pitch 1
			fi
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	fi
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	LOCKED=false
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

scale_edo() {
	gtts_speak "scale e d o"
	draw_banner "SCALE"
	stopat=""
	read -rsn1 edo_change
	if [ "$edo_change" = "J" ]; then
		if [ "$EDO" -le "2" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=true
		time=2.5
		edo_change="$(($EDO-1))"
	elif [ "$edo_change" = "K" ]; then
		if [ "$EDO" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=false
		time=2.5
		edo_change="$(($EDO+1))"
	elif [ "$edo_change" == "j" ]; then
		gtts_speak "scaling"
		downwards=true
		time=$SCALE_SPEED
		edo_change="$(($EDO-1))"
	elif [ "$edo_change" == "k" ]; then
		gtts_speak "scaling"
		downwards=false
		time=$SCALE_SPEED
		edo_change="$(($EDO+1))"
	elif [ "$edo_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "" ] || [ "$edo_change" == "q" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "?" ]; then
		scale_help_screen
		draw_pitch
		draw_position
		return
	elif [ "`isnum \"$edo_change\"`" != "0" ] || [ "$edo_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="`read_line \"$edo_change\"`"
		if [ "$tmp" -lt "$EDO" ]; then
			if [ "$tmp" -le "0" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=true
			time=$SCALE_SPEED
			edo_change="$(($EDO-1))"
		elif [ "$tmp" -gt "$EDO" ]; then
			if [ "$tmp" -ge "2000000" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=false
			time=$SCALE_SPEED
			edo_change="$(($EDO+1))"
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$edo_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		original_edo="$EDO"
		c=""
		flaggy=false
		orig_edo=$EDO
		orig_interval=$INTERVAL
		while [ "$edo_change" != "$original_edo" ]; do
			if [ "$downwards" == true ]; then # && [ "$edo_change" -lt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t $time c
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ]; then
					break
				elif [ "$c" == "c" ]; then
					downwards=false
					sleep $SCALE_SPEED
					gtts_speak "order reversed"
					edo_change="$(((2000000)))"
					flaggy=false
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					original_edo="$EDO"
					old_EDO=$EDO
					EDO="$(($EDO-1))"
					edo_change="$(($edo_change-1))"
					INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
					if [ "$flaggy" == false ]; then
						temp="`calc \"$orig_edo/$EDO\" | cut -d'~' -f2`"
						INTERVAL="`echo \"$orig_interval/$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
					fi
					if [ "$EDO" == "1" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "1" ]; then
					break
				fi

			elif [ "$downwards" == false ]; then # && [ "$edo_change" -gt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t $time c
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ]; then
					break
				elif [ "$c" == "c" ]; then
					sleep $SCALE_SPEED
					gtts_speak "order reversed"
					original_edo="$EDO"
					flaggy=false
					downwards=true
					edo_change="1"
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					original_edo=$EDO
					EDO="$(($EDO+1))"
					edo_change=$(($edo_change+1))

					INTERVAL_LIMIT=`calc "$EDO * 2.6"`
					INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`

					if [ "$flaggy" == false ]; then
						temp="`calc \"$EDO/$orig_edo\" | cut -d'~' -f2`"
						INTERVAL="`echo \"$orig_interval*$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
					fi

					if [ "$INTERVAL" == "0" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch 2
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "0" ]; then
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

main_menu() {
	z=""
	old_LINES=$LINES
	old_COLUMNS=$COLUMNS
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi
	local initial_screen=$1
	tagged=false

	if [ "$(($COLUMNS%2))" == "0" ]; then
		even=true
	else
		even=false
	fi
	
	OPT[1]="Music"
	OPT[2]="Sound"
	OPT[3]="Video"
	OPT[4]="Queue"
	OPT[5]="Voice"
	OPT[6]="Help"
	OPT[7]="Quit"
	if [ "$LINES" -gt "10" ]; then
		TOTAL_OPTS=${#OPT[@]}
	else
		TOTAL_OPTS=3
	fi

	OPT_MUSIC_SUBMENU[1]="Loops"
	OPT_MUSIC_SUBMENU[2]="Locks"

	TOTAL_OPTS_MUSIC_SUBMENU=${#OPT_MUSIC_SUBMENU[@]}

	SELECTION="1"

	pad_=1

	flag=false
	menu_start_over=true

	first=$((($LINES/2) - ($TOTAL_OPTS/2)-1))
	last=$(($first + $TOTAL_OPTS - 1))

	empty_pane
	
	until [ "$z" = "," ]; do
		if [ "$LINES" -le "10" ]; then
			TOTAL_OPTS=3
		else
			TOTAL_OPTS=${#OPT[@]}
		fi
		if [ "$z" == "" ]; then
			x=1
			if [ "$initial_screen" == true ]; then
				echo -ne "$NOCOLOR"
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
			else
				draw_banner "MENU"
				echo -ne "$NOCOLOR"
			fi

			if [ "$(($COLUMNS%2))" == "0" ]; then
				moveleft=1
			else
				moveleft=0
			fi
			tput cup $first $(($COLUMNS/2-5-$moveleft))
				menu_buf="$PADDING$COLOR_ACCENT$TOP_BAR_MENU`tput el`"
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk${LINE_CHAR_END}`tput el`"
			else
				menu_buf="$menu_buf"
			fi

			for i in `seq 1 $TOTAL_OPTS`; do
				pad="  "
				temp="${#OPT[$i]}"
				while [ "$temp" -le "$pad_" ]; do
					pad="$pad "
					temp="$(($temp+1))"
				done
				if [ "${OPT[$i]}" == "Music" ]; then #|| [ "${OPT[$i]}" == "Sound" ] || [ "${OPT[$i]}" == "Video" ]; then
					arrow=" ›"
				else
					arrow="  "
				fi
				if [ "$i" = "$SELECTION" ]; then
					COLOR="$WHITE"
					if [ "${#OPT[$i]}" -lt "5" ]; then
						pad=" "
					else
						pad=""
					fi
					menu_buf="$menu_buf\n$PADDING$COLOR_ACCENT`tput cuf $(($COLUMNS/2-5-$moveleft))`$BAR$BLUE_BLACK ${OPT[$i]}$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR`tput el`"
					if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "1" ]; then
							if [ "$MUSIC_SELECTION" == "1" ] && [ "$i" == "1" ]; then
								menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							elif [ "$i" == "1" ]; then
								menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							fi
						fi
					fi
					if [ "$SOUND_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "1" ]; then
							menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk$LINE_CHAR_END`tput el`"
						elif [ "$SELECTION" == "2" ]; then
							if [ "$SOUND_SELECTION" == "1" ] && [ "$i" == "2" ]; then
								menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							elif [ "$i" == "2" ]; then
								menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							fi
						fi
					fi
					if [ "$VIDEO_RIGHT_WINDOW" == true ]; then
						if [ "$i" == "2" ]; then
							menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk$LINE_CHAR_END`tput el`"
						elif [ "$i" == "3" ] || [ "$i" == "4" ]; then
							if [ "$VIDEO_SELECTION" == "1" ] && [ "$i" == "3" ]; then
								menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							elif [ "$i" == "3" ]; then
								menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							fi
						fi
					fi
					if [ "$tagged" == false ] || [ "$tagged" == "" ]; then
						if [ "$nospeak" == false ]; then
							if [ "$menu_start_over" == true ]; then
								if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
									gtts_speak "menu, ${OPT[$i]}, ${OPT_MUSIC_SUBMENU[$MUSIC_SELECTION]}"
								elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
									gtts_speak "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$SOUND_SELECTION]}"
								elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
									gtts_speak "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$VIDEO_SELECTION]}"
								else
									gtts_speak "menu, ${OPT[$i]}"
								fi
								menu_start_over=false
							else
								if [ "$NO_QUEUE_FLAG" == false ]; then
									if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
										gtts_speak "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$MUSIC_SELECTION]}"
									elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
										gtts_speak "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$SOUND_SELECTION]}"
									elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
										gtts_speak "${OPT[$i]} ${OPT_MUSIC_SUBMENU[$VIDEO_SELECTION]}"
									else
										gtts_speak "${OPT[$i]}"
									fi
								else
									NO_QUEUE_FLAG=false
								fi
							fi
						fi
					fi
				else
					if [ "${#OPT[$i]}" -lt "5" ]; then
						pad=" "
					else
						pad=""
					fi
					menu_buf="$menu_buf\n$PADDING`tput cuf $(($COLUMNS/2-5-$moveleft))`$COLOR_ACCENT$BAR$WHITE ${OPT[$i]}$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR`tput el`"
					if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "1" ]; then
							if [ "$i" -ge "2" ]; then
									if [ "$MUSIC_SELECTION" == "$i" ] && [ "$i" == "2" ]; then
										menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$i]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
									elif [ "$i" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
										menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$i]} $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
									fi
							fi
						fi
					fi
					if [ "$SOUND_RIGHT_WINDOW" == true ]; then
						if [[ ( "$SELECTION" == "2" || "$SELECTION" == "3" ) && ( "$i" == "2" || "$i" == "3" ) ]]; then
							if [ "$SOUND_SELECTION" == "$(($i-1))" ]; then
								menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$(($i-1))]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							elif [ "$(($i-1))" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
								menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$(($i-1))]} $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							fi
						elif [ "$i" == "1" ]; then
							menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqk$LINE_CHAR_END`tput el`"
						fi
					fi

					if [ "$VIDEO_RIGHT_WINDOW" == true ]; then
						if [ "$SELECTION" == "3" ] && [ "$i" == "4" ]; then
							if [ "$VIDEO_SELECTION" == "$(($i-2))" ]; then
								menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$(($i-2))]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							elif [ "$(($i-2))" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
								menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$(($i-2))]} $COLOR_ACCENT$BAR$NOCOLOR`tput el`"
							fi
						elif [ "$i" == "2" ]; then
							menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqk$LINE_CHAR_END`tput el`"
						fi
					fi

					if [ "$i" == "3" ] && [ "$MUSIC_RIGHT_WINDOW" == true ]; then
						menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END`tput el`"
					fi
					if [ "$i" == "4" ] && [ "$SOUND_RIGHT_WINDOW" == true ]; then
						menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END`tput el`"
					fi
					if [ "$i" == "5" ] && [ "$VIDEO_RIGHT_WINDOW" == true ]; then
						menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END`tput el`"
					fi
				fi
			done

			menu_buf="$menu_buf\n$PADDING`tput cuf $(($COLUMNS/2-5-$moveleft))`$COLOR_ACCENT$BOTTOM_BAR_MENU`tput el`"

			tput cup $((($LINES/2) - ($TOTAL_OPTS/2)-1)) $(($COLUMNS/2-5-$moveleft))

			echo -ne "$menu_buf"
		fi

		if [ "$z" == "" ]; then
			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.05
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait
						if [ "$(($COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						render_help_screen
						render_repeat_help_screen
						render_voice_settings_screen
						render_scale_help_screen
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						if [ "$initial_screen" == false ]; then
							draw_volume
							draw_equalizer
							draw_position
						fi
						break
					else
						screen_redrawn=false
					fi
					read -rsn1 -t $BANNER_WAIT_TIME z
					if [ "$?" == "0" ]; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "j" ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$MUSIC_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					MUSIC_SELECTION=$(($MUSIC_SELECTION+1))
				fi
			elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [ "$SOUND_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					SOUND_SELECTION=$(($SOUND_SELECTION+1))
				fi
			elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$VIDEO_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					VIDEO_SELECTION=$(($VIDEO_SELECTION+1))
				fi
			else
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$(($SELECTION+1))"
				else
					SELECTION="1"
				fi
			fi
			tagged=false
			flag=true
			z=""
			continue
		elif [ "$z" == "k" ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$MUSIC_SELECTION" != "1" ]; then
					MUSIC_SELECTION=$(($MUSIC_SELECTION-1))
				fi
			elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [ "$SOUND_SELECTION" != "1" ]; then
					SOUND_SELECTION=$(($SOUND_SELECTION-1))
				fi
			elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$VIDEO_SELECTION" != "1" ]; then
					VIDEO_SELECTION=$(($VIDEO_SELECTION-1))
				fi
			else
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$(($SELECTION-1))"
				else
					SELECTION="$TOTAL_OPTS"
				fi
			fi
			tagged=false
			flag=true
			z=""
			continue
		elif [ "$z" == "l" ]; then
			if [ "$SELECTION" == "1" ]; then
				MUSIC_RIGHT_WINDOW=true
				SOUND_RIGHT_WINDOW=false
				VIDEO_RIGHT_WINDOW=false
				MUSIC_SELECTION=1
			#elif [ "$SELECTION" == "2" ]; then
			#	SOUND_RIGHT_WINDOW=true
			#	MUSIC_RIGHT_WINDOW=false
			#	VIDEO_RIGHT_WINDOW=false
			#	SOUND_SELECTION=1
			#elif [ "$SELECTION" == "3" ]; then
			#	VIDEO_RIGHT_WINDOW=true
			#	SOUND_RIGHT_WINDOW=false
			#	MUSIC_RIGHT_WINDOW=false
			#	VIDEO_SELECTION=1
			fi
			z=""
			continue
		elif [ "$z" == "h" ]; then
			echo -ne "$WHITE"
			MUSIC_RIGHT_WINDOW=false
			SOUND_RIGHT_WINDOW=false
			VIDEO_RIGHT_WINDOW=false
			MUSIC_SELECTION=1
			SOUND_SELECTION=1
			VIDEO_SELECTION=1
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			if [ "$initial_screen" == true ]; then
				menu_start_over=true
			fi
			draw_banner "MENU"
			draw_position
			flag=true
			z=""
			continue
		elif [ "$z" == "i" ]; then
			if [ "$initial_screen" == true ]; then
				flag=true
				z=""
				continue
			else
				z=","
			fi
		elif [ "$z" == "a" ]; then
			set_equalizer false true
			draw_equalizer
			z=""
			continue
		elif [ "$z" == "|" ]; then
			vanish
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_colors true
			z=""
			continue
		elif [ "$z" == "" ]; then
			invert_colors true
			empty_pane
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			z=""
			continue
		elif [ "$z" == "X" ]; then
			set_scale_speed
			draw_banner "MENU"
			z=""
			continue
		elif [ "$z" == "q" ]; then
			if [ "$initial_screen" == true ]; then
				clear
				tput cnorm
				stty echo
				exit 0
			fi
			z=","
		elif [ "$z" == "C" ]; then
			yt_artist
			z=""
			continue
		elif [ "$z" == "F" ]; then
			yt_search
			z=""
			continue
		elif [ "$z" == "f" ]; then
			tmux_attach
			z=""
			continue
		elif [ "$z" == "8" ]; then
			system_volume_change "-3% -3%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change "+3% +3%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change "-1% -1%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change "+1% +1%"
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$(($VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$(($VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$(($VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$(($VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			flag=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "MENU"
			flag=true
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait
			REDRAWN=true
			reset_dimensions
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
				reset_buffer
			fi
			flag=false
			z=""
			continue
		elif [ "$z" == ":" ]; then
			tput cup 1
			tput el
			tput cup $(($LINES-2))
			tput el
			voice_settings_screen true
			if [ "$initial_screen" == true ]; then
				empty_pane
			else
				redraw_buffer
			fi
			flag=false
			z=""
			continue
		elif [ "$z" == "?" ]; then
			tput cup 1
			tput el
			tput cup $(($LINES-2))
			tput el
			if [ "$initial_screen" == true ]; then
				help_screen true
				empty_pane
			else
				help_screen false
				empty_pane
			fi
			flag=false
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "S" ]; then
			new_playlist true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			flag=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_panels
			z=""
			continue
		elif [ "$z" == "s" ]; then
			if [ "$initial_screen" == false ]; then
				REPEAT_ONLY=false
			else
				VIDEO=false
				unset queue_array
				IFS=$'\n'
				index=0
				for i in $(find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | sort); do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				unset IFS
				TOTAL_QUEUE=$index
				SHUFFLED=true
				if [ "$TOTAL_QUEUE" == "0" ]; then
					draw_banner "NO MUSIC"
					gtts_speak "no music"
					sleep $BANNER_WAIT_TIME
					NO_QUEUE_FLAG=true
					menu_start_over=true
					continue
				fi
				JUMP="1"
				echo -ne "$NOCOLOR"
			fi
			if [ "$initial_screen" == true ]; then
				start_search true
			else
				start_search
			fi
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			redraw_buffer
			z=""
			continue
		elif [ "$z" == "Q" ]; then
			queue_controls true
			if [ "$?" == "$RETURN_JUMP" ]; then
				JUMP=1
				return $RETURN_JUMP
			fi
			empty_pane
			flag=false
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$(($SELECTION+1))"
				fi
				tagged=false
				flag=true
				z=""
				continue
				;;
			'[A')
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$(($SELECTION-1))"
				fi
				tagged=false
				flag=true
				z=""
				continue
				;;
			*)
				if [ "$initial_screen" == true ]; then
					exit 0
				else
					tput cup $(($LINES-2))
					tput el
					z=","
				fi
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_RIGHT_WINDOW=false
				if [ "$MUSIC_SELECTION" == "1" ]; then
					VIDEO=false
					load_only_loops true
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO LOOPS"
						gtts_speak "no music loops"
						sleep $BANNER_WAIT_TIME
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "$MUSIC_SELECTION" == "2" ]; then
					VIDEO=false
					set_only_locked false false false false true
					if [ "$?" == "50" ]; then
						draw_banner "NO LOCKS"
						gtts_speak "no locked music" true
						sleep $BANNER_WAIT_TIME
						#tput cup $LINES
						#echo -ne "$WHITE_BLACK"
						#printf '%*s' $COLUMNS
						#echo -ne "$NOCOLOR"
						continue
					else
						draw_banner "WAIT"
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
			case $SELECTION in
			*)
				if [ "${OPT[$SELECTION]}" == "Search" ]; then
					new_playlist true
					if [ "$?" == "$RETURN_JUMP" ]; then
						return $RETURN_JUMP
					fi
					flag=true
				elif [ "${OPT[$SELECTION]}" == "Music" ]; then
					QUEUE_RENDERED=false
					PICK=""
					if [ "$initial_screen" == false ]; then
						REPEAT_ONLY=false
					fi
					VIDEO=false
					unset queue_array
					IFS=$'\n'
					index=0
					for i in `find "$MUSICDIR" \( -iname "*.mp3" -o -iname "*.flac" \) -and -not -iname "*\.repeat\.*" | shuf`; do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					SHUFFLED=true
					TOTAL_QUEUE=$index
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						sleep $BANNER_WAIT_TIME
						gtts_speak "no music" true
						menu_start_over=true
						NO_QUEUE_FLAG=true
						continue
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Sound" ]; then
					QUEUE_RENDERED=false
					PICK=""
					REPEAT_ONLY=false
					VIDEO=false
					unset queue_array

					IFS=$'\n'
					index=0
					for i in `find "$SOUNDDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					SHUFFLED=true
					new_TOTAL_QUEUE=$index
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO SOUNDS"
						gtts_speak "no sounds" true
						sleep $BANNER_WAIT_TIME
						menu_start_over=true
						NO_QUEUE_FLAG=true
						draw_position
						continue
						
					else
						TOTAL_QUEUE="$new_TOTAL_QUEUE"
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Video" ]; then
					QUEUE_RENDERED=false
					REPEAT_ONLY=false
					unset queue_array

					IFS=$'\n'
					index=0
					for i in `find "$VIDEODIR" -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.webm" | shuf`; do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					TOTAL_QUEUE=$(($index))
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO VIDEOS"
						gtts_speak "no videos" true
						sleep $BANNER_WAIT_TIME
						NO_QUEUE_FLAG=true
						menu_start_over=true
						continue
						
					fi					
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
					if [ -e "$ALETHEIA/playlists/" ] && [ "`ls -1 \"$ALETHEIA/playlists/\" | wc -l`" != "0" ]; then
						queue_controls true
					else
						queue_controls true
					fi
					if [ "$?" == "$RETURN_JUMP" ]; then
						JUMP=1
						return $RETURN_JUMP
					fi
					empty_pane
					menu_start_over=true
					flag=false
				elif [ "${OPT[$SELECTION]}" == "Voice" ]; then
					tput cup 1
					tput el
					tput cup $(($LINES-2))
					tput el
					voice_settings_screen true
					#if [ "$initial_screen" == true ]; then
					#	empty_pane
					#else
					#	redraw_buffer
					#fi
					flag=false
				elif [ "${OPT[$SELECTION]}" == "Help" ]; then
					tput cup 1
					tput el
					tput cup $(($LINES-2))
					tput el
					if [ "$initial_screen" == true ]; then
						help_screen true
						#empty_pane
					else
						help_screen false
						#redraw_buffer
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					fi
					flag=false
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "Quit" ]; then
					clear
					exit 0
				else
					z=","
				fi

			esac
		fi
		if [ "$z" = "," ]; then
			if [ "$1" == false ] || [ "$1" == "" ]; then
				reset_buffer
				redraw_buffer
				draw_pitch
				draw_position
			fi
			gtts_speak "closed" true
			z=","
		fi
	done
}

scale() {
	if [ "$WEB_CLIENT" != 1 ]; then
		gtts_speak "scale interval"
	fi
	draw_banner "SCALE"
	stopat=""
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 interval_change <&1
	else
		read -rsn1 interval_change <"$ALETHEIA/web_client_pipe$$"
	fi

	if [ "$interval_change" = "J" ]; then
		if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=2.5
		interval_change="$(($INTERVAL-$EDO))"
	elif [ "$interval_change" = "K" ]; then
		if [ "$INTERVAL" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=2.5
		interval_change="$(($INTERVAL+$EDO))"
	elif [ "$interval_change" == "j" ]; then
		if [ "$INTERVAL" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=$SCALE_SPEED
		interval_change="$(($INTERVAL-$EDO))"
	elif [ "$interval_change" == "k" ]; then
		if [ "$INTERVAL" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=$SCALE_SPEED
		interval_change="$(($INTERVAL+$EDO))"
	elif [ "$interval_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "?" ]; then
		scale_help_screen
		RIGHT_BANNER_WIDTH=0
		redraw_buffer
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "" ] || [ "$interval_change" == "q" ] || [ "$interval_change" == "u" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "`isnum \"$interval_change\"`" != "0" ] || [ "$interval_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="`read_line \"$interval_change\"`"
		if [ "`isnum \"$tmp\"`" == "0" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		if [ "$tmp" -lt "$INTERVAL" ]; then
			if [ "$tmp" -le "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=true
			time=$SCALE_SPEED
			interval_change="$(($INTERVAL-$EDO))"
		elif [ "$tmp" -gt "$INTERVAL" ]; then
			if [ "$tmp" -ge "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=false
			time=$SCALE_SPEED
			interval_change="$(($INTERVAL+$EDO))"
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "SCALE" false true
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$interval_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		orig_int="$INTERVAL"
		c=""
		while [ "$interval_change" != "$orig_int" ]; do
			if [ "$interval_change" -le "$orig_int" ] || [ "$BACKWORDS" == true ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t $SCALE_SPEED c
				else
					read -rsn1 -t $SCALE_SPEED c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ]; then
					if [ "$c" == "c" ]; then
						sleep $SCALE_SPEED
						gtts_speak "order reversed"
					fi
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						INTERVAL="$(($INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						interval_change="$(($interval_change * -1))"
					else 
						backwards=true
						interval_change="$(($interval_change*-1))"
						INTERVAL="$(($INTERVAL-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
					INTERVAL="$(($INTERVAL-1))"
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
					gtts_speak "limit reached"
					break
				fi

			elif [ "$interval_change" -ge "$orig_int" ] || [ "$backwards" == false ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t $SCALE_SPEED c
				else
					read -rsn1 -t $SCALE_SPEED c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ] || [ "$backwards" == true ]; then
					if [ "$c" == "c" ]; then
						sleep $SCALE_SPEED
						gtts_speak "order reversed"
					fi
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						INTERVAL="$(($INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						INTERVAL="$(($INTERVAL+1))"
					else
						backwards=true
						INTERVAL="$(($INTERVAL-1))"
						interval_change="$(($interval_change*-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					INTERVAL="$(($INTERVAL+1))"
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
					gtts_speak "limit reached"
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

scale_octave() {
	draw_banner "OCTAVE" false true
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	if [ "$1" == "-" ]; then
		orig_int=$INTERVAL
		if [ "$(($INTERVAL-$EDO))" -ge "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$(($INTERVAL-$EDO))
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -lt "$EDO" ]; do
					read -rsn1 -t $SCALE_SPEED c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$(($INTERVAL-1))"
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$(($x+1))
					fi
				done
			fi
		fi
	elif [ "$1" == "+" ]; then
		orig_int=$INTERVAL
		if [ "$(($INTERVAL+$EDO))" -le "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$(($INTERVAL+$EDO))
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -le "$EDO" ]; do
					read -rsn1 -t $SCALE_SPEED c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$(($INTERVAL+1))"
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$(($x+1))
					fi
				done
			fi
		fi
	fi
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

set_custom_int() {
	gtts_speak "enter interval"
	draw_banner "INT"
	read -n1 interval_jump
	if [ "`isnum \"$interval_jump\"`" == "1" ] || [ "$interval_jump" == "-" ]; then
		interval_jump="`read_line \"$interval_jump\"`"
	else
		gtts_speak "closed" true
		draw_pitch
		redraw_buffer
		return
	fi
	if [ "$interval_jump" != "" ]; then
		PAUSE=false
		echo -e "speed_set `calc \"2^($interval_jump/$EDO)\"`" >"$ALETHEIA/pipe$$" &
		INTERVAL="$interval_jump"
	else
		gtts_speak "closed" true
		draw_position
	fi
	draw_pitch
}

toggle_mute() {
	#echo "pausing_keep mute" >"$ALETHEIA/pipe$$" &
	if [ $MUTE = false ]; then
		gtts_speak "muted" true
		if [ "$OS" == "Darwin" ]; then
			osascript -e 'set volume with output muted'
		elif [ "$OS" == "Linux" ]; then
			pactl set-sink-mute @DEFAULT_SINK@ 1 >/dev/null 2>/dev/null
		fi
		MUTE=true
		draw_banner "MUTE"
	else
		if [ "$OS" == "Linux" ]; then
			pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
		elif [ "$OS" == "Darwin" ]; then
			osascript -e "set volume output volume $SYSTEM_VOLUME_LEFT"
		fi
		gtts_speak "unmuted"
		MUTE=false
		draw_pitch
	fi
}

toggle_pause() {
	echo -e "pause" >"$ALETHEIA/pipe$$" &
	if [ $PAUSE = false ]; then
		PAUSE=true
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "paused"
			draw_banner "PAUSE" false false true
		fi
	else
		PAUSE=false
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "unpaused"
			draw_pitch
		fi
	fi
}

interval_to_zero() {
	INTERVAL="0"
	echo "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	LOCKED=false
	draw_volume
	draw_equalizer
	draw_pitch
	draw_position
}

reset_all_tuning() {
	SCALETEMPO=false
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	sleep $MPLAYER_WAIT_TIME
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	gtts_speak "reset"
	draw_volume
	draw_equalizer
	draw_pitch
}

read_locked_file() {
	CONTENTS="$1"
	IFS='/' read _int _edo _scaletempo_flag oldstyle1 oldstyle2 <<< "$CONTENTS"
	if [ "$oldstyle1" != "" ] && [ "$oldstyle2" != "" ]; then
		# backwards compatible with old style locked file
		_scaletempo_flag=$oldstyle2
	fi
	INTERVAL=$_int
	EDO=$_edo
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
}

reset_to_locked() {
	if [ -e "$FILENAME.locked" ]; then
		read_locked_file "$(cat "$FILENAME.locked")"
		LOCKED=true

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		
		if [ "$EQUALIZER" == "" ]; then
			EQUALIZER="$DEFAULT_EQUALIZER"
			equal="`echo $EQUALIZER | cut -d':' -f1`"
			equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
			equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
		else
			if [ "$EQUALIZER" != "0:0:0:0:0:0:0:0:0:0" ]; then
				echo -e "af_del equalizer" >"$ALETHEIA/pipe$$" &
				echo -e "af_add equalizer=$EQUALIZER" >"$ALETHEIA/pipe$$" &

				equal="`echo $EQUALIZER | cut -d':' -f1`"
				equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
				equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
			fi
		fi

		if [ "$_scaletempo_flag" == "" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "0" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "1" ]; then
			SCALETEMPO=true
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "2" ]; then
			SCALETEMPO=true
			ONLY_PITCH=true
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		fi
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		sleep $MPLAYER_WAIT_TIME
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	else
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$DEFAULT_EDO"
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
		echo "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		VOLUME="$DEFAULT_VOLUME"
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	gtts_speak "tuning reset"
	draw_equalizer
	draw_volume
	draw_pitch
	draw_position
}

set_custom_edo() {
	draw_banner "EDO"
	gtts_speak "enter e d o"
	read -n1 new_edo
	if [ "`isnum \"$new_edo\"`" == "1" ]; then
		new_edo="`read_line \"$new_edo\"`"
	else
		gtts_speak "closed" true
		draw_pitch
		redraw_buffer
		return
	fi

	reset_buffer
	if [ "$new_edo" = "" ]; then
		gtts_speak "closed" true
		draw_pitch
		redraw_buffer
		return
	fi

	if [ "`isnum \"$new_edo\"`" != "0" ]; then
		PAUSE=false
		LEVEL="${#new_edo}"
		if [ "$new_edo" -lt "1" ]; then
			return
		fi
		if [ "$new_edo" -gt "$EDO" ]; then
			temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
			INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
		elif [ "$new_edo" -lt "$EDO" ]; then
			temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2 | bc`"
			INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
		else
			draw_pitch
			draw_position
			return
		fi

		EDO="$new_edo"
		LOCKED_EDO="$EDO"
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		LOCKED=false
		draw_volume
		draw_equalizer
		redraw_buffer
		draw_pitch
		draw_position
	else
		redraw_buffer
		draw_pitch
	fi
}

double_precise() {
	if [ "$EDO" -lt "$EDO_LIMIT" ]; then
		INTERVAL=$(($INTERVAL * 2))
		EDO=$(($EDO*2))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		INTERVAL_LIMIT=`calc "$EDO * 2.6"`
		INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
		gtts_speak "$EDO"
	else
		gtts_speak "limit"
	fi
}

half_precise() {
	old="`calc \"($INTERVAL/$EDO)\"`"
	if [ "$(($EDO % 2))" = "0" ]; then
		new_edo="$(($EDO/2))"
		if [ "$new_edo" -ge "2" ]; then
			temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
			INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
			if [ "`isnum \"$INTERVAL\"`" == "0" ]; then
				INTERVAL=0
			fi
			EDO="$new_edo"
			new="`calc \"($INTERVAL/$EDO)\"`"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			INTERVAL_LIMIT=`calc "$EDO * 2.6"`
			INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
			gtts_speak "$EDO"
		else
			gtts_speak "limit"
		fi
		if [ "$old" != "$new" ]; then
			LOCKED=false
		fi
		draw_pitch
	fi
}

pitch_down() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -gt "-`echo -n $INTERVAL_LIMIT | cut -d'.' -f1`" ]; then
		INTERVAL=$(($INTERVAL-1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

pitch_up() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -lt "`echo -n $INTERVAL_UPPER_LIMIT | cut -d'.' -f1`" ]; then
		INTERVAL=$(($INTERVAL+1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

edo_down() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -gt "1" ]; then
		EDO=$(($EDO-1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		tmpz=$(($EDO*2))
		if [ "$INTERVAL" -gt "$tmpz" ] || [ "$INTERVAL" -lt "$((-$tmpz))" ]; then
			if [ "$INTERVAL" -lt "0" ]; then
				INTERVAL=-$tmpz
			else
				INTERVAL=$tmpz
			fi
		fi

		LOCKED=false
		draw_pitch 2
		gtts_speak " $EDO"
	else
		gtts_speak "limit"
	fi

	return 200
}

set_default_edo() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	new_edo="$DEFAULT_EDO"
	if [ "$new_edo" -gt "$EDO" ]; then
		temp="`calc \"$new_edo/$EDO\" | cut -d'~' -f2`"
		INTERVAL="`echo \"$INTERVAL*$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
	elif [ "$new_edo" -lt "$EDO" ]; then
		temp="`calc \"$EDO/$new_edo\" | cut -d'~' -f2`"
		INTERVAL="`echo \"$INTERVAL/$temp\" | bc | cut -d'~' -f2 | cut -d'.' -f1`"
	fi
	EDO="$new_edo"
	INTERVAL_LIMIT=`calc "$EDO * 2.6"`
	INTERVAL_UPPER_LIMIT=`calc "$EDO * 2.1"`
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	LOCKED=false
	draw_pitch 1
	gtts_speak "$EDO"
}

edo_up() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -lt "2000000" ]; then
		EDO=$(($EDO+1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		draw_pitch 2
		gtts_speak "$EDO"
	else
		gtts_speak "limit"
	fi

	return 200
}

toggle_scale_tempo() {
	if [ "$SCALETEMPO" == false ]; then
		echo -e "af_add scaletempo" >"$ALETHEIA/pipe$$" &
		gtts_speak "tempo"
		SCALETEMPO=true
		ONLY_PITCH=false
	else
		if [ "$ONLY_PITCH" == false ]; then
			ONLY_PITCH=true
			gtts_speak "pitch"
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep $MPLAYER_WAIT_TIME
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		else
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			gtts_speak "pitch and tempo"
			SCALETEMPO=false
			ONLY_PITCH=false
		fi
	fi
	if [ "$PAUSE" == true ]; then
		PAUSE=false
	fi
	draw_pitch 3
}

secondary_scale_func() {
	if [ "$1" == "v" ]; then
		toggle_scale_tempo
	elif [ "$1" == "j" ]; then
		pitch_down
	elif [ "$1" == "k" ]; then
		pitch_up
	elif [ "$1" == "l" ]; then
		gtts_speak "forward"
		echo "seek +5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "h" ]; then
		gtts_speak "backward"
		echo "seek -5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "8" ]; then
		system_volume_change "-3% -3%"
	elif [ "$1" == "9" ]; then
		system_volume_change "+3% +3%"
	elif [ "$1" == "*" ]; then
		system_volume_change "-1% -1%"
	elif [ "$1" == "(" ]; then
		system_volume_change "+1% +1%"
	elif [ "$1" == "H" ]; then
		less_precise
	elif [ "$1" == "L" ]; then
		more_precise
	elif [ "$1" == "o" ]; then
		pause=false
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$"
			mute=false
			draw_pitch
		fi
		double_precise
	elif [ "$1" == "m" ]; then
		pause=false
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$"
			mute=false
			draw_pitch
		fi
		half_precise				
	elif [ "$1" == "M" ]; then
		invert_int
	elif [ "$1" == "a" ]; then
		PAUSE=false
		pause=false
		draw_banner "$2" false true
		set_equalizer
		draw_banner "$2" false true
	elif [ "$1" == "y" ]; then
		set_default_edo
	elif [ "$1" == "!" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "@" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "1" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "2" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "p" ]; then
		toggle_pause
		draw_banner "$2" false true
		if [ "$WEB_CLIENT" == "0" ]; then
			read -n1 input_char
		else
			read -n1 input_char <"$ALETHEIA/web_client_pipe$$"
		fi

		toggle_pause
		draw_banner "$2" false true
	elif [ "$1" == "T" ]; then
		set_only_display_song
		redraw_buffer
	elif [ "$1" == "\\" ]; then
		echo "seek 0 2" >"$ALETHEIA/pipe$$" &
	else
		process_key "$1"
		return
	fi
}

oscillate() {
	old_int="$INTERVAL"
	gtts_speak "oscillate; enter an interval to oscillate to or push enter to invert"
	draw_banner "OSCILLATE"
	tput rc
	read -rsn1 result
	if [ "$result" == "q" ] || [ "$result" == "G" ] || [ "$result" == "" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi
	if [ "$result" != "" ]; then
		result="`read_line \"$result\"`"
	fi
	if [ "$result" != "" ]; then
		if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			if [ "$INTERVAL" -lt "$result" ]; then
				NEGATIVE=true
			else
				NEGATIVE=false
			fi
			abs_int=${INTERVAL#-}
			abs_result=${result#-}
			if [ "$abs_int" -gt "$abs_result" ]; then
				result="`echo -e \"$abs_int - $abs_result\" | bc`"
			elif [ "$abs_int" -lt "$abs_result" ]; then
				result="`echo -e \"$abs_result - $abs_int\" | bc`"
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -gt "0" ]; then
			if [ "$INTERVAL" -gt "$result" ]; then
				result="`echo -e \"$INTERVAL - $result\" | bc`"
				NEGATIVE=false
			elif [ "$INTERVAL" -lt "$result" ]; then
				result="`echo -e \"$result - $INTERVAL\" | bc`"
				NEGATIVE=true
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -lt "0" ]; then
			abs_result=${result#-}
			result="`echo -e \"$abs_result + $INTERVAL\" | bc`"
			NEGATIVE=false
		elif [ "$INTERVAL" -lt "0" ] && [ "$result" -gt "0" ]; then
			abs_int=${INTERVAL#-}
			result="`echo -e \"$result + $abs_int\" | bc`"
			NEGATIVE=true
		elif [ "$INTERVAL" == "0" ] || [ "$result" == "0" ]; then
			if [ "$INTERVAL" == "0" ] && [ "$result" == "0" ]; then
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			elif [ "$INTERVAL" == "0" ]; then
				if [ "$result" -lt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				result="`calc \"abs($result)\" | sed \"s/\\t//g\"`"
			elif [ "$result" == "0" ]; then
				if [ "$INTERVAL" -lt "0" ]; then
					NEGATIVE=true
				else
					NEGATIVE=false
				fi
				result="`calc \"abs($INTERVAL)\" | sed \"s/\\t//g\"`"
			fi
		fi
	fi
	if [ "$result" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi
	if [ "$INTERVAL" == "0" ]; then
		gtts_speak "can't oscillate; interval at zero"
		draw_pitch
		draw_position
		return
	fi
	draw_banner "OSCILLATE" false true
	gtts_speak "oscillating"
	if [ "$result" == "" ]; then
		old_int="$INTERVAL"
		INTERVAL="$((-($INTERVAL)))"
		if [ "$INTERVAL" -lt "0" ]; then
			result="$old_int"
		else
			result="$INTERVAL"
		fi
		result="$(($result*2))"
		if [ "$old_int" -gt "0" ]; then
			NEGATIVE=false
		else
			NEGATIVE=true
		fi
	fi
	x=0

	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$x" -lt "$result" ]; do
		read -rsn1 -t $SCALE_SPEED c
		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		#FIXME
		if [ "$c" == "o" ]; then
			old_int=$(($old_int*2))
			if [ "$EDO" -lt "$EDO_LIMIT" ]; then
				x=$(($x*2))
				result=$(($result*2))
			fi
		elif [ "$c" == "m" ]; then
			#old_int=$INTERVAL
			if [ "$(($EDO % 2))" == "0" ]; then
				old_int=$(($old_int/2))
				x=$(($x/2))
				result=$(($result/2))
			fi
		fi
		secondary_scale_func "$c" "OSCILLATE"
		if [ "$c" == "c" ]; then
			x=$(($result-$x-2))
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
		# FIXME
		elif [ "$c" == "H" ]; then
			old_int=$INTERVAL
		elif [ "$c" == "L" ]; then
			old_int=$INTERVAL
		elif [ "$c" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "OSCILLATE" false true
			redraw_screen false 1 1 1 0
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_pitch
			draw_banner "OSCILLATE" false true
		elif [ "$c" == "q" ] || [ "$c" == "" ]; then
			break
		elif [ "$c" == "" ]; then
			if [ "$NEGATIVE" == false ]; then
				INTERVAL="$(($old_int-1))"
				old_int="$(($old_int-1))"
			else
				INTERVAL="$(($old_int+1))"
				old_int="$(($old_int+1))"
			fi
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			x="$(($x+1))"
		fi

		if [ "$x" == "$result" ]; then
			x=0
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
			read -rsn1 -t $SCALE_SPEED c
			ps -p $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch
				draw_position
				return
			fi
			if [ "$c" == "o" ]; then
				old_int=$(($old_int*2))
				if [ "$EDO" -lt "$EDO_LIMIT" ]; then
					x=$(($x*2))
					result=$(($result*2))
				fi
			elif [ "$c" == "m" ]; then
				if [ "$(($EDO % 2))" == "0" ]; then
					old_int=$(($old_int/2))
					x=$(($x/2))
					result=$(($result/2))
				fi
			fi
			secondary_scale_func "$c" "OSCILLATE"
			if [ "$c" == "c" ]; then
				x=$(($result-$x-2))
				if [ "$NEGATIVE" == true ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
			elif [ "$c" == "H" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "L" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "z" ]; then
				draw_wait
				reset_dimensions
				draw_banner "OSCILLATE" false true
				redraw_screen false 1 1 1 0
			elif [ "$c" == "q" ] || [ "$c" == "" ]; then
				break
			elif [ "$c" == "" ]; then
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			fi
		fi

	done
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

pcm_volume_change() {
	ps -p $MPLAYER_PID >/dev/null 2>/dev/null
	if [ "$?" == "1" ]; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
				JUMP="1"
				POSITION="1"
				draw_position
				return $RETURN_JUMP
			else
				return 0
			fi
		fi
	fi
	if [ "$1" == "1" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "5" ]; then
			VOLUME="$(($VOLUME-5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "2" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "95" ]; then
			VOLUME="$(($VOLUME+5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "!" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "1" ]; then
			VOLUME="$(($VOLUME-1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "@" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "99" ]; then
			VOLUME="$(($VOLUME+1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	fi
	read -n1 -t 0.1 key
	if [ "$key" != "" ]; then
		if [ "$key" == "1" ] || [ "$key" == "2" ] || [ "$key" == "!" ] || [ "$key" == "@" ]; then
			pcm_volume_change "$1"
			if [ "$?" != "200" ]; then
				return $?
			fi
		fi
	fi
	return 200
}

set_system_volume() {
	if [ "$OS" == "Linux" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ $1
	elif [ "$OS" == "Darwin" ]; then
		osascript -e "set volume output volume $1" 
	fi
}

system_volume_change() {
	leftvolume=${SYSTEM_VOLUME_LEFT%\%}
	rightvolume=${SYSTEM_VOLUME_RIGHT%\%}
	if [ "$leftvolume" == "" ]; then
		leftvolume=0
	fi
	if [ "$OS" == "Linux" ]; then
		pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
	elif [ "$OS" == "Darwin" ]; then
		osascript -e "set volume without output muted"
	else
		return
	fi
	dir="$(echo -ne "$1" | cut -b1)"
	num="$(echo -ne "$1" | cut -b2)"
	num2="$(echo -ne "$1" | cut -b6)"
	if [ "$dir" == "+" ]; then
		if (( $leftvolume + 1 <= 100 )) && (( $rightvolume + 1 <= 100 )); then
			l=$(($leftvolume + $num))
			r=$(($rightvolume + $num2))
			if (( $l > 100 )) && (( $r > 100 )); then
				set_system_volume "+$((100 - $leftvolume))% +$((100 - $rightvolume))%"
			elif (( $l > 100 )); then
				set_system_volume "+$((100 - $leftvolume))% +$num2%"
			elif (( $r > 100 )); then
				set_system_volume "+$num% +$((100 - $rightvolume))%"
			else
				set_system_volume "$1"
			fi
		fi
	else
		if (( $leftvolume - 1 >= 0 )) && (( $rightvolume - 1 >= 0 )); then
			l=$(($leftvolume - $num))
			r=$(($rightvolume - $num2))
			if [ "$OS" == "Linux" ]; then
				if (( $l < 0 )) && (( $r < 0 )); then
					set_system_volume "-$leftvolume% -$rightvolume%"
				elif (( $l < 0 )); then
					set_system_volume "-$leftvolume% -$num2%"
				elif (( $r < 0 )); then
					set_system_volume "-$num% -$rightvolume%"
				else
					set_system_volume "$1"
				fi
			fi
		fi
	fi
	get_system_volume
	draw_volume 2 3
}

fade_volume() {
	inputchar=""
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		inputchar="$_input"
	fi
	draw_banner "FADE"
	gtts_speak "select direction to fade"
	PAUSE=false
	MUTE=false
	x=0
	if [ "$inputchar" == "" ]; then
		read -n1 inputchar
	fi
	down=false
	up=false
	if [ "$inputchar" == "j" ]; then
		down=true
		gtts_speak "down"
	elif [ "$inputchar" == "k" ]; then
		up=true
		gtts_speak "up"
	else
		gtts_speak "closed" true
		draw_pitch
		return
	fi

	if [ "$down" == true ] && [ "$VOLUME" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	if [ "$up" == true ] && [ "$VOLUME" == "100" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	while [ "$x" -le "100" ] && [ "$VOLUME" -ge "0" ] && [ "$VOLUME" -le "100" ]; do
		if [ "$up" == true ]; then
			if [ "$VOLUME" == "100" ]; then
				draw_pitch
				return
			fi
			VOLUME="$(($VOLUME+1))"
		elif [ "$down" == true ]; then
			if [ "$VOLUME" == "0" ]; then
				draw_pitch
				return
			fi
			VOLUME="$(($VOLUME-1))"
		fi
		echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		draw_volume
		read -rsn1 -t $BANNER_WAIT_TIME c
		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "3" ]; then
			gtts_speak "closed" true
			draw_pitch
			break
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "FADE"
		elif [ "$c" == "c" ]; then
			if [ "$down" == true ]; then
				down=false
				up=true
			else
				down=true
				up=false
			fi
			gtts_speak "order reversed"
		elif [ "$c" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "FADING"
			redraw_screen false 1 1 0 1
		fi
		x=$(($x+1))
	done
	draw_pitch
	redraw_buffer
}

sleep_countdown() {
	local var="$1"
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 -t `calc "$1 * 60"` tmp
	else
		read -rsn1 -t `calc "$1 * 60"` tmp <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$tmp" != "" ]; then
		gtts_speak "sleep canceled"
		tput cup $(($LINES-3))
		tput el
		echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
		echo -ne "${PADDING}${WHITE}Sleep canceled"
		draw_pitch
		return
	fi
	if [ "$SLEEPING" == true ]; then
		SLEEPING=false
		empty_pane
		tput cup $(($LINES-3))
		echo -ne "${PADDING}${WHITE}Sleeping now..."
		x="$VOLUME"
		while [ "$x" -ge "0" ] && [ "$VOLUME" -gt "0" ]; do
			VOLUME="$(($VOLUME-1))"
			echo "volume $x 1" >"$ALETHEIA/pipe$$" &
			draw_volume
			if [ "$WEB_CLIENT" == "0" ]; then
				read -rsn1 -t 0.7 tmp
			else
				read -rsn1 -t 0.7 tmp <"$ALETHEIA/web_client_pipe$$"
			fi
			if [ "$tmp" != "" ]; then
				echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
				return
			fi
			x=$(($x-1))
		done

		kill $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$SUSPEND" == true ]; then
			systemctl suspend
		fi
		exit 0
	fi
}

set_sleep() {
	if [ "$WEB_CLIENT" == "0" ]; then
		empty_pane
		draw_banner "SLEEP"
		gtts_speak "sleep"
		tput cup $(($LINES-3))
		echo -ne "$NOCOLOR${PADDING}${WHITE}How many minutes$BLUE? "
		answer="`read_line`"
	else
		answer="180"
	fi

	if [ "$answer" != "" ]; then
		if [ "`isnum \"$answer\"`" != "0" ]; then
			SLEEPING=true
			if [ "$WEB_CLIENT" == "0" ]; then
				empty_pane
				tput cup $(($LINES-3))
				gtts_speak "suspend?"
				echo -ne "${PADDING}${WHITE}Do you want to suspend$BLUE? "
				read -rsn1 suspend
			else
				suspend="y"
			fi
		
			if [ "$suspend" == "y" ] || [ "$suspend" == "Y" ]; then
				SUSPEND=true
			else
				SUSPEND=false
			fi
			tput cup $(($LINES-3))
			tput el
			if [ "$VOICE_ENABLED" == true ]; then
				if [ "$answer" != "1" ]; then
					gtts_speak "sleep enabled"
				else
					gtts_speak "sleep enabled"
				fi
			fi
			if [ "$SUSPEND" == true ]; then
				echo -ne "${PADDING}${WHITE}Suspending in $BLUE$answer ${WHITE}minute"
			else
				echo -ne "${PADDING}${WHITE}Sleeping in $BLUE$answer ${WHITE}minute"
			fi
			if [ "$answer" != "1" ]; then
				echo -ne "s"
			fi
			PAUSE=false
			if [ "$MUTE" == true ]; then
				echo "mute" >"$ALETHEIA/pipe$$" &
				MUTE=false
			fi
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_position
			sleep_countdown "$answer"
			sleep 1
			redraw_buffer
		else
			gtts_speak "closed" true
			draw_pitch
			redraw_buffer
		fi
	else
		gtts_speak "closed" true
		draw_pitch
		redraw_buffer
	fi
}

read_line() {
	local h=$1
	IFS=$'\n'
	line=""
	stty -echo
	if [ "$h" != "" ]; then
		x="$1"
	else
		read -n1 x
	fi
	if [ "$x" == "" ]; then
		unset IFS
		return
	fi
	if [ "$x" == "" ]; then
		unset IFS
		return
	fi

	echo -ne $x >/dev/stderr
	if [ "$VOICE_ENABLED" == true ]; then
		if [ "$x" == "-" ]; then
			gtts_speak "negative"
		elif [ "$x" == "." ]; then
			gtts_speak "point"
		else
			gtts_speak " $x"
		fi
	fi


	if [ "$x" != "" ]; then
		line="$x"
	fi

	read -n1 x
	while [ ! -z $x ]; do
		if [ "$x" == "" ]; then
			unset IFS
			return
		fi
		if [ "$x" == "" ]; then
			if [ "`echo $line | wc -c`" -lt "2" ]; then
				read -n1 x
				continue
			fi
			line="`echo $line | rev | cut -c2- | rev`"
			echo -ne "\b \b" >/dev/stderr
			read -n1 x
			continue
		elif [ "$x" == "" ]; then
			echo -n $line
			unset IFS
			return
		else
			line="$line$x"
		fi

		echo -ne "$x" >/dev/stderr
		if [ "$VOICE_ENABLED" == true ]; then
			if [ "$x" == "-" ]; then
				gtts_speak "negative"
			elif [ "$x" == "." ]; then
				gtts_speak "point"
			else
				gtts_speak " $x"
			fi
		fi
		read -n1 x
	done

	unset IFS
	echo -n "$line"
}

read_number() {
	stty -echo
	number="0"
	echo -ne "$number" >/dev/stderr
	read -n1 x
	if [ "$x" == "" ]; then
		return
	fi
	while [ ! -z "$x" ]; do
		if [ "$x" == "j" ]; then
			if [ "$number" -gt "-12" ]; then
				for i in `seq 1 ${#number}`; do
					echo -ne "\b" >/dev/stderr
					tput el >/dev/stderr
				done
				number="$(($number-1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "k" ]; then
			if [ "$number" -lt "12" ]; then
				for i in `seq 1 ${#number}`; do
					echo -ne "\b" >/dev/stderr
					tput el >/dev/stderr
				done
				number="$(($number+1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "-" ]; then
			for i in `seq 1 ${#number}`; do
				echo -ne "\b" >/dev/stderr
				tput el >/dev/stderr
			done
			echo -ne $x >/dev/stderr
			if [ "$VOICE_ENABLED" == true ]; then
				gtts_speak " $x"
			fi
			tmp="`read_line`"
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$tmp" == "" ]; then
				echo -ne ""
				return
			fi
			if [ "`isnum \"$tmp\"`" != "0" ]; then
				echo -ne "-$tmp"
				return
			fi
		elif [ "`isnum \"$x\"`" != "0" ]; then
			for i in `seq 1 ${#number}`; do
				echo -ne "\b" >/dev/stderr
				tput el >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			gtts_speak " $x"
			tmp=""
			if [ "$tmp" == "" ]; then
				echo -ne "$x"
				return
			elif [ "`isnum \"$tmp\"`" != "0" ]; then
				echo -ne "$x$tmp"
				return
			fi
		elif [ "$x" == "" ]; then
			echo -e ""
			return
		elif [ "$x" == "q" ]; then
			echo -e ""
			return
		elif [ "$x" == "" ]; then
			break
		fi
		read -rsn1 x
	done
	echo -ne "$number"
	return
}

reset_dimensions() {
	local norender=$1
	if [ "$LINES" != "$old_LINES" ] || [ "$COLUMNS" != "$old_COLUMNS" ]; then
		DIMENSIONS_RESET=true
	fi
	if [ "$norender" == "false" ] || [ "$norender" == "" ]; then
		render_help_screen
		render_voice_settings_screen
		render_repeat_help_screen
		render_scale_help_screen
	fi
}

redraw_screen() {
	reset_buffer

	if [ "$2" == "" ]; then
		draw_volume
		draw_equalizer
		draw_pitch
		draw_position
	else
		if [ "$2" == "1" ]; then
			draw_volume
		fi
		if [ "$3" == "1" ]; then
			draw_equalizer
		fi
		if [ "$4" == "1" ]; then
			draw_pitch
		fi
		if [ "$5" == "1" ]; then
			draw_position
		fi
	fi

	redraw_buffer
	tput cup 1
	tput el
	tput cup $(($LINES-2))
	tput el
}

reset_buffer() {
	number_per_page="$(($LINES-4))"
	original_number_per_page="$number_per_page"

	BUFFER=""
	UNCOLORED_BUFFER=""

	HALF="$(($POSITION % $number_per_page + $(($number_per_page/2 + 1))))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		HALF="1"
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
		number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$(($number_per_page*2 - 1))" ]; then
		HALF="$(($POSITION-$original_number_per_page/2))"
	fi

	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
		number_per_page="$TOTAL_QUEUE"
		FLAGGED=true
	fi

	half_page="$(($number_per_page/2))"

	if [ "$POSITION" -gt "$half_page" ]; then
		if [ "$(($number_per_page % 2))" != "" ]; then
			HALF=$((($POSITION - ($half_page))))
		else
			HALF=$((1+($POSITION - ($half_page))))
		fi

		if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
		fi
	fi

	HALF_OFFSET="0"
	if [ "$HALF" -lt "1" ]; then
		HALF_OFFSET="$(($HALF*-1)) - 1"
		HALF="1"
	fi

	pos_on_page=0
	_last=$(($HALF+($number_per_page)-$HALF_OFFSET))
	diff=$(($_last-$HALF))
	if [ "$TOTAL_QUEUE" -lt "$diff" ]; then
		diff="$TOTAL_QUEUE"
	fi

	for i in `seq 1 $diff`; do
		line="`echo -ne \"${queue_array[$(($i+$HALF-2))]}\"`"
		new_line="$line"
		pos=$(($i-1+$HALF))
		orig_line="$line"
		# Too slow. Needs an option to cache all at once
		USE_ID_TAGS=0
		line="`echo \"$line\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"

		if [ "`echo -ne \"$line\" | grep --text \" - \"`" != "" ]; then
			artist="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
			song="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"
			line="$artist - $song"
		fi

		if [ "$pos" == "$POSITION" ]; then
			REPLACE="$BLUE_BLACK"
		else
			REPLACE=""
		fi

		ext="`echo -ne \"$orig_line\" | rev | cut -d'.' -f1 | rev`"
		filename_without_ext="`echo -ne \"$orig_line\" | rev | cut -d'.' -f2- | rev`"

		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			REP="$BLUE"
		else
			REP=""
		fi

		if [ -e "$orig_line.locked" ]; then
			if [ -e "$orig_line.repeats" ]; then
				
				INDICATOR="${WHITE}$REP#"
			else
				INDICATOR="${WHITE}$"
			fi
		else
			if [ -e "$orig_line.repeats" ]; then
				INDICATOR="${WHITE}$REP&"
			else
				INDICATOR="${BLUE} "
			fi
		fi
		
		if [ "$pos" -lt "10" ] && [ "$TOTAL_QUEUE" -gt "9" ]; then
			pad="0"
			display_pad=" "
		else
			pad=""
			display_pad=""
		fi

		pos_on_page=$(($pos_on_page+1))
		
		if [ "$pos" == "$POSITION" ]; then
			offset="$(($COLUMNS - 11 - ${#pos} - ${#pad}))"
		else
			offset="$(($COLUMNS - 5 - ${#pos} - ${#pad}))"
		fi
		if [ "${#line}" -gt "$offset" ]; then
			line="$(echo -ne "$line" | sed -e 's/^ .*//g' | cut -b 1-$(($offset-1)))…"
		fi
		if [ "`echo -ne \"$line\" | grep --text \" - \"`" != "" ]; then
			first_part="`echo -ne \"$line\" | sed \"s/ - //\" | cut -d'' -f1`"
			second_part="`echo -ne \"$line\" | sed \"s/ - //\" | cut -d'' -f2`"
			combined=false
		else
			combined=true
		fi

		if [ "$combined" == false ]; then
			line="$first_part - $second_part"
		fi

		if [ "$pos" == "$POSITION" ]; then
			SONG_LENGTH="$(ffprobe -i "$new_line" -show_entries format=duration -v quiet -of csv="p=0" | cut -d'.' -f1)"
			if [ "$SONG_LENGTH" == "" ]; then
				SONG_LENGTH="--:--"
			else
				SONG_LENGTH="`date -u -d @$SONG_LENGTH +%H:%M:%S`"
			fi
			IFS=':' read hours minutes seconds <<< "$SONG_LENGTH"
			if [ "$hours" != "00" ]; then
				buf_space="`printf '%*s' $(($COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-8))`"
				APPEND_BLACK="${BLUE_BLACK}$hours${WHITE_BLACK}:${BLUE_BLACK}"
				APPEND="${BLUE}$hours${WHITE}:$BLUE"
			else
				buf_space="`printf '%*s' $(($COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-5))`"
				APPEND=""
				APPEND_BLACK=""
			fi
		else
			buf_space="`printf '%*s' $(($COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3))`"
		fi
		if [ "$PANELS_ENABLED" == true ] && [ "$pos" == "$POSITION" ]; then
			BUFFER="$BUFFER$BLUE_BLACK$PADDING$INDICATOR $display_pad$BLUE_BLACK$pos $line$buf_space$APPEND_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING`tput sgr0`\n"
			LOCKING_POS="$(($i-1))"
		else
			if [ "$PANELS_ENABLED" == false ]; then
				if [ "$pos" == "$POSITION" ]; then
					BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $BLUE$display_pad$BLUE$pos $line$buf_space$APPEND$BLUE$minutes$WHITE:$BLUE$seconds$PADDING\n"
					LOCKING_POS="$(($i-1))"
					UNCOLORED_BUFFER="$UNCOLORED_BUFFER$PADDING$INDICATOR $display_pad$pos $line$minutes:$seconds$PADDING\n"
				else
					BUFFER="$BUFFER$PADDING$WHITE$INDICATOR $BLUE$display_pad$BLUE$pos $WHITE$line$buf_space$PADDING\n"
					UNCOLORED_BUFFER="$UNCOLORED_BUFFER$PADDING$INDICATOR $display_pad$pos $line$buf_space$PADDING\n"
				fi
			else
				BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $display_pad$BLUE$pos $WHITE$line$buf_space$PADDING\n"
				UNCOLORED_BUFFER="$BUFFER$PADDING$INDICATOR $display_pad$pos $line$buf_space$PADDING\n"
			fi
		fi
	done
}


cleanup_sigint() {
	killall espeak-ng play >/dev/null 2>/dev/null
	if [ "$WEB_CLIENT" == "1" ]; then
		killall node >/dev/null 2>/dev/null
	fi
	kill $MPLAYER_PID >/dev/null 2>/dev/null

	if [ "$WEB_CLIENT" == "1" ]; then
		echo -ne "" >"$ALETHEIA/current_song"
	fi
	echo -ne "$NOCOLOR"
	clear
	tput cnorm
	stty echo
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	exit 0
}

cleanup() {
	killall espeak-ng node play >/dev/null 2>/dev/null

	tmp_volume_left="`echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1`"
	tmp_volume_right="`echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1`"
	if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
		#amixer sset Master $SYSTEM_VOLUME_LEFT,$SYSTEM_VOLUME_LEFT >/dev/null 2>/dev/null
		pactl set-sink-volume @DEFAULT_SINK@ $SYSTEM_VOLUME_LEFT >/dev/null 2>/dev/null
	elif [ "$tmp_volume_left" -lt "$tmp_volume_right" ]; then
		#amixer sset Master $SYSTEM_VOLUME_RIGHT,$SYSTEM_VOLUME_RIGHT >/dev/null 2>/dev/null
		pactl set-sink-volume @DEFAULT_SINK@ $SYSTEM_VOLUME_RIGHT >/dev/null 2>/dev/null
	fi
	echo -ne "" >"$ALETHEIA/current_song"
	echo -ne "$NOCOLOR"
	tput cnorm
	stty ixon
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	kill $MPLAYER_PID 2>/dev/null >/dev/null
	exit 0
}

redraw_buffer() {
	echo -ne "$NOCOLOR"
	tput cup 1
	tput el
	tput cup $(($LINES-2))
	tput el
	tput cup 2
	echo -ne "$BUFFER"

	if [ "$number_per_page" -lt "$TOTAL_QUEUE" ]; then
		number_per_page=$TOTAL_QUEUE
	fi

	if [ "$(($COLUMNS-$TOTAL_QUEUE-4))" -gt "0" ]; then
		empty_pane $((2+$TOTAL_QUEUE))
	fi

	tput cup $(($LINES-2))
}

empty_pane() {
	tput civis
	lineno=$1
	pane="$(($LINES-2))"

	if [ "$lineno" == "" ]; then
		lineno="1"
	fi

	tput sgr0
	while [ "$lineno" -le "$pane" ]; do
		tput cup $lineno
		tput el
		lineno="$(($lineno+1))"
	done
	tput cup 1
	tput el
	tput cup $(($LINES-2))
	tput el
}

draw_volume() {
	tput cup 0

	tmp_volume_left=${SYSTEM_VOLUME_LEFT%\%}
	tmp_volume_right=${SYSTEM_VOLUME_RIGHT%\%}
	if [ "$tmp_volume_left" == "" ]; then
		tmp_volume_left="0"
		tmp_volume_right="0"
	fi
	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	echo -ne "$BLUE_BLACK$PADDING$VOLUME$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_left$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_right"
	printf '%*s' $(($COLUMNS - (${#CORNER_DIVIDER}*2) - ${#equal} -${#VOLUME} - (${#PADDING}*2) - ${#tmp_volume_left} - ${#tmp_volume_right}))
	echo -ne "$NOCOLOR"
}

draw_position() {
	local equalizer=$1
	RIGHT_BANNER_WIDTH=0
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
	tput cup $LINES $(($COLUMNS-${#POSITION} - ${#TOTAL_QUEUE} - 1 - (${#CORNER_DIVIDER}*2) - ${#PADDING}))
	if [ "$LOOP" == true ]; then
		center="1"
	elif [ "$LOOP_ARTIST" == true ]; then
		center="2"
	elif [ "$TRACK_RANDOM" == true ]; then
		center="3"
	elif [ "$ONLY_LOCKED" == true ]; then
		center="4"
	else
		center="0"
	fi
	echo -ne "$BLUE_BLACK$POSITION$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$TOTAL_QUEUE$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$center$PADDING$NOCOLOR"
	return
}

yt_artist() {
	which yt_artist >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "artist" yt_artist "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`" 1
		else
			tmux new-session -s "artist" yt_artist "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`" 0
		fi
		tput civis
		gtts_speak "closed" true
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

yt_search() {
	which yt_search >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "search" yt_search 1 "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		else
			tmux new-session -s "search" yt_search 0 "`echo \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		fi
		gtts_speak "closed" true
		tput civis
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

tmux_attach() {
	which yt_search >/dev/null 2>/dev/null
	if [ "$?" == "0" ]; then
		# FIXME
		gtts_speak "attached"
		tmux attach >/dev/null 2>/dev/null
		tput civis
		gtts_speak "closed" true
		draw_pitch
		draw_position
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

toggle_panels() {
	if [ "$PANELS_ENABLED" == true ]; then
		gtts_speak "panels disabled"
		PANELS_ENABLED=false
		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37m'
			BLUE_BLACK='\033[1;37m'
			RED_BLACK='\033[1;37m'
			CYAN_BLACK='\033[1;37m'
			WHITE_BLACK='\033[1;37m'
		else
			GREEN_BLACK='\033[1;32m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			#BLUE_BLACK=$ORIG_BLUE_BLACK
			#WHITE_BLACK=$ORIG_WHITE_BLACK
			BLUE_BLACK="${BLUE}"
			WHITE_BLACK="${WHITE}"
		fi
	else
		gtts_speak "panels enabled"
		PANELS_ENABLED=true
		if [ "$COLORS_ENABLED" == false ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			color="${COLOR_PANEL#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))
			BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
		fi
	fi
	reset_buffer
	draw_volume
	draw_equalizer
	if [ "$1" == true ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
}

toggle_colors() {
	draw_wait
	if [ "$COLORS_ENABLED" == false ]; then
		COLORS_ENABLED=true
		BLUE=$orig_blue
		RED='\033[1;31m'
		LIGHTRED='\033[0;31m'
		GREEN='\033[1;32m'
		#BLUE='\033[1;34m'
		YELLOW='\033[1;33m'
		LIGHTBLUE='\033[1;34m'
		PURPLE='\033[1;35m'
		CYAN='\033[1;36m'
		LIGHTCYAN='\033[0;36m'
		LIGHTRED='\033[0;31m'
		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;32;1;40m'
			BLUE_BLACK='\033[1;34;1;40m'
			RED_BLACK='\033[1;31;1;40m'
			CYAN_BLACK='\033[1;36;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;32m'
			BLUE_BLACK='\033[1;34m'
			RED_BLACK='\033[1;31m'
			CYAN_BLACK='\033[1;36m'
			WHITE_BLACK='\033[1;37m'
		fi
	else
		orig_blue_black=$BLUE_BLACK
		orig_white_black=$WHITE_BLACK
		orig
		COLORS_ENABLED=false
		if [ "$PANELS_ENABLED" == true ]; then
			GREEN_BLACK='\033[1;37;1;40m'
			BLUE_BLACK='\033[1;37;1;40m'
			RED_BLACK='\033[1;37;1;40m'
			CYAN_BLACK='\033[1;37;1;40m'
			WHITE_BLACK='\033[1;37;1;40m'
		else
			GREEN_BLACK='\033[1;37m'
			BLUE_BLACK='\033[1;37m'
			RED_BLACK='\033[1;37m'
			CYAN_BLACK='\033[1;37m'
			WHITE_BLACK='\033[1;37m'
		fi
		RED='\033[1;37m'
		LIGHTRED='\033[0;37m'
		GREEN='\033[1;37m'
		BLUE='\033[1;37m'
		YELLOW='\033[1;37m'
		LIGHTBLUE='\033[1;37m'
		PURPLE='\033[1;37m'
		CYAN='\033[1;37m'
	fi
	if [ "$DARK_BACKGROUND" == true ]; then
		WHITE='\033[1;37m'
		LIGHTWHITE='\033[1;37m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;37;1;40m'
		else
			WHITE_BLACK='\033[1;37m'
		fi
	else
		WHITE='\033[1;30m'
		LIGHTWHITE='\033[1;30m'
		if [ "$PANELS_ENABLED" == true ]; then
			WHITE_BLACK='\033[1;30;1;40m'
		else
			WHITE_BLACK='\033[1;30m'
		fi
	fi

	if [ "$COLORS_ENABLED" == true ]; then
		WHITE=$orig_white
	fi
	render_help_screen
	render_voice_settings_screen
	render_repeat_help_screen
	render_scale_help_screen
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	if [ "$COLORS_ENABLED" == false ]; then
		gtts_speak "color disabled"
	else
		gtts_speak "color enabled"
	fi
}

invert_colors() {
	local orig_blue=$BLUE
	local orig_blue_black=$BLUE_BLACK
	BLUE=$WHITE
	WHITE=$orig_blue
	BLUE_BLACK=$WHITE_BLACK
	WHITE_BLACK=$orig_blue_black
	draw_wait
	render_help_screen
	render_voice_settings_screen
	render_repeat_help_screen
	render_scale_help_screen
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	gtts_speak "color inverted"
}

draw_wait() {
	if [ "$1" == "" ] || [ "$1" == false ]; then
		echo -ne "$NOCOLOR"
		clear
	fi
	tput cup $(($LINES/2)) $((($COLUMNS/2)-5))
	echo -ne "$NOCOLOR${WHITE}-- ${BLUE}WAIT ${WHITE}--$NOCOLOR"
	gtts_speak "wait" false true
}

web_client_func() {
	if [ "$WEB_CLIENT" == "1" ]; then
		number_per_page="4"
		original_number_per_page="$number_per_page"

		BUFFER=""

		HALF="$(($POSITION % $number_per_page + $(($number_per_page/2 + 1))))"

		if [ "$POSITION" -lt "$number_per_page" ]; then
			HALF="1"
		elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
			number_per_page="$original_number_per_page"
		elif [ "$POSITION" -gt "$(($number_per_page*2 - 1))" ]; then
			HALF="$(($POSITION-$original_number_per_page/2))"
		fi

		if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi

		half_page="$(($number_per_page/2))"

		if [ "$POSITION" -gt "$half_page" ]; then
			if [ "$(($number_per_page % 2))" != "" ]; then
				HALF=$((($POSITION - ($half_page))))
			else
				HALF=$((1+($POSITION - ($half_page))))
			fi

			if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
			fi
		fi

		HALF_OFFSET="0"
		if [ "$HALF" -lt "1" ]; then
			HALF_OFFSET="$(($HALF*-1)) - 1"
			HALF="1"
		fi

		COLOR2="$BLUE"

		pos_on_page=0
		_last=$(($HALF+($number_per_page)-$HALF_OFFSET))
		if [ "$(($_last-$HALF))" -lt "5" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			if [ "$POSITION" == "$TOTAL_QUEUE" ] || [ "$POSITION" == "$(($TOTAL_QUEUE-1))" ]; then
				HALF=$(($_last-5))
			fi
		fi
		if [ "$HALF" == "1" ]; then
			HALF=2
			_last=$((${_last}+1))
		fi
		lines="`printf '%s\n' \"${queue_array[@]}\" | sed -n \"$(($HALF-1)),$((${_last}-1))p\"`"
		diff=$(($_last-$HALF))
		if [ "$POSITION" -lt "3" ]; then
			pos=$POSITION
		else
			pos=2
		fi
		echo -ne "$lines" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/\n/<br\/>/g" >"$ALETHEIA/current_queue"
		if [ "$POSITION" -lt "3" ]; then
			pos=$(($pos-1))
		elif [ "$POSITION" -gt "$(($TOTAL_QUEUE-1))" ]; then
			pos=$(($pos+1))
		fi
		if [ "$POSITION" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=4
		elif [ "$POSITION" == "$(($TOTAL_QUEUE-1))" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=3
		fi
		echo -ne "$pos" >"$ALETHEIA/current_pos"
	fi
}

say_locked_and_loops() {
	while [ true ]; do
		ps -p $PLAY_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "locked" true
	gtts_speak "$INTERVAL" true
	gtts_speak "`echo -ne \"$REPEATS\" | wc -l`" true
	gtts_speak "loops" true 
}

say_unlocked_and_loops() {
	while [ true ]; do
		ps -p $PLAY_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "unlocked" true
	gtts_speak "`echo -ne \"$REPEATS\" | wc -l`" true
	gtts_speak "loops" true 
}

say_locked_and_no_loops() {
	while [ true ]; do
		ps -p $PLAY_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "locked" true
	gtts_speak "`echo -ne \"$INTERVAL\" | sed \"s/\-/negative /g\"`" true
	gtts_speak "$EDO"
	gtts_speak "no loops" true
}

say_unlocked_and_no_loops() {
	while [ true ]; do
		ps -p $PLAY_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "unlocked" true
	gtts_speak "no loops" true 
}

jump_to_first_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="`printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | head -1 | cut -d':' -f1`"
	kill $MPLAYER_PID >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

jump_to_last_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="`printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | tail -1 | cut -d':' -f1`"
	kill $MPLAYER_PID >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

load_only_loops() {
	if [ "$LOOPS_ONLY" == false ] || [ "$1" == true ]; then
		draw_banner "WAIT"
		if [ "$ONLY_LOCKED" == true ]; then
			gtts_speak "only locked loops"
		else
			gtts_speak "loops" true
		fi
		artist="`echo -ne \"$TITLE\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
		if [ "$LOOP_ARTIST" == true ]; then
			if [ "`find \"$MUSICDIR\" | grep -e \"^$artist - \" | grep -e \"\.repeats$\"`" == "" ]; then
				LOOP_ARTIST=false
			fi
		fi
		if [ "$ONLY_LOCKED" == true ]; then
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $(find "$MUSICDIR" \( -iname "*.mp3.locked" -o -iname "*.flac.locked" \) -and -not -iname "*.repeat.*" | sort); do
				var1="`echo -ne \"$i\" | rev | cut -d'.' -f2- | rev`"
				if [ -e "$var1.repeats" ]; then
					queue_array[$index]="$var1"
					index=$(($index+1))
				fi
			done
			unset IFS
			new_QBUF=""
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in `find "$MUSICDIR" -iname "*\.repeats" | shuf | sed -e "s/\.repeats$//g"`; do
				if [ -e "$i" ]; then
					queue_array[$index]="$i"
					index=$(($index+1))
				fi
			done
			unset IFS
		fi
		SHUFFLED=true
		TOTAL_QUEUE="$index"
		tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1 | head -1`"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		#reset_buffer
		#redraw_buffer
		#draw_pitch
		#draw_position
	else
		draw_banner "WAIT"
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		SHUFFLED=true
		TOTAL_QUEUE=$index
		tmp="`printf '%s\n' "${queue_array[@]}" | grep -n \"$FILENAME$\" | cut -d':' -f1`"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		reset_buffer
		redraw_buffer
	fi
}

process_key() {
	case "$1" in
	'[')
		system_volume_change "-1% -0%"
		;;
	']')
		system_volume_change "-0% -1%"
		;;
	'{')
		system_volume_change "+1% +0%"
		;;
	'}')
		system_volume_change "+0% +1%"
		;;
	esac
}

generate_random_color() {
	printf "#%02x%02x%02x\n" $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

generate_light_random_color() {
	while true; do
		color=$(printf "#%02x%02x%02x\n" $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)))
		IFS=";" read _ _ _ red green blue <<<"$color"
		local r=$(hex_to_decimal "$red")
		local g=$(hex_to_decimal "$green")
		local b=$(hex_to_decimal "${blue%m}")

		if [ "$r" -lt 164 ] || [ "$g" -lt 164 ] || [ "b" -lt 164 ]; then
			continue
		else
			printf "#%02x%02x%02x\n" $r $g $b
			return
		fi
	done
}

generate_dark_random_color() {
	printf "#%02x%02x%02x" $((RANDOM%64)) $((RANDOM%64)) $((RANDOM%64))
}

hex_to_decimal() {
	local hex=$1
	echo "ibase=16; $hex" | bc
}

generate_complementary_color() {
	local color=$1
	IFS=";" read _ _ _ red green blue <<<"$BLUE"
	local r=$(hex_to_decimal "$red")
	local g=$(hex_to_decimal "$green")
	local b=$(hex_to_decimal "${blue%m}")

	local comp_r=$((255 - $r))
	local comp_g=$((255 - $g))
	local comp_b=$((255 - $b))

	printf "#%02x%02x%02x\n" $comp_r $comp_g $comp_b
}

load_loop_file() {
	if [ "$LOOP_ON" == false ]; then
		LOOP_ON=true
		ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
		filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			echo "volume 0 1" >"$ALETHEIA/pipe$$" &
			draw_banner "LOOP ON"
			gtts_speak "loading loop"
			sleep $MPLAYER_WAIT_TIME
			if [ -e "$filename_without_ext.repeat.$ext.repeats" ]; then
				REPEATS="$(cat "$filename_without_ext.repeat.$ext.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$filename_without_ext.repeat.$ext.locked" ]; then
				read_locked_file "$(cat "$filename_without_ext.repeat.$ext.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			fi
			sleep 0.05
			echo -e "loadfile '$filename_without_ext.repeat.$ext'" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_pitch
			draw_position
		else
			LOOP_ON=false
			return 1
		fi
	else
		LOOP_ON=false
		if [ -e "$FILENAME" ]; then
			echo "volume 0 1" >"$ALETHEIA/pipe$$" &
			draw_banner "LOOP OFF" 
			gtts_speak "loop disabled"
			if [ -e "$FILENAME.repeats" ]; then
				REPEATS="$(cat "$FILENAME.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$FILENAME.locked" ]; then
				read_locked_file "$(cat "$FILENAME.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			fi
			sleep 0.05
			echo -e "loadfile \"$FILENAME\"" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
			LOOP=false
			draw_pitch
			draw_position
		fi
	fi
}

invert_int() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	INTERVAL="$((-($INTERVAL)))"
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	espeak_say " $INTERVAL $EDO"
	VOICE_ENABLED=false
	ONLY_VOICE_TITLES=false
	draw_pitch
}

draw_pitch() {
	if [ "$PAUSE" == true ]; then
		draw_banner "PAUSE"
		return
	elif [ "$MUTE" == true ]; then
		draw_banner "MUTE"
		return
	fi

	tput cup $LINES

	if [ "$SCALETEMPO" == true ]; then
		if [ "$ONLY_PITCH" == true ]; then
			toggle=2
		else
			toggle=1
		fi
	else
		toggle=0
	fi

	echo -ne "$BLUE_BLACK$PADDING$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$toggle"

	POSITION_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))"
	if [ "$POSITION_WIDTH" -lt "$RIGHT_BANNER_WIDTH" ]; then
		printf '%*s' $(($COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - $RIGHT_BANNER_WIDTH))
	else
		printf '%*s' $(($COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - $POSITION_WIDTH))
	fi
	echo -ne "$NOCOLOR"
}

draw_equalizer() {
	stty -echo
	equal1="`echo $EQUALIZER | cut -d':' -f1`"
	equal2="`echo $EQUALIZER | cut -d':' -f4`"
	equal3="`echo $EQUALIZER | cut -d':' -f8`"
	equal="`echo $EQUALIZER | cut -d':' -f1`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"
	tput cup 0 $(($COLUMNS-${#equal1}-${#equal2}-${#equal3}-(${#CORNER_DIVIDER}*2)-${#PADDING}))
	echo -ne "$BLUE_BLACK$equal1$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$equal2$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$equal3$PADDING$NOCOLOR"
}

toggle_voice() {
	if [ "$VOICE_ENABLED" == false ]; then
		VOICE_ENABLED=true
		if [ "$2" == false ] || [ "$2" == "" ]; then
			gtts_speak "on" false true
		fi
	else
		if [ "$2" == false ] || [ "$2" == "" ]; then
			if [ "$ONLY_VOICE_TITLES" == true ]; then
				gtts_speak "voice only titles, off" false true
			else
				gtts_speak "off" false true
			fi
		fi
		VOICE_ENABLED=false
		ONLY_VOICE_TITLES=false
	fi
	draw_banner "$3"
}

queue_help_screen() {
	gtts_speak "queue controls"
	local flagged=false
	original_number_per_page="$number_per_page"
	number_per_page="$(($LINES-4))"

	FLAGGED=false
	if [ "$QUEUE_HELP_LENGTH" -le "$number_per_page" ]; then
		number_per_page="$QUEUE_HELP_LENGTH"
		FLAGGED=true
	fi

	pos=1
	while [ "$pos" -le "$QUEUE_HELP_LENGTH" ]; do
		buf=""
		tput cup 0
		if [ "$(($QUEUE_HELP_LENGTH-$pos))" -lt $number_per_page ]; then
			number_per_page=$(($QUEUE_HELP_LENGTH-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
			return
		fi
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$QUEUE_HELP\" | sed -n ${i}p`"
			if [ "`echo \"$line\" | cut -b2`" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
			else
				tmp1="$BLUE `echo \"$line\" | cut -b1`"
				tmp2="$WHITE`echo \"$line\" | cut -d' ' -f2-`"
			fi

			buf="$buf$PADDING$tmp1 $tmp2`tput el`\n"
		done
		draw_banner "CONTROLS" false true

		tput cup 2
		echo -ne "$NOCOLOR$buf"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page + 2))"
		fi

		read -rsn1 inputchar
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
				pos="$(($QUEUE_HELP_LENGTH-$number_per_page-1))"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$inputchar" == "d" ]; then
			echo -e "$QUEUE_HELP" | sed -n "$pos,$(($pos+$number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -v en-us+m1 -k 2 & >/dev/null 2>/dev/null
		else
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			draw_pitch
			draw_position
			redraw_buffer
			empty_pane $(($number_per_page+2))
			return
		fi
	done
}

scale_help_screen() {
	gtts_speak "scale controls"
	draw_banner "HELP" false true
	local initial_screen=$1

	width="$(echo -ne "$SCALE_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$((($width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#SCALE_HELP_BUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page

		tput cup 2
		echo -ne "$NOCOLOR${SCALE_HELP_BUFFER[$page]}"

		helpbuflines=`echo -ne \"${SCALE_HELP_BUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			else
				_first=$((($page*$number_per_page*2)+1))
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page)+$number_per_page))
			else
				_first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$(($page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
				page=$(($page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			killall espeak-ng play >/dev/null 2>/dev/null
			echo "$SCALE_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/|/vertical slash/g" | sed "s/?/question mark/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed "s/-/ /g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 & >/dev/null 2>/dev/null
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "SCALE"
			draw_banner "HELP" false true
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			#draw_pitch
			#draw_position
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

add_downloaded() {
	IFS=$'\n'
	index=0
	list=`find "$MUSICDIR" -cnewer $SCRIPT_PATH -iname "*.mp3" -o -cnewer $SCRIPT_PATH -iname "*.flac"`
	if [ "$list" != "" ]; then
		for i in $list; do
			queue_array[$(($index+$TOTAL_QUEUE))]="$i"
			index=$(($index+1))
		done
		unset IFS
		DOWNLOAD_POSITION="$(($TOTAL_QUEUE+1))"
		TOTAL_QUEUE="$(($index+$TOTAL_QUEUE))"
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "queued downloads"
		fi
		if [ "$1" != "noposition" ]; then
			draw_position
		fi
		reset_buffer
		redraw_buffer
	else
		unset IFS
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "nothing downloaded"
			draw_banner "NONE"
		fi
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
	fi
	touch -m $SCRIPT_PATH
}

say_status() {
	draw_banner "STATUS" false false true
	gtts_speak "which corner?"
	read -n1 x
	if [ "$x" == "u" ]; then
		tmp="`echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1`"
		tmp2="`echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1`"
		tmp3="`echo $VOLUME | cut -d'%' -f1`"
		gtts_speak "$tmp3" true
		gtts_speak "$tmp" true
		gtts_speak "$tmp2" true
	elif [ "$x" == "i" ]; then
			res="`echo -ne \"$equal\" | sed -e \"s/:/, /g\"`"
			if [ "$res" == "0, 0, 0" ]; then
				gtts_speak "0" true
				gtts_speak "0" true
				gtts_speak "0" true
			else
				gtts_speak " $bass" true
				gtts_speak " $mid" true
				gtts_speak " $treble" true
			fi
	elif [ "$x" == "j" ]; then
			if [ "$LOCKED" == true ]; then 
				tmp_int="`cat \"$FILENAME.locked\" | cut -d'/' -f1`"
				gtts_speak "$INTERVAL" true
				gtts_speak "$EDO" true
				gtts_speak "locked" true
				gtts_speak "$tmp_int" true
				if [ "$SCALETEMPO" == true ]; then
					gtts_speak "tempo" true
				fi
			else
				gtts_speak "$INTERVAL" true
				gtts_speak "$EDO" true
				if [ "$SCALETEMPO" == true ]; then
					gtts_speak "tempo" true
				fi
			fi
	elif [ "$x" == "k" ]; then
		gtts_speak "$POSITION" true
		gtts_speak "of" true
		gtts_speak "$TOTAL_QUEUE" true
		if [ "$LOOP" == true ]; then
			gtts_speak "loop enabled" true
		elif [ "$LOOP_ARTIST" == true ]; then
			gtts_speak "playing" true
			gtts_speak "$TITLE" true
		elif [ "$RANDOM_MODE" == true ]; then
			gtts_speak "random mode" true
		elif [ "$ONLY_LOCKED" == true ]; then
			gtts_speak "only locked" true
		fi
			
	elif [ "$x" == "I" ]; then
		gtts_speak "closed" true
	fi
	draw_pitch
}

sort_queue() {
	gtts_speak "sorted"

	IFS=$'\n'
	queue_array=($(sort <<<"${queue_array[*]}"))	
	
	unset IFS
	#escaped_filename=$(printf '%s\n' "$FILENAME" | tr -cd "[:alnum:]._\-,()[]\!\"\'\&\/ ")
	tmp=$(printf '%s\n' "${queue_array[@]}" | grep --text -n "$FILENAME" | cut -d':' -f1 | head -1)

	POSITION="$tmp"
	web_client_func

	reset_buffer
	redraw_buffer
}

shuffle_queue() {
	gtts_speak "shuffled"

	IFS=$'\n'
	#escaped_filename=$(printf '%s\n' "$FILENAME" | tr -cd "[:alnum:]._\-,()[]\!\"\'\&\/ ")
	queue_array=("$FILENAME" $(shuf <<<"${queue_array[*]}" | grep --text -v "$FILENAME"))	
	unset IFS

	POSITION=1
	TRACK_RANDOM=false
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))

	web_client_func
	reset_buffer
	redraw_buffer
}

render_voice_settings_screen() {
	render $(($VOICE_HELP_LENGTH+1)) "`echo -ne \"$VOICE_HELP\" | wc -L`" "$VOICE_HELP"
	VOICE_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

render_scale_help_screen() {
	render $(($SCALE_HELP_LENGTH+1)) "`echo -ne \"$SCALE_HELP\" | wc -L`" "$SCALE_HELP"
	SCALE_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

voice_settings_screen() {
	gtts_speak "voice settings"
	flagged=false

	width="$(echo -ne "$VOICE_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$((($width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#VOICE_HELP_BUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page
		draw_banner "VOICE"
		tput cup 2
		echo -ne "$NOCOLOR${VOICE_HELP_BUFFER[$page]}"

		helpbuflines=`echo -ne \"${VOICE_HELP_BUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$(($number_per_page*2))
			else
				first=$((($page*$number_per_page*2)+1))
				last=$((($page*number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$(($page+1))" -lt "${#VOICE_HELP_BUFFER[@]}" ]; then
				page=$(($page+1))
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
			fi
		elif [ "$inputchar" == "J" ]; then
			if [ "$VOICE_PITCH" -gt "-30" ]; then
				VOICE_PITCH="$(($VOICE_PITCH-1))"
			fi
			if [ ! -e "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" ]; then
				gtts-cli " $VOICE_PITCH" -o /tmp/voice-pitch${VOICE_PITCH}.mp3
				sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}" speed $(calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-)
				rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"
			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
			flagged=true
		elif [ "$inputchar" == "K" ]; then
			if [ "$VOICE_PITCH" -lt "30" ]; then
				VOICE_PITCH="$(($VOICE_PITCH+1))"
			fi
			if [ ! -e "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" ]; then
				gtts-cli " $VOICE_PITCH" -o /tmp/voice-pitch${VOICE_PITCH}.mp3
				sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" speed $(calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-)
				rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"

			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
			flagged=true
		elif [ "$inputchar" == "8" ]; then
			if [ "`echo -e \"$VOICE_VOLUME > 0.05\" | bc`" == "1" ]; then
				VOICE_VOLUME="`echo \"$VOICE_VOLUME-0.05\" | bc`"
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "9" ]; then
			if [ "`echo -e \"$VOICE_VOLUME < 1.0\" | bc`" == "1" ]; then
				VOICE_VOLUME="`echo \"$VOICE_VOLUME+0.05\" | bc`"
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "d" ]; then
			echo "$VOICE_HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/PCM/p,c,m/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -v en-us+m1 -k 2 & >/dev/null 2>/dev/null
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "VOICE"
			draw_position
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#VOICE_HELP_BUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$switchback" == true ]; then
					VOICE_ENABLED=false
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					redraw_screen
				else
					empty_pane
				fi
				return
				;;
			esac
		else
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$1" == true ]; then
				empty_pane
			fi
			if [ "$switchback" == true ]; then
				VOICE_ENABLED=false
			fi
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				redraw_screen
			fi
			return
		fi
	done
}

render() {
	TMP_BUFFER=()
	local length="$1"
	local width="$2"
	local text="$3"
	loading_chars=0
	number_per_page="$(($LINES-4))"
	original_number_per_page="$number_per_page"

	FLAGGED=false

	if [ "$length" -le "$number_per_page" ]; then
		number_per_page="$length"
		FLAGGED=true
	fi
	
	if [ "$COLUMNS" -ge "$((($width*2)+3))" ]; then
		if [ "$FLAGGED" == true ]; then
			TWO_COLUMN=false
			d=1
		else
			TWO_COLUMN=true
			d=2
		fi
	else
		TWO_COLUMN=false
		d=1
	fi

	pos=1
	while [ "$pos" -lt "$length" ]; do
		buf=""
		if [ "$(($length-$pos))" -lt $number_per_page ]; then
			number_per_page=$(($length-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$length" ]; then
			return
		fi
		x=0
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$text\" | sed -n ${i}p`"
			if [ "$TWO_COLUMN" == false ]; then
				pmt_line=""
			else
				pmt_line="`echo -e \"$text\" | sed -n $(($i+$number_per_page))p`"
			fi
			if [ "`echo \"$line\" | cut -b3`" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""

				if [ "$TWO_COLUMN" == true ]; then
					if [ "$(($i+$number_per_page-2))" -lt "`echo -n \"$text\" | wc -l`" ]; then
						if [ "`echo \"$pmt_line\" | cut -b3`" != " " ]; then
							pmt1="$BLUE$pmt_line"
							pmt2=""
						else
							pmt1="$BLUE `echo \"$pmt_line\" | cut -b1-2`"
							pmt2="$WHITE`echo \"$pmt_line\" | cut -d' ' -f3-`"
							pmt_line=" $BLUE$pmt1 $WHITE$pmt2"
						fi
					else
						pmt_line=""
					fi
				else
					pmt_line=""
				fi
			else
				tmp1="$BLUE `echo \"$line\" | cut -b1-2`"
				tmp2="$WHITE`echo \"$line\" | cut -d' ' -f3-`"

				if [ "$TWO_COLUMN" == true ]; then
					if [ "$(($i+$number_per_page-2))" -lt "`echo -n \"$text\" | wc -l`" ]; then
						pmt1="$BLUE `echo \"$pmt_line\" | cut -b1-2`"
						pmt2="$WHITE`echo \"$pmt_line\" | cut -d' ' -f3-`"
					else
						pmt_line=""
					fi
				else
					pmt_line=""
				fi

				if [ "`echo \"$pmt_line\" | cut -b3`" != " " ]; then
					pmt1="$BLUE$pmt_line"
					pmt2=""
				fi

			fi

			if [ "$TWO_COLUMN" == true ]; then
				difference=$(( (($COLUMNS/2) - $width + 2) / 2))
			else
				difference=$(( (($COLUMNS - $width + 2) / 2 ) ))
			fi

			if [ "$pmt_line" != "" ] && [ "$line" != "" ]; then
				buf="$buf`printf '%*s' $difference`$tmp1 $tmp2`tput el``tput cup $(($x+2)) $((($COLUMNS/2+1)))``printf '%*s' $(($difference-1))`$pmt1 $pmt2`tput el`\n"
			else
				buf="$buf`printf '%*s' $difference`$tmp1 $tmp2`tput el`\n"
			fi

			x=$(($x+1))

		done

		TMP_BUFFER+=("$buf")

		if [ "$TWO_COLUMN" == false ]; then
			pos="$(($pos+$number_per_page))"
		else
			if [ "$(($pos+($number_per_page*2)))" -lt "$length" ]; then
				pos="$(($pos+($number_per_page*2)))"
			else
				return
			fi
		fi
	done
}

render_repeat_help_screen() {
	render $(($REPEAT_HELP_LENGTH+1)) "`echo -ne \"$REPEAT_HELP\" | wc -L`" "$REPEAT_HELP"
	REPEAT_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

loop_help_screen() {
	gtts_speak "loop controls"
	local initial_screen=$1

	width="$(echo -ne "$REPEAT_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$((($width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#REPEAT_HELP_BUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page

		tput cup 2
		echo -ne "$NOCOLOR${REPEAT_HELP_BUFFER[$page]}"

		helpbuflines=`echo -ne \"${REPEAT_HELP_BUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			else
				_first=$((($page*$number_per_page*2)+1))
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page)+$number_per_page))
			else
				_first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$(($page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
				page=$(($page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			killall espeak-ng play >/dev/null 2>/dev/null
			echo "$REPEAT_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/|/vertical slash/g" | sed "s/?/question mark/g" | sed "s/-/minus /g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 & >/dev/null 2>/dev/null
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "HELP" false false true
			tput cup $LINES $(($COLUMNS-12))
			echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

render_help_screen() {
	render $(($HELP_LENGTH+1)) "`echo -ne \"$HELP\" | wc -L`" "$HELP"
	tput rc
	HELP_BUFFER=("${TMP_BUFFER[@]}")
}

help_screen() {
	gtts_speak "key controls"
	local initial_screen=$1

	width="$(echo -ne "$HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$((($width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#HELP_BUFFER[@]}" ]; do
		number_per_page=$(($LINES-4))
		original_number_per_page=$number_per_page

		tput cup 0
		echo -ne "$BLUE_BLACK${PADDING}PCM${WHITE_BLACK}:${BLUE_BLACK}LEF${WHITE_BLACK}:${BLUE_BLACK}RIG"
		printf '%*s' $(($COLUMNS - 24))
		echo -ne "${BLUE_BLACK}BAS${WHITE_BLACK}:${BLUE_BLACK}MID${WHITE_BLACK}:${BLUE_BLACK}TRE$PADDING$NOCOLOR"

		tput cup $LINES
		echo -ne "${BLUE_BLACK}${PADDING}INT${WHITE_BLACK}:${BLUE_BLACK}EDO${WHITE_BLACK}:${BLUE_BLACK}TOG"
		printf '%*s' $(($COLUMNS - 24))
		echo -ne "${BLUE_BLACK}POS${WHITE_BLACK}:${BLUE_BLACK}QUE${WHITE_BLACK}:${BLUE_BLACK}TOG$PADDING$NOCOLOR"

		tput cup 2
		echo -ne "$NOCOLOR${HELP_BUFFER[$page]}"

		helpbuflines=`echo -ne \"${HELP_BUFFER[$page]}\" | wc -l`
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			empty_pane "$(($helpbuflines+2))"
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			else
				_first=$((($page*$number_per_page*2)+1))
				last=$((($page*$number_per_page*2)+($number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$((($page*$number_per_page)+$number_per_page))
			else
				_first=$((($page*$number_per_page)+1))
				last=$((($page*$number_per_page)+$number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$(($page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
				page=$(($page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$(($page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			killall espeak-ng play >/dev/null 2>/dev/null
			echo "$HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/-EDO/ EDO/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/'/single quote/g" | sed "s/\"/double quote/g" | sed "s/\./period/g" | sed "s/|/vertical slash/g" | sed "s/-[0-9]/minus &/g" | sed "s/\([a-zA-Z]\)\/\([a-zA-Z]\)/\1 or \2/g" | sed "s/?/question mark/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 & >/dev/null 2>/dev/null
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			page=0
			reset_dimensions
			empty_pane
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			killall play >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
			fi
			empty_pane
			return
		elif [ "$inputchar" == "m" ]; then
			man aletheia
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$(($page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
					page=$(($page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$(($page-1))
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				if [ "$initial_screen" == false ]; then
					draw_volume
					draw_equalizer
					draw_banner "MENU"
					draw_position
				fi
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

start_search() {
	draw_banner "SEARCH"
	draw_position
	tput rc
	echo -ne "$BLUE_BLACK"
	gtts_speak "search"
	if [ "$WEB_CLIENT" == "0" ]; then
		local jump="`read_line`"
	else
		read -t 0.1 jump <"$ALETHEIA/web_client_pipe$$"
		if [ "$jump" == "" ]; then
			local jump="`read_line`"
		fi
	fi
	if [ "$jump" != "" ]; then
		if [ "`isnum \"$jump\"`" != "0" ]; then
			jump="${jump#"${jump%%[!0]*}"}"
			if [ "$jump" -lt "1" ]; then
				redraw_buffer
			elif [ "$jump" -le "$TOTAL_QUEUE" ]; then
				if [ "$jump" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jump"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					redraw_buffer
					draw_pitch
					draw_position
				fi
			else
				redraw_buffer
				draw_pitch
				draw_position
			fi
		else
			if [ "$1" == true ]; then
				jump="$(echo -n "$jump" | iconv -f utf-8 -t ascii//TRANSLIT)"
				tmp=$(printf '%s\n' "${queue_array[@]}" | iconv -f utf-8 -t ascii//TRANSLIT | grep --text -ni "$jump" | head -1 | cut -d':' -f1)
				if [ "$tmp" != "" ]; then
					JUMP="$tmp"
					return "$RETURN_JUMP"
				else
					return
				fi
			fi
			jump="$(echo -ne "$jump" | iconv -f utf-8 -t ascii//TRANSLIT)"
			SEARCHBUFFER="$(printf '%s\n' "${queue_array[@]}" | iconv -f utf-8 -t ascii//TRANSLIT | grep -ni "$jump")"
			length="$(echo -e "$SEARCHBUFFER" | wc -l)"
			if [ "$length" == "1" ]; then
				if [ "$(echo "$SEARCHBUFFER" | grep ":")" != "" ]; then
					LOOP_ARTIST=false
					JUMP="$(echo -e "$SEARCHBUFFER" | cut -d':' -f1)"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
				fi
			elif [ "$length" == "0" ]; then
				draw_pitch
				draw_position
				redraw_buffer
			else
				search_queue
				if [ "$?" == "$RETURN_JUMP" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
		fi
	else
		gtts_speak "closed" true
		draw_pitch
		draw_position
		redraw_buffer
	fi
}

new_playlist() {
	local initial_screen=$1
	KEYWORD=""
	gtts_speak "enter keyword to start new playlist"
	draw_banner "SEARCH"
	keyw="`read_line`"
	if [ "$keyw" == "" ]; then
		if [ "$initial_screen" == true ]; then
			empty_pane
		else
			draw_pitch
		fi
	else
		for i in "$keyw"; do
			KEYWORD="$KEYWORD$i.*"
		done
		file_list="$(find "$MUSICDIR" -type f)"
		matches="$(echo -e "$file_list" | grep -n "" | iconv -f utf-8 -t ascii//TRANSLIT | grep -iE ".*${keyw}.*mp3$|.*${keyw}.*flac$")"
		if [ "$2" == "true" ]; then
			IFS=$'\n'
			index=$TOTAL_QUEUE
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[$index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$(($index+1))
			done
			unset IFS
			if [ "$index" == "$TOTAL_QUEUE" ]; then
				gtts_speak "nothing found" true
				return
			fi
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[$index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$(($index+1))
			done
			unset IFS
			if [ "$index" == "0" ]; then
				gtts_speak "nothing found" true
				return
			fi
		fi
		VIDEO=false
		TOTAL_QUEUE="$index"
		echo -ne "$NOCOLOR"
		if [ "$2" == true ]; then
			gtts_speak "closed" true
			reset_buffer
		else
			JUMP="1"
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			return $RETURN_JUMP
		fi
	fi
}

search_queue() {
	local total="$(echo -e "$SEARCHBUFFER"| wc -l)"
	local number_per_page="$(($LINES-4))"
	local original_number_per_page="$number_per_page"

	local FLAGGED=false
	local REDRAWN=false
	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$pos" -le "$total" ] || [ "$FLAGGED" == false ]; do
		BUFFER=""
		tput cup 0
		if [ "$(($total-$pos))" -lt "$number_per_page" ]; then
			number_per_page=$(($total-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		_last=$(($pos+$number_per_page))
		_lines="$(echo -e "$SEARCHBUFFER" | sed -n "$pos,${_last}p")"
		diff=$(($_last-$pos))
		for i in $(seq 1 $diff); do
			truepos=$(($i))
			line="$(echo -ne "$_lines" | sed -n "${truepos}p")"
			m="$(echo -ne "$line" | cut -d':' -f1)"
			if [ "$m" == "" ]; then
				break
			fi

			line="$(echo "$line" | cut -d':' -f2 | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev)"
			if [ "$(echo -ne "$line" | grep " - ")" != "" ]; then
				artist="$(echo -ne "$line" | sed -e "s/ - //g" | cut -d'' -f1)"
				song="$(echo -ne "$line" | rev | sed -e "s/ - //g" | cut -d'' -f1 | rev)"
				line="$artist - $song"
			fi
			tmp_buf="$tmp_buf. $m. $line. "

			if [ "$m" -lt "$POSITION" ]; then
				COLOR="$WHITE"
			elif [ "$m" -gt "$POSITION" ]; then
				COLOR="$WHITE"
			else
				COLOR="$BLUE"
			fi

			if [ "$m" -lt "10" ]; then
				pad=" "
			else
				pad=""
			fi

			offset="$(($COLUMNS - ${#m} - 4 - ${#pad}))"


			line="$(echo "$line" | cut -b 1-$offset)"
			BUFFER="$BUFFER$BLUE$PADDING ${m} $COLOR$line$(tput el)\n"
		done
		tput cup 2
		echo -ne "$NOCOLOR$BUFFER"
		
		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page+2))"
		fi
		draw_banner "SEARCH"
		printf '%*s' $(($COLUMNS - 14))
		tput rc

		if [ "$WEB_CLIENT" == "0" ]; then
			read -rsn1 inputchar <&1
		else
			read -rsn1 -t 0.1 inputchar <"$ALETHEIA/web_client_pipe$$"
			if [ "$inputchar" == "" ]; then
				read -rsn1 inputchar <&1
			fi
		fi

		if [ "$inputchar" = "j" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -ge "$total" ]; then
				pos="$(($pos-$number_per_page))"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "`isnum \"$inputchar\"`" != "0" ]; then
			gtts_speak " $inputchar"
			up_down="`read_line $inputchar`"
			jumpto="$up_down"
			if [ "$jumpto" -le "$TOTAL_QUEUE" ]; then
				if [ "$jumpto" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jumpto"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					return
				fi
			fi
			return
		elif [ "$inputchar" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			else
				BUFFER="$BUFFER_BACKUP"
				gtts_speak "closed" true
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				return
			fi
		elif [ "$inputchar" == "" ]; then
			if [ "$VOICE_ENABLED" == true ]; then
				killall espeak-ng >/dev/null 2>/dev/null
			fi
			LOOP_ARTIST=false
			JUMP="`echo \"$SEARCHBUFFER\" | head -1 | cut -d':' -f1`"
			return $RETURN_JUMP
		elif [ "$inputchar" == "T" ]; then
			FLAGGED=false
		elif [ "$inputchar" == "d" ]; then
			killall play >/dev/null 2>/dev/null
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say " $tmp_buf"
			FLAGGED=false
		elif [ "$inputchar" == "q" ]; then #|| [ "$inputchar" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
				gtts_speak "closed" true
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
			return
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			reset_dimensions
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "SEARCH"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$(($pos+$number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$(($total-$number_per_page-1))"
				fi
				;;
			'[A')
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "closed" true
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position

				return
				;;
			esac
		fi
	done
}

queue_controls() {
	gtts_speak "select queue"
	SEARCHBUFFER="`ls -1 \"$ALETHEIA/playlists/\"`"
	local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
	local number_per_page="$(($LINES-4))"
	local original_number_per_page="$number_per_page"
	local FLAGGED=false
	local REDRAWN=false

	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$(($pos-1))" -le "$total" ]; do
		if [ "$total" == "0" ]; then
			SEARCHBUFFER="\n"
			local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
		else
			SEARCHBUFFER="`ls -1 \"$ALETHEIA/playlists/\"`"
			local total="`echo -e \"$SEARCHBUFFER\"| wc -l`"
		fi
		BUFFER=""
		tput cup 0
		if [ "$(($total-$pos))" -lt "$number_per_page" ]; then
			number_per_page=$(($total-$pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		for i in `seq $pos $(($pos + $(($number_per_page-1))))`; do
			line="`echo -e \"$SEARCHBUFFER\" | sed -n ${i}p`"

			if [ "$i" -lt "10" ]; then
				pad=" "
			else
				pad=""
			fi

			offset="$(($COLUMNS-${#i} - 3))"

			line="`echo \"$line\" | cut -b 1-$offset`"

			tmp_buf="$tmp_buf. $i. $line, "
			if [ "$line" == "" ]; then
				BUFFER="$BUFFER$BLUE ${i} $WHITE(none)$(tput el)\n"
			else
				BUFFER="$BUFFER$BLUE ${i} $WHITE$line$(tput el)\n"
			fi
		done
		tput cup 2
		echo -ne "$NOCOLOR$BUFFER"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$(($number_per_page+2))"
		fi
		draw_banner "QUEUE"

		read -rsn1 inputchar <&1

		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$(($pos+$number_per_page))"
			if [ "$pos" -gt "$total" ]; then
				pos="$(($total-$number_per_page-1))"
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "`isnum \"$inputchar\"`" != "0" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			up_down="`read_line \"$inputchar\"`"
			jumpto="$up_down"
			if [ "$jumpto" -le "$total" ]; then
				if [ "$jumpto" -gt "0" ]; then
					PICK="`echo -ne \"$SEARCHBUFFER\" | sed -n ${jumpto}p`"
					if [ "$PICK" == "" ]; then
						gtts_speak "number not valid"
					else
						unset queue_array

						IFS=$'\n'
						index=0
						for i in `cat "$ALETHEIA/playlists/$PICK"`; do
							queue_array[$index]="$i"
							index=$(($index+1))
						done
						unset IFS
						TOTAL_QUEUE=$(($index-1))
						JUMP="1"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
					continue
				else
					continue
				fi
			else
				gtts_speak "number not valid"
				continue
			fi
			return
		elif [ "$inputchar" == "D" ]; then
			draw_banner "DELETE"
			gtts_speak "number to delete?"
			c="`read_line`"
			if [ "`isnum \"$c\"`" != "0" ]; then
				if [ "$c" -gt "0" ] && [ "$c" -le "$total" ]; then
					draw_banner "DELETE" true

					gtts_speak "delete $c?"
					read -rsn1 z
					if [ "$z" == "y" ] || [ "$z" == "Y" ]; then
						pmt_PICK="`echo -ne \"$SEARCHBUFFER\" | sed -n ${c}p`"
						rm "$ALETHEIA/playlists/$pmt_PICK"
						gtts_speak "deleted"
					else
						gtts_speak "delete canceled"
					fi
				fi
			fi
		elif [ "$inputchar" == "" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$VOICE_ENABLED" == true ]; then
				killall espeak-ng >/dev/null 2>/dev/null
			fi
			PICK="`echo -ne \"$SEARCHBUFFER\" | head -1`"
			if [ "$PICK" == "" ]; then
				gtts_speak "no queues"
			else
				unset queue_array

				IFS=$'\n'
				index=0
				for i in `cat "$ALETHEIA/playlists/$PICK"`; do
					queue_array[$index]="$i"
					index=$(($index+1))
				done
				unset IFS
				TOTAL_QUEUE=$(($index-1))
				JUMP="1"
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				return $RETURN_JUMP
			fi
		elif [ "$inputchar" == "d" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			espeak_say " $tmp_buf" true
		elif [ "$inputchar" == "Z" ]; then
			if [ "$initial_screen" == true ]; then
				continue
			fi
			gtts_speak "save queue as?"
			draw_banner "SAVE QUEUE"
			tmp="`read_line`"
			if [ "$tmp" != "" ]; then
				if [ ! -e "$ALETHEIA/playlists/" ]; then
					mkdir "$ALETHEIA/playlists"
				fi
				echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
				gtts_speak "saved"
			else
				gtts_speak "canceled"
			fi
			draw_banner "QUEUE"
			draw_position
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
			fi
			gtts_speak "closed" true
			if [ "$inputchar" == "i" ]; then
				return -2
			fi
			return -1
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			reset_dimensions
			number_per_page="$(($LINES-4))"
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "QUEUE"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$(($pos+$number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$(($total-$number_per_page-1))"
				fi
				;;
			'[A')
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				killall espeak-ng >/dev/null 2>/dev/null
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					draw_volume
					draw_equalizer
					draw_pitch
					draw_position
				fi
				return -1
				;;
			esac
		fi
		
	done
}

set_equalizer() {
	draw_banner "EQUALIZER"

	empty_pane

	tput cup $(($LINES-5))
	echo -ne "$PADDING${WHITE}Bass$BLUE? "
	gtts_speak "bass"
	bass="`read_number`"
	if [ "$bass" == "" ]; then
		gtts_speak "closed" true
		if [ "$2" == false ] || [ "$2" == "" ]; then
			redraw_buffer
		fi
		return
	fi
	tput cup $(($LINES-4))
	echo -ne "$PADDING${WHITE}Mid$BLUE? "
	gtts_speak "mid"
	mid="`read_number`"
	if [ "$mid" == "" ]; then
		gtts_speak "closed" true
		if [ "$2" == false ] || [ "$2" == "" ]; then
			redraw_buffer
		fi
		return
	fi
	tput cup $(($LINES-3))
	echo -ne "$PADDING${WHITE}Treble$BLUE? "
	gtts_speak "treble"
	treble="`read_number`"
	if [ "$treble" == "" ]; then
		gtts_speak "closed" true
		if [ "$2" == false ] || [ "$2" == "" ]; then
			draw_pitch
			redraw_buffer
		fi
		return
	fi

	if [ "$bass" == "0" ] && [ "$mid" == "0" ] && [ "$treble" == "0" ]; then
		gtts_speak "equalizer off"
	else
		gtts_speak "equalizer on"
	fi

	bass="$bass:$bass:$bass"
	mid="$mid:$mid:$mid:$mid"
	treble="$treble:$treble:$treble"

	EQUALIZER="$bass:$mid:$treble"
	if [ "$1" == false ] || [ "$1" == "" ]; then
		echo -e "af_cmdline equalizer $EQUALIZER" >"$ALETHEIA/pipe$$" &
	fi

	equal="`echo $EQUALIZER | cut -d':' -f1`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f4`"
	equal="$equal:`echo $EQUALIZER | cut -d':' -f8`"

	draw_volume
	draw_equalizer
	if [ "$2" == false ] || [ "$2" == "" ]; then
		if [ "$1" == false ] || [ "$1" == "" ]; then
			draw_pitch
			draw_position
			redraw_buffer
		fi
	fi
}

print_queue() {
	gtts_speak "queue"
	current=$POSITION
	BUFFER_BACKUP="$BUFFER"

	number_per_page="$(($LINES-4))"

	original_number_per_page="$number_per_page"

	FLAGGED=false
	REDRAWN=false

	tput cup 2

	CHANGED=false

	stty -echo
	HALF="$(($POSITION % $number_per_page + ($number_per_page/2) + 1))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
			HALF="1"
		else
			HALF="1"
		fi
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$(($TOTAL_QUEUE-$original_number_per_page+1))"
			number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$(($original_number_per_page*2 - 1))" ]; then
		HALF="$(($POSITION-($original_number_per_page/2)))"
	fi

	if [ "$(($TOTAL_QUEUE-$POSITION))" -lt "$number_per_page" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page+3))"
	fi
	if [ "$(($HALF+$original_number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
		HALF="$(($TOTAL_QUEUE-$original_number_per_page))"
		number_per_page="$original_number_per_page"
	fi

	half_page="$(($number_per_page/2))"
	if [ "$POSITION" -gt "$half_page" ]; then
		result="$(($POSITION-$half_page))"
		if [ "$(($number_per_page % 2))" != "" ]; then
			HALF="$result"
		else
			HALF=$((1+$result))
		fi

		if [ "$(($HALF+$number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
		fi
	fi

	if [ "$HALF" -gt "$(($TOTAL_QUEUE-$number_per_page))" ]; then
		HALF="$(($TOTAL_QUEUE-$number_per_page+1))"
	fi
	if [ "$HALF" -lt "1" ]; then
		HALF=1
	fi

	pos=$HALF
	while [ "$pos" -le "$TOTAL_QUEUE" ]; do
		stty -echo
		echo -ne "$NOCOLOR"
		if [ "$(($TOTAL_QUEUE-$pos))" -lt $number_per_page ] && [ "$pos" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi
		if [ "$(($pos+$number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
			number_per_page="$original_number_per_page"
		fi
		if [ "$pos" -gt "$TOTAL_QUEUE" ]; then
			return 200
		fi
		if [ "$number_per_page" -gt "$TOTAL_QUEUE" ]; then
			number_per_page="$TOTAL_QUEUE"
		fi
		flaggy=false
		tmpbuf=""
		if [ "$pos" -le $POSITION ] && [ "$(($pos + $(($number_per_page-1))))" -ge "$POSITION" ] || [ $CHANGED == true ] ; then
			if [ "$pos" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" != "1" ]; then
				number_per_page="$original_number_per_page"
				pos="$(($pos-$number_per_page))"
			fi
			x=0
			end=$(($number_per_page-1))
			_last=$(($pos+$end))
			diff=$(($_last-$pos+1))
			truepos=$(($i-1+$pos))
			tput cup 2
			m=$pos
			new_buf=""
			for i in `seq 1 $number_per_page`; do
				if [ -e "${queue_array[$(($m-1))]}.locked" ]; then
					if [ -e "${queue_array[$(($m-1))]}.repeats" ]; then
						INDICATOR="$BLUE$REPLACE${WHITE}#"
					else
						INDICATOR="$BLUE${REPLACE}${WHITE}$"
					fi
				else
					if [ -e "${queue_array[$(($m-1))]}.repeats" ]; then
						INDICATOR="$BLUE$REPLACE${WHITE}&"
					else
						INDICATOR="${BLUE} "
					fi
				fi
				if [ "$TOTAL_QUEUE" -gt "9" ]; then
					if [ "$m" -lt "10" ]; then
						pad=" "
					else
						pad=""
					fi
					display_pad="$pad"
				fi
				if [ "$POSITION" == "$m" ]; then
					rep=""
				else
					rep="$BLUE"
				fi
				if [ "$current" == "$m" ] || [ "$POSITION" == "$m" ]; then
					nline="`echo -ne \"${queue_array[$(($m-1))]}\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | cut -c 1-$(($COLUMNS-(${#PADDING}*2)-3-${#m}-${#display_pad}))`"
					padd="`printf '%*s' $(($COLUMNS-(${#PADDING}*2)-3-${#m}-${#nline}-${#display_pad}))`"
					new_buf="$new_buf$BLUE_BLACK${PADDING}$INDICATOR$BLUE_BLACK $display_pad$BLUE_BLACK$m $rep$nline$padd$PADDING$NOCOLOR\n"
				else
					new_buf="$new_buf${PADDING}$BLUE$INDICATOR$BLUE $display_pad$BLUE$m $WHITE`echo -ne \"${queue_array[$(($m-1))]}\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | cut -c 1-$(($COLUMNS-(${#PADDING}*2)-3-${#m}))``tput el`\n"
				fi
				m=$(($m+1))
			done

			echo -ne "$new_buf"

			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				empty_pane "$(($number_per_page+2))"
			fi
		else
			pos="$(($pos+$number_per_page))"
			continue
		fi


		draw_banner "QUEUE"
		tput rc
		
		read -rsn1 inputchar
		tput civis
		if [ "$inputchar" = "j" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page down"
			CHANGED=true
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
				if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
					pos="$(($TOTAL_QUEUE-$number_per_page+1))"
				else
					pos="$(($pos+$number_per_page))"
				fi
			fi
			if [ "$current" -le "$truepos" ]; then
				current=$pos
			fi
		elif [ "$inputchar" = "k" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			gtts_speak "page up"
			CHANGED=true
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$(($pos-$number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
			current=$pos
		elif [ "$inputchar" = "h" ]; then
			if [ "$current" == "$TOTAL_QUEUE" ]; then
				continue
			fi
			current=$(($current+1))
			if [ "$current" -gt "$truepos" ]; then
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "page down"
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$(($TOTAL_QUEUE-$number_per_page+1))"
					else
						pos="$(($pos+$number_per_page))"
					fi
				fi
			fi

			skip=true
		elif [ "$inputchar" = "l" ]; then
			if [ "$current" == "1" ]; then
				continue
			fi
			current=$(($current-1))
			if [ "$current" -lt "$(($truepos-$number_per_page+1))" ]; then
				killall espeak-ng >/dev/null 2>/dev/null
				gtts_speak "page up"
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			fi

			skip=true
		elif [ "$inputchar" == "," ]; then
			gtts_speak "$(echo -ne "${queue_array[$(($current-1))]}" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev)"
		elif [ "`isnum \"$inputchar\"`" != "0" ]; then
			up_down="`read_line \"$inputchar\"`"
			if [ "`isnum \"$up_down\"`" != "0" ]; then
				up_down="${up_down#"${up_down%%[!0]*}"}"
				if [ "$up_down" -lt "1" ]; then
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				elif [ "$up_down" -le "$TOTAL_QUEUE" ]; then
					JUMP="$up_down"
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				fi
			fi
		elif [ "$inputchar" == "b" ]; then
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM_BACK
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST_BACK
			elif [ "$ONLY_LOCKED" == true ]; then
				return $RETURN_ONLY_LOCKED_BACK
			else
				return $RETURN_BACK
			fi
		elif [ "$inputchar" == "n" ]; then
			ps -p $MPLAYER_PID >/dev/null
			if [ "$?" != "1" ]; then
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						JUMP="1"
						POSITION="1"
						draw_position
						return $RETURN_JUMP
					else
						return 0
					fi
				fi
			fi
		elif [ "$inputchar" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			elif [ "$?" == "-1" ]; then
				return -1 
			fi
		elif [ "$inputchar" == "z" ]; then
			draw_wait
			CHANGED=true
			REDRAWN=true
			pos=1
			clear
			reset_dimensions
			number_per_page=$(($LINES-4))
			original_number_per_page=$number_per_page
			draw_volume
			draw_equalizer
			draw_banner "QUEUE"
			draw_position
			reset_buffer
			continue
		elif [ "$inputchar" == "?" ]; then
			queue_help_screen
			continue
		elif [ "$inputchar" == "<" ]; then
			if [ "$current" -lt "$TOTAL_QUEUE" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$(($POSITION+1))
				elif [ "$(($current+1))" == "$POSITION" ]; then
					POSITION=$(($POSITION-1))
				fi
				tmp="${queue_array[$current]}"
				queue_array[$current]="${queue_array[$(($current-1))]}"
				queue_array[$(($current-1))]="$tmp"
				current=$(($current+1))
				if [ "$current" -gt "$truepos" ]; then
					killall espeak-ng >/dev/null 2>/dev/null
					gtts_speak "page down"
					CHANGED=true
					if [ "$FLAGGED" == true ]; then
						continue
					fi
					if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
						if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
							pos="$(($TOTAL_QUEUE-$number_per_page+1))"
						else
							pos="$(($pos+$number_per_page))"
						fi
					fi
				fi
			fi
		elif [ "$inputchar" == ">" ]; then
			if [ "$current" -gt "1" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$(($POSITION-1))
				elif [ "$(($current-1))" == "$POSITION" ]; then
					POSITION=$(($POSITION+1))
				fi
				tmp="${queue_array[$(($current-2))]}"
				queue_array[$(($current-2))]="${queue_array[$(($current-1))]}"
				queue_array[$(($current-1))]="$tmp"
				current=$(($current-1))
				if [ "$current" -lt "$(($truepos-$number_per_page+1))" ]; then
					killall espeak-ng >/dev/null 2>/dev/null
					gtts_speak "page up"
					CHANGED=true
					if [ "$pos" == "1" ]; then
						continue
					else
						FLAGGED=false
					fi
					if [ "$number_per_page" -lt "$original_number_per_page" ]; then
						number_per_page="$original_number_per_page"
					fi
					pos="$(($pos-$number_per_page))"
					if [ "$pos" -le "0" ]; then
						pos=1
					fi
				fi
			fi
		elif [ "$inputchar" == "p" ]; then
			if [ "$PAUSE" == true ]; then
				draw_position
				gtts_speak "unpaused"
			else
				gtts_speak "paused"
			fi
			toggle_pause true
			continue
		elif [ "$inputchar" == "d" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			if [ "$CHANGED" != false ]; then
				espeak_say " $pos of $(($pos+$number_per_page-1)). $tmpbuf."
			else
				espeak_say " $pos of $(($pos+$number_per_page-1)). $tmpbuf."
			fi
		elif [ "$inputchar" == $'\e' ]; then
			read -n2 -t 0.03 key
			case $key in
			'[B')
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$(($pos+$number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$(($pos+($number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$(($TOTAL_QUEUE-$number_per_page+1))"
					else
						pos="$(($pos+$number_per_page))"
					fi
				fi
				;;
			'[A')
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$(($pos-$number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				echo -ne "$NOCOLOR"
				draw_equalizer
				draw_volume
				draw_pitch
				draw_position
				redraw_buffer
				return 200
				;;
			esac
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == ";" ]; then
			killall espeak-ng >/dev/null 2>/dev/null
			BUFFER="$BUFFER_BACKUP"
			echo -ne "$NOCOLOR"
			reset_buffer
			draw_volume
			draw_equalizer
			redraw_buffer
			draw_pitch
			draw_position
			gtts_speak "closed" true
			return 200
		elif [ "$inputchar" == "" ]; then
			kill $MPLAYER_PID >/dev/null 2>/dev/null
			JUMP="$current"
			draw_position
			return $RETURN_JUMP
		fi
	done
	redraw_screen true
}

_save_setting() {
	if [ "`echo \"$CONFIG\" | grep -i $1`" == "" ]; then
		CONFIG="$CONFIG\n$1=$2"
	else
		CONFIG="`echo -ne \"$CONFIG\" | sed -e \"/$1/s/.*/$1=$2/g\"`"
	fi
}

save_settings() {
	draw_banner "SAVE" true
	gtts_speak "save settings?"
	while [ true ]; do
		read -rsn1 yesno
		if [ "$yesno" == "z" ]; then
			draw_wait
			reset_dimensions
			draw_banner "SAVE" true
			redraw_screen false 1 1 0 0
		else
			break
		fi
	done
	if [ "$yesno" == "y" ]; then
		_save_setting "VOICE_PITCH" "$VOICE_PITCH"
		_save_setting "DEFAULT_VOLUME" "$DEFAULT_VOLUME"
		_save_setting "VOICE_VOLUME" "$VOICE_VOLUME"
		_save_setting "PANELS_ENABLED" "$PANELS_ENABLED"
		_save_setting "DARK_BACKGROUND" "$DARK_BACKGROUND"
		_save_setting "ONLY_VOICE_TITLES" "$ONLY_VOICE_TITLES"
		_save_setting "COLORS_ENABLED" "$COLORS_ENABLED"
		_save_setting "DEFAULT_EQUALIZER" "$DEFAULT_EQUALIZER"
		if [ "$VOICE_ENABLED" == true ]; then
			_save_setting "VOICE_ENABLED" "true"
		else
			_save_setting "VOICE_ENABLED" "false"
		fi
		echo -e "$CONFIG" >"$ALETHEIA/config"
		gtts_speak "saved" true
	else
		gtts_speak "canceled" true
	fi
	draw_pitch
	draw_position
}

main() {
	PAUSE=false
	MUTE=false
	LOCKED=false
	SCALETEMPO=false
	FLAGS=""
	START_MARKER="0.0"
	END_TIME=""
	space=0
	SAVED_INTERVAL=""
	SAVED_POSITION=""
	CURRENT_POSITION=""
	SAVED_TOTAL=""

	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LIMIT=$(calc "$EDO * 2.6")
	INTERVAL_UPPER_LIMIT=$(calc "$EDO * 2.1")

	if [ -e "$FILENAME.locked" ]; then
		LOCKED=true

		if [ "$LOCKED_OFF" == false ]; then
			read_locked_file "$(cat "$FILENAME.locked")"
		fi

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi

		FLAGS="-speed `calc \"2^($INTERVAL/$EDO)\"` -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"

		if [ "$_scaletempo_flag" == "1" ]; then
			FLAGS="$FLAGS,scaletempo=speed=tempo"
			SCALETEMPO=true
		elif [ "$_scaletempo_flag" == "2" ]; then
			FLAGS="$FLAGS,scaletempo=speed=pitch"
			SCALETEMPO=true
			ONLY_PITCH=true
		else
			SCALETEMPO=false
		fi
	else
		FLAGS="-speed `calc \"2^($DEFAULT_INTERVAL/$DEFAULT_EDO)\"` -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"
	fi

	if [ -e "$FILENAME.repeats" ]; then
		REPEATS="$(cat "$FILENAME.repeats")"
		REPEAT_CURRENT=1
		REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
	else
		REPEATS=""
		REPEAT_CURRENT=0
		REPEAT_TOTAL=0
	fi

	LOOP=false
	echo -ne "$NOCOLOR"
	reset_buffer
	redraw_buffer
	draw_equalizer
	draw_volume

	if [ "`echo -ne \"$TITLE\" | grep \" - \" 2>/dev/null`" != "" ]; then
		ARTISTSONG="$ARTIST - $SONG"
	else
		ARTISTSONG="$TITLE"
	fi
	if [ "$ONLY_VOICE_TITLES" == true ]; then
		gtts_speak "$ARTISTSONG" false false true
	else
		gtts_speak "$ARTISTSONG"
	fi
	
	LOCKED_EDO="$EDO"

	if [ "$VIDEO" == false ]; then
		flag="-novideo"
	else
		flag=""
	fi

	if [ "$FULLSCREEN" == true ]; then
		flag="$flag -fs"
	fi

	if [ "$ALWAYS_ON_TOP" == true ]; then
		flag="$flag -ontop"
	fi

	if [ "$REPEAT_ONLY" == true ]; then
		FLAGS="$FLAGS -volume 0"
	fi

	rm -f "$ALETHEIA/mplayer_output" >/dev/null 2>/dev/null

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
		var1="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`.repeat.$ext"
		if [ ! -e "$var1" ]; then
			var1="$FILENAME"
		fi
	else
		var1="$FILENAME"
	fi
	mplayer -slave -osdlevel 0 -ao pulse -softvol -softvol-max 100 $flag -hr-mp3-seek -quiet -input file="$ALETHEIA/pipe$$" -noconfig all $FLAGS "$var1" >"$ALETHEIA/mplayer_output" 2>/dev/null &

	MPLAYER_PID="$!"

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		SELECT_REPEAT_FILE=false
	fi
	
	if [ "$REPEAT_ONLY" == true ]; then
		repeat
		repeat_tmp=$?
		if [ "$repeat_tmp" != "200" ]; then
			return $repeat_tmp
		fi
	else
		draw_pitch
		draw_position
	fi

	old_LINES=$LINES
	old_COLUMNS=$COLUMNS

	stty -echo
	while true; do
		if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
			clear
			draw_wait
			reset_dimensions
			redraw_screen false
			if [ "$MUTE" == true ]; then
				draw_banner "MUTE"
			elif [ "$PAUSE" == true ]; then
				draw_banner "PAUSE"
			fi
			gtts_speak "screen redrawn"
			old_LINES=$LINES
			old_COLUMNS=$COLUMNS
		fi
		if [ "$WEB_CLIENT" == "0" ]; then
				read -rsn1 -t $MAIN_REFRESH_TIME input
		else
			read -rsn1 -t 0.4 input
			if [ "$input" == "" ] && [ "$WEB_CLIENT" == "1" ]; then
				read -rsn1 -t 0.3 input <"$ALETHEIA/web_client_pipe$$"
			fi
		fi

		ps -p $MPLAYER_PID >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					JUMP="1"
					return $RETURN_JUMP
				else
					return 0
				fi
			fi
		fi

		case "$input" in
			'j')
				pitch_down
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'k')
				pitch_up
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'o')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				;;
			'm')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				;;
			'i')
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				;;
			'p')
				toggle_pause
				;;
			'n')
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				killall play >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						JUMP="1"
						POSITION="1"
						draw_position
						return $RETURN_JUMP
					else
						return 0
					fi
				fi
				;;
			'b')
				if [ "$POSITION" == "0" ]; then
					POSITION=1
				fi
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				killall play >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM_BACK
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST_BACK
				elif [ "$ONLY_LOCKED" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					return $RETURN_BACK
				fi
				;;
			'8')
				system_volume_change "-3% -3%"
				;;
			'9')
				system_volume_change "+3% +3%"
				;;
			'y')
				set_default_edo
				;;
			'h')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_position
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				echo "seek -5%" >"$ALETHEIA/pipe$$" &
				;;
			'l')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				ps -p $MPLAYER_PID >/dev/null
				if [ "$?" == "1" ]; then
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
							JUMP="1"
							return $RETURN_JUMP
						else
							return 0
						fi
					fi
				fi
				echo "seek +5%" >"$ALETHEIA/pipe$$" &
				;;
			';')
				BUFFER_BACKUP="$BUFFER"
				print_queue
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'?')
				help_screen
				draw_volume
				draw_equalizer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'q')
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$_input" != "" ]; then
					if [ "$_input" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					fi
				fi
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "quit?"
				fi
				input_char=""
				until [ "$input_char" == "n" ] || [ "$input_char" == "q" ]; do
					read -n1 input_char
					if [ "$input_char" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					elif [ "$input_char" == "q" ]; then
						draw_pitch
						draw_position
						break
					elif [ "$input_char" == "n" ]; then
						draw_pitch
						draw_position
					fi
				done
				;;
			'P')
				old_percent=0
				percentbreak=false
				ps -p $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$?" != "1" ]; then
					echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					percent="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
					if [ "`isnum \"$percent\"`" == "0" ]; then
						percent=1
					fi
					total_=$(($COLUMNS-(${#PADDING}*2)-14))
					PAUSE=false
					tput cup $LINES
					echo -ne "$BLUE_BLACK${PADDING}00$WHITE_BLACK:${BLUE_BLACK}00 "
					echo -ne "$BLUE_BLACK[$WHITE_BLACK"
					percent=`calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1`
					if [ "$percent" -gt "$total_" ]; then
						percent="$total_"
					fi
					gtts_speak "progress bar"
					printf '%*s' $percent | tr " " "="
					printf '%*s' $(($total_ - $percent))
					echo -ne "$BLUE_BLACK] "
					minutes="$(echo -ne "$SONG_LENGTH" | cut -d':' -f1)"
					seconds="$(echo -ne "$SONG_LENGTH" | cut -d':' -f2)"
					echo -ne "$BLUE$minutes$WHITE:$BLUE$seconds$PADDING"
					if [ "`echo -ne \"$minutes\" | cut -c 1`" == "0" ]; then
						minutes="`echo -ne \"$minutes\" | cut -c 2`"
					fi
					if [ "`echo -ne \"$seconds\" | cut -c 1`" == "0" ]; then
						seconds="`echo -ne \"$seconds\" | cut -c 2`"
					fi
					total_seconds_tt=$(($minutes * 60 + $seconds))
					tput cup $LINES $((1+7))
					l=0
					input_char=""
					until [ "$input_char" != "" ]; do
						ps -p $MPLAYER_PID >/dev/null 2>/dev/null
						if [ "$?" == "1" ]; then
							if [ "$TRACK_RANDOM" == true ]; then
								return $RETURN_TRACK_RANDOM
							elif [ "$LOOP_ARTIST" == true ]; then
								return $RETURN_LOOP_ARTIST
							else
								if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
									JUMP="1"
									return $RETURN_JUMP
								else
									return 0
								fi
							fi
						fi
						echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
						sleep $MPLAYER_WAIT_TIME
						percent="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2`"
						echo "get_time_pos" >"$ALETHEIA/pipe$$" &
						sleep $MPLAYER_WAIT_TIME
						tmpq="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d'=' -f2 | cut -d'.' -f1`"
						tput cup $LINES 1
						if [ "`isnum \"$tmpq\"`" == "1" ]; then
							dateo="`date -u -d @$tmpq +%M:%S`"
							skip2=false
						else
							dateo="00:00"
							percent=$total_
							skip2=true
						fi
						echo -ne "$BLUE`echo -ne \"$dateo\" | cut -d':' -f1`$WHITE:$BLUE`echo -ne \"$dateo\" | cut -d':' -f2`"
						if [ "$skip2" == false ]; then
							tput cup $LINES $(($COLUMNS-6))
							if [ "$INTERVAL" -lt "0" ]; then
								int="`echo -ne \"$INTERVAL\" | cut -c 2-`"
								neg=true
								skip=false
							elif [ "$INTERVAL" -gt "0" ]; then
								int="$INTERVAL"
								neg=false
								skip=false
							else
								skip=true
							fi
							if [ "$skip" == false ]; then
								if [ "$neg" == true ]; then
									total_seconds_dateo="`calc \"$total_seconds_tt * (2 * $int / $EDO)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
								else
									total_seconds_dateo="`calc \"$total_seconds_tt * (($int / $EDO)/2)\" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1`"
									total_seconds_dateo=$(($total_seconds_tt-$total_seconds_dateo))
								fi
								new_minutes=$(($total_seconds_dateo / 60))
								new_seconds=$(($total_seconds_dateo % 60))
							else
								new_minutes=$minutes
								new_seconds=$seconds
							fi
							tput cup $LINES $(($COLUMNS-6))
							new_minutes="`printf '%02d' $new_minutes`"
							new_seconds="`printf '%02d' $new_seconds`"
							echo -ne "$BLUE$new_minutes$WHITE:$BLUE$new_seconds"
							if [ "`isnum \"$percent\"`" == "0" ]; then
								percent=$total_
							fi
							percent=`calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1`
							if [ "$percent" -gt "$total_" ]; then
								percent="$total_"
							fi
							
							tput cup $LINES $((1+7))
							echo -ne "$WHITE_BLACK"
							printf '%*s' $percent | tr " " "="
							printf '%*s' $(($total_ - $percent))
						fi
						read -n1 -t 1 input_char
						if [ "$input_char" == "l" ]; then
							if [ "$old_percent" -gt "$percent" ]; then
								percentbreak=true
								break
							fi
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							ps -p $MPLAYER_PID >/dev/null
							if [ "$?" == "1" ]; then
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
										JUMP="1"
										return $RETURN_JUMP
									else
										return 0
									fi
								fi
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							old_input_char="$input_char"
							input_char=""
						elif [ "$input_char" == "h" ]; then
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_position
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							old_input_char="$input_char"
							input_char=""
						elif [ "$input_char" == "j" ]; then
							pitch_down false true
							old_input_char="$input_char"
							input_char=""
						elif [ "$input_char" == "k" ]; then
							pitch_up false true
							old_input_char="$input_char"
							input_char=""
						else
							old_input_char=""
						fi
						l=0
						old_percent=$percent
					done
					if [ "$percentbreak" == true ]; then
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST
						else
							if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
								JUMP="1"
								return $RETURN_JUMP
							else
								return 0
							fi
						fi
					fi
					if [ "$MUTE" == true ]; then
						draw_banner "MUTE"
					else
						draw_pitch
					fi
					draw_position
					gtts_speak "closed" true
				fi
				;;
			'$')
				gtts_speak "position saved"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.05
				draw_banner "POS SAVED"
				sleep $BANNER_WAIT_TIME
				if [ "$SAVED_POSITION" == "" ]; then
					SAVED_TOTAL=1
					SAVED_POSITION[1]="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
					CURRENT_POSITION=1
				else
					SAVED_TOTAL=$(($SAVED_TOTAL+1))
					SAVED_POSITION[$SAVED_TOTAL]="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				fi
					
				draw_pitch
				draw_position
				;;
			'|')
				vanish
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'`')
				draw_banner "COMMAND"
				command="`read_line`"
				if [ "$command" == "about" ]; then
					about
					read -rsn1 _
				elif [ "$command" != "" ]; then
					echo -e "$command" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					empty_pane
					tput cup $(($LINES-3))
					echo -ne "$PADDING$CYAN`tail -1 \"$ALETHEIA/mplayer_output\"`"
					tput el
					read -n1 input_char
				fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'\')
				SAVED_POSITION=""
				CURRENT_POSITION=""
				if [ "$VIDEO" == true ] || [ "$VIDEO_FLAGGED" == true ]; then
					JUMP="$POSITION"
					kill $MPLAYER_PID 2>/dev/null >/dev/null
					if [ "$VIDEO" == false ]; then
						VIDEO_FLAGGED=false
					fi
					return $RETURN_JUMP
				else
					echo "seek 0 2" >"$ALETHEIA/pipe$$" &
					if [ "$PAUSE" == true ]; then
						PAUSE=false
						draw_pitch
						draw_position
					fi
				fi
				;;
			'5')
				draw_banner "START"
				gtts_speak "start"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep $(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)
				fi
				draw_pitch
				draw_position
				;;
			'%')
				rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
				gtts_speak "unlocked"
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					INDICATOR="${WHITE_BLACK}&"
				else
					INDICATOR="$BLUE_BLACK "
				fi
				echo -ne "$INDICATOR"
				;;
			'7')
				draw_banner "END"
				gtts_speak "end"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_TIME="`tail -1 \"$ALETHEIA/mplayer_output\" | cut -d '=' -f2`"
				END_MARKER=$END_TIME
				space=0
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep $(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)
				fi
				draw_pitch
				draw_position
				;;
			'&')
				ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f1 | rev`"
				filename_without_ext="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | rev`"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					SELECT_REPEAT_FILE=true
					JUMP="$POSITION"
					kill $MPLAYER_PID
					return $RETURN_JUMP
				else
					gtts_speak "none"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'6')
				repeat
				repeat_tmp="$?"
				if [ "$repeat_tmp" != "200" ] && [ "$repeat_tmp" != "300" ]; then
					return $repeat_tmp
				fi
				;;
			'0')
				get_system_volume
				tmp_volume_left="`echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1`"
				tmp_volume_right="`echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1`"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					total="$tmp_volume_left"
					right=true
				elif [ "$tmp_volume_right" -gt "$tmp_volume_left" ]; then
					total="$tmp_volume_right"
					right=false
				else
					continue
				fi

				gtts_speak "balancing volume"

				draw_banner "BALANCING"

				flaggy=false
				while [ "$tmp_volume_left" != "$tmp_volume_right" ]; do
					if [ "$tmp_volume_left" -lt "$total" ]; then
						tmp_volume_left=$(($tmp_volume_left+1))
					elif [ "$tmp_volume_left" -gt "$total" ]; then
						tmp_volume_left=$(($tmp_volume_left-1))
					fi

					if [ "$tmp_volume_right" -lt "$total" ]; then
						tmp_volume_right=$(($tmp_volume_right+1))
					elif [ "$tmp_volume_right" -gt "$total" ]; then
						tmp_volume_right=$(($tmp_volume_right-1))
					fi

					get_system_volume
					pactl set-sink-volume @DEFAULT_SINK@ ${tmp_volume_left}% ${tmp_volume_right}%
					#MIXER_OUTPUT="`amixer sset Master ${tmp_volume_left}%,${tmp_volume_right}% | grep \"Front\" | grep \"\[\"`"
					#SYSTEM_VOLUME_LEFT="`echo \"$MIXER_OUTPUT\" | grep Left | cut -d'[' -f2 | cut -d']' -f1`"
					#SYSTEM_VOLUME_RIGHT="`echo \"$MIXER_OUTPUT\" | grep Right | cut -d'[' -f2 | cut -d']' -f1`"
					draw_volume 2 3
					read -rsn1 -t 0.08 c
					ps -p $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "0" ]; then
						flaggy=true
						break
					elif [ "$c" == "z" ]; then
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 0 1
						draw_banner "BALANCING"
					fi
				done
				draw_pitch
				if [ "$flaggy" == true ]; then
					get_system_volume
					continue
				fi
				;;
			')')
				get_system_volume
				tmp_volume_left="`echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1`"
				tmp_volume_right="`echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1`"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					SYSTEM_VOLUME_RIGHT="${tmp_volume_left}%"
				else
					SYSTEM_VOLUME_LEFT="${tmp_volume_right}%"
					tmp_volume_left=$tmp_volume_right
				fi

				pactl set-sink-volume @DEFAULT_SINK@ $SYSTEM_VOLUME_LEFT $SYSTEM_VOLUME_RIGHT
				draw_volume
				espeak_say " $tmp_volume_left"
				;;
			'G')
				oscillate
				;;
			'g')
				if [ "$INTERVAL" == "0" ]; then
					continue
				fi
				if [ "$PAUSE" == true ]; then
					echo -e "pause" >"$ALETHEIA/pipe$$" &
					PAUSE=false
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				draw_banner "INVERT" false true
				old_int="$INTERVAL"
				INTERVAL="$((-($INTERVAL)))"
				gtts_speak "scaling"
				if [ "$INTERVAL" -lt "0" ]; then
					result="$old_int"
				else
					result="$INTERVAL"
				fi
				result="$(($result*2))"
				x=0
				if [ "$old_int" -gt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				while [ "$x" -lt "$result" ]; do
					read -rsn1 -t $SCALE_SPEED c
					ps -p $MPLAYER_PID >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					secondary_scale_func "$c" "INVERT"
					if [ "$c" == "c" ]; then
						x=$(($result-$x))
						if [ "$NEGATIVE" == true ]; then
							NEGATIVE=false
						else
							NEGATIVE=true
						fi
					#FIXME
					elif [ "$c" == "o" ]; then
						old_int=$(($old_int*2))
					elif [ "$c" == "m" ]; then
						old_int=$INTERVAL
					elif [ "$c" == "z" ]; then
						x2=$x
						draw_wait
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "INVERT" false true
						x=$x2
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
						draw_banner "INVERT" false true
					elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "m" ]; then
						break
					elif [ "$c" == "" ]; then
						if [ "$NEGATIVE" == false ]; then
							INTERVAL="$(($old_int-1))"
							old_int="$(($old_int-1))"
						else
							INTERVAL="$(($old_int+1))"
							old_int="$(($old_int+1))"
						fi
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x="$(($x+1))"
					fi

				done
				espeak_say " $INTERVAL $EDO"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'M')
				invert_int
				;;
			'f')
				tmux_attach
				;;
			'F')
				yt_search
				;;
			'C')
				yt_artist
				;;
			'W')
				add_downloaded
				;;
			'J')
				edo_down
				;;
			'I')
				say_status
				;;
			'K')
				edo_up
				;;
			'<')
				if [ "$VIDEO" == true ]; then
					gtts_speak "video disabled"
					VIDEO=false
					draw_banner "OFF"
				else
					gtts_speak "video enabled"
					VIDEO=true
					VIDEO_FLAGGED=true
					draw_banner "VIDEO ON"
				fi
				kill $MPLAYER_PID >/dev/null 2>/dev/null
				JUMP="$POSITION"
				return "$RETURN_JUMP"
				;;
			'>')
				if [ "$FULLSCREEN" == false ]; then
					echo "pausing_keep vo_fullscreen 1" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=true
					gtts_speak "video fullscreen"
					draw_banner "FULLSCREEN"
				else
					gtts_speak "video normal"
					echo "pausing_keep vo_fullscreen 0" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=false
					draw_banner "OFF"
				fi
				stty -echo
				sleep $BANNER_WAIT_TIME
				stty echo
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'U')
				scale_edo
				;;
			'Z')
				gtts_speak "save queue as?"
				draw_banner "SAVE QUEUE"
				tmp="`read_line`"
				if [ "$tmp" != "" ]; then
					if [ ! -e "$ALETHEIA/playlists/" ]; then
						mkdir "$ALETHEIA/playlists"
					fi
					echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
					gtts_speak "saved"
				else
					gtts_speak "canceled"
				fi
				draw_pitch
				draw_position
				;;
			'c')
				toggle_mute
				;;
			't')
				zero_interval
				if [ "$?" == "$RETURN_QUIT" ]; then
					return $RETURN_QUIT
				fi
				;;
			'H')
				less_precise
				;;
			'L')
				more_precise
				;;
			'Y')
				zero_interval_jump
				;;
			'x')
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				tput cup $(($LOCKING_POS+2)) $((1))
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					gtts_speak "unlocked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "$BLUE_BLACK "
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						if [ "$ONLY_PITCH" == true ]; then
							echo "$INTERVAL/$EDO/2" >"$FILENAME".locked
						else
							echo "$INTERVAL/$EDO/1" >"$FILENAME".locked
						fi
					else
						echo "$INTERVAL/$EDO/0" >"$FILENAME".locked
					fi
					LOCKED=true
					gtts_speak "locked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "${WHITE_BLACK}${REP}$"
					fi
				fi
				;;
			'a')
				PAUSE=false
				set_equalizer
				draw_pitch
				;;
			'')
				if [ "$CURRENT_POSITION" != "" ]; then
					CURRENT_POSITION=$(($CURRENT_POSITION+1))
					if [ "$CURRENT_POSITION" -gt "$SAVED_TOTAL" ]; then
						CURRENT_POSITION=1
					fi
					echo "seek ${SAVED_POSITION[$CURRENT_POSITION]} 2" >"$ALETHEIA/pipe$$" &
				fi
				;;
			'v')
				toggle_scale_tempo
				;;
			'')
				draw_indicator() {
					RIGHT_BANNER_WIDTH="29"
					if [ "$(($COLUMNS-$RIGHT_BANNER_WIDTH-$LEFT_BANNER_WIDTH-2-(${#PADDING}*2)))" -gt "1" ]; then
						tput cup $LINES $(($COLUMNS-${#PADDING}-$RIGHT_BANNER_WIDTH))
						echo -ne "${BLUE_BLACK}v:${WHITE_BLACK}invert ${BLUE_BLACK}#:${WHITE_BLACK}save ${BLUE_BLACK}n:${WHITE_BLACK}next ${BLUE_BLACK}b:${WHITE_BLACK}back$PADDING"
						echo -ne "$COLOR_TEXT"
					else
						draw_position
					fi
				}

				orig_BLUE=$BLUE
				orig_BLUE_BLACK=$BLUE_BLACK
				orig_WHITE=$WHITE
				orig_WHITE_BLACK=$WHITE_BLACK
				orig_COLOR_ACCENT=$COLOR_ACCENT
				gtts_speak "select color"
				if [ "$complementary_color" == "" ]; then
					complementary_color=false
				fi
				char=""
				until [ "$char" == "q" ]; do
					if [ "$char" == "n" ] || [ "$char" == "" ]; then
						gtts_speak "next color"
						prev_BLUE=$BLUE
						prev_BLUE_BLACK=$BLUE_BLACK
						lBLUE=$(generate_random_color)
						color="${lBLUE#"#"}"
						bred=$((16#${color:0:2}))
						bgreen=$((16#${color:2:2}))
						bblue=$((16#${color:4:2}))
						BLUE="\033[1;38;2;${bred};${bgreen};${bblue}m"

						prev_WHITE=$WHITE
						prev_WHITE_BLACK=$WHITE_BLACK
						if [ "$complementary_color" == true ]; then
							lWHITE=$(generate_complementary_color "$BLUE")
						else
							lWHITE=$(generate_random_color)
						fi
						color="${lWHITE#"#"}"
						wred=$((16#${color:0:2}))
						wgreen=$((16#${color:2:2}))
						wblue=$((16#${color:4:2}))
						WHITE="\033[1;38;2;${wred};${wgreen};${wblue}m"
						WHITE_BLACK="\033[1;38;2;${wred};${wgreen};${wblue}m"

						newBLUE=$(generate_dark_random_color)
						color="${newBLUE#"#"}"
						red=$((16#${color:0:2}))
						green=$((16#${color:2:2}))
						blue=$((16#${color:4:2}))
						
						if [ "$PANELS_ENABLED" == true ]; then
							WHITE_BLACK="\033[1;38;2;$wred;$wgreen;$wblue;48;2;$red;$green;${blue}m"
							BLUE_BLACK="\033[1;38;2;$bred;$bgreen;$bblue;48;2;$red;$green;${blue}m"
						else
							WHITE_BLACK="$WHITE"
							BLUE_BLACK="$BLUE"
						fi
						prev_COLOR_ACCENT=$COLOR_ACCENT
						COLOR_ACCENT="\033[1;38;2;$red;$green;${blue}m"
					elif [ "$char" == "b" ]; then
						gtts_speak "previous color"
						BLUE=$prev_BLUE
						BLUE_BLACK=$prev_BLUE_BLACK
						WHITE=$prev_WHITE
						WHITE_BLACK=$prev_WHITE_BLACK
						COLOR_ACCENT=$prev_COLOR_ACCENT
					elif [ "$char" == "#" ]; then
						clean_sequence=${BLUE#*\033}
						clean_sequence=${clean_sequence%m}
						IFS=';' read -ra color_values <<< "$clean_sequence"
						r=$(printf "%02x" "${color_values[3]}")
						g=$(printf "%02x" "${color_values[4]}")
						b=$(printf "%02x" "${color_values[5]}")
						hex_color="#$r$g$b"
						_save_setting "COLOR_HIGHLIGHT" "$hex_color"
						clean_sequence=${WHITE#*\033}
						clean_sequence=${clean_sequence%m}
						IFS=';' read -ra color_values <<< "$clean_sequence"
						r=$(printf "%02x" "${color_values[3]}")
						g=$(printf "%02x" "${color_values[4]}")
						b=$(printf "%02x" "${color_values[5]}")
						hex_color="#$r$g$b"
						_save_setting "COLOR_UNSELECTED" "$hex_color"
						if [ "$PANELS_ENABLED" == true ]; then
							clean_sequence=${BLUE_BLACK#*\033}
							clean_sequence=${clean_sequence%m}
							IFS=';' read -ra color_values <<< "$clean_sequence"
							r=$(printf "%02x" "${color_values[8]}")
							g=$(printf "%02x" "${color_values[9]}")
							b=$(printf "%02x" "${color_values[10]}")
							hex_color="#$r$g$b"
							_save_setting "COLOR_PANEL" "$hex_color"
						fi
						echo -e "$CONFIG" >"$ALETHEIA/config"
						draw_banner "SAVED"
						tput el
						
						gtts_speak "color saved"
						sleep $BANNER_WAIT_TIME
						break
					elif [ "$char" == "v" ]; then
						tmpBLUE=$BLUE
						tmpBLUE_BLACK=$BLUE_BLACK
						BLUE=$WHITE
						BLUE_BLACK=$WHITE_BLACK
						WHITE=$tmpBLUE
						WHITE_BLACK=$tmpBLUE_BLACK
					elif [ "$char" == "c" ]; then
						if [ "$complementary_color" == true ]; then
							complementary_color=false
							gtts_speak "random"
						else
							gtts_speak "complementary"
							complementary_color=true
						fi
						draw_indicator
						flaggy=true
						char="n"
					fi
					reset_buffer
					draw_volume
					draw_equalizer
					redraw_buffer
					draw_banner "COLOR"
					draw_indicator
					if [ "$flaggy" != true ]; then
						read -rsn1 char
					else
						flaggy=false
					fi
				done
				RIGHT_BANNER_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+3))"
				if [ "$char" != "q" ]; then
					draw_banner "WAIT"
					render_help_screen
					render_voice_settings_screen
					render_repeat_help_screen
					render_scale_help_screen
				else
					draw_banner "WAIT"
					draw_position
					BLUE=$orig_BLUE
					BLUE_BLACK=$orig_BLUE_BLACK
					WHITE=$orig_WHITE
					WHITE_BLACK=$orig_WHITE_BLACK
					COLOR_ACCENT=$orig_COLOR_ACCENT
					reset_buffer
				fi
				redraw_screen
				;;
			'')
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'')
				if [ "$ALWAYS_ON_TOP" == true ]; then
					gtts_speak "always on top"
					draw_banner "OFF"
					ALWAYS_ON_TOP=false
					echo "vo_ontop 0" >"$ALETHEIA/pipe$$" &
				else
					gtts_speak "off"
					draw_banner "ON TOP"
					ALWAYS_ON_TOP=true
					echo "vo_ontop 1" >"$ALETHEIA/pipe$$" &
				fi
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				;;
			'')
				add_downloaded true
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'd')
				toggle_voice
				draw_pitch
				;;
			':')
				if [ "$DIMENSIONS_RESET" == true ]; then
					render_help_screen
					render_voice_settings_screen
					render_repeat_help_screen
					render_scale_help_screen
					DIMENSIONS_RESET=false
				fi
				voice_settings_screen
				;;
			'/')
				set_custom_edo
				;;
			'4')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_all_tuning
				;;
			'w')
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_to_locked
				;;
			'T')
				if [ "$ONLY_VOICE_TITLES" == true ]; then
					ONLY_VOICE_TITLES=false
					if [ "$VOICE_ENABLED" == true ]; then
						prev_true=true
					else
						prev_true=false
					fi
					VOICE_ENABLED=true
					if [ "$prev_true" == true ]; then
						gtts_speak "voice on"
						draw_banner "voice on"
					else
						gtts_speak "off"
						draw_banner "off"
						VOICE_ENABLED=false
					fi
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				else
					ONLY_VOICE_TITLES=true
					if [ "$VOICE_ENABLED" == true ]; then
						prev_true=true
					else
						prev_true=false
					fi
					VOICE_ENABLED=true
					if [ "$prev_true" == true ]; then
						VOICE_ENABLED=true
						gtts_speak "voice on"
						draw_banner "VOICE ON"
					else
						gtts_speak "voice only titles, on"
						VOICE_ENABLED=false
						draw_banner "ONLY TITLES"
					fi
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'z')
				tput civis
				draw_wait
				reset_dimensions
				redraw_screen false
				if [ "$MUTE" == true ]; then
					draw_banner "MUTE"
				elif [ "$PAUSE" == true ]; then
					draw_banner "PAUSE"
				fi
				gtts_speak "screen redrawn"
				;;
			'O')
				gtts_speak "edit playlist"
				echo -e "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/queue"
				cp "$ALETHEIA/queue" "$ALETHEIA/queue.old"
				vim +"$POSITION" "$ALETHEIA/queue"
				diff $ALETHEIA/queue $ALETHEIA/queue.old >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					unset queue_array

					IFS=$'\n'
					index=0
					for i in `cat "$ALETHEIA/queue"`; do
						queue_array[$index]="$i"
						index=$(($index+1))
					done
					unset IFS
					TOTAL_QUEUE=$index
					gtts_speak "saved"
					# FIXME
					new="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
					if [ "$new" == "" ]; then
						res="${queue_array[$POSITION]}"
						if [ "$res" != "$FILENAME" ]; then
							tput civis
							JUMP="$POSITION"
							kill $MPLAYER_PID >/dev/null 2>/dev/null
							return $RETURN_JUMP
						fi
					else
						POSITION="$new"
					fi
					reset_buffer
				else
					gtts_speak "closed" true
				fi
				tput civis
				redraw_buffer
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				;;
			',')
				gtts_speak "$TITLE" true
				;;
			'D')
				yesno=""
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$_input" != "" ]; then
					yesno="$_input"
				else
					draw_banner "DELETE" true
					gtts_speak "delete?"
				fi

				if [ "$yesno" == "" ]; then
					read -rsn1 yesno
				fi
				if [ "$yesno" == "y" ] || [ "$yesno" == "Y" ]; then
					if [ ! -d "$ALETHEIA/deleted" ] || [ ! -d "$ALETHEIA/deleted/voices" ]; then
						mkdir "$ALETHEIA/deleted"
						mkdir "$ALETHEIA/deleted/voices"
					fi
					mv "$FILENAME" "$ALETHEIA/deleted"
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "$ALETHEIA/deleted"
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "$ALETHEIA/deleted"
					fi
					path="`echo -ne \"$FILENAME\" | rev | cut -d'/' -f2- | rev`"
					if [ "`ls -1 \"$path\"`" == "" ]; then
						rmdir "$path"
					fi
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						mv "$ALETHEIA/voices/$TITLE.mp3" "$ALETHEIA/deleted/voices/"
					fi
					draw_pitch
				else
					draw_pitch
					draw_position
					gtts_speak "canceled"
					continue
				fi
				tput el
				draw_position
				if [ "$POSITION" = "" ]; then
					return 0
				fi

				for i in `seq $POSITION $(($TOTAL_QUEUE-1))`; do
					queue_array[$(($i-1))]=${queue_array[$i]}
				done

				kill $MPLAYER_PID >/dev/null 2>/dev/null
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					JUMP="1"
					POSITION="1"
					draw_position
					TOTAL_QUEUE="$(($TOTAL_QUEUE-1))"
					return $RETURN_JUMP
				else
					TOTAL_QUEUE="$(($TOTAL_QUEUE-1))"
					return $RETURN_RESTART
				fi
				;;
			"'")
				jump_to_first_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'"')
				jump_to_last_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'N')
				if [ "$SHUFFLED" == false ]; then
					last="$(echo -ne "${queue_array[$(($TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/ - //" | cut -d'' -f1)"
					if [ "$artist" != "$last" ]; then
						IFS=$'\n'
						tmpq="`printf '%s\n' ${queue_array[@]} | grep -n "\/$artist \- " | tail -1 | cut -d':' -f1`"
						unset IFS
						JUMP="$(($tmpq+1))"
						unset tmpq
						kill $MPLAYER_PID >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				fi
				;;
			'B')
				if [ "$SHUFFLED" == false ]; then
					IFS=$'\n'
					tmpq="`printf '%s\n' ${queue_array[@]} | grep -n "\/$artist \- " | head -1 | cut -d':' -f1`"
					if [ "$tmpq" -gt "1" ]; then
						last_artist="`echo -ne \"${queue_array[$(($tmpq-2))]}\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev | sed -e \"s/ - //\" | cut -d'' -f1`"
						JUMP="`printf '%s\n' ${queue_array[@]} | grep -n "\/$last_artist \- " | head -1 | cut -d':' -f1`"
					fi
					unset IFS
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			's')
				start_search
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'S')
				new_playlist false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'')
				new_playlist false true
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'Q')
				queue_controls false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'#')
				save_settings
				;;
			'r')
				draw_banner "RENAME" true
				gtts_speak "rename file?"
				read -rsn1 yesno
				if [ "$yesno" == "y" ]; then
					ext="`echo "$FILENAME" | rev | cut -d'.' -f1 | rev`"
					path="`echo "$FILENAME" | rev | cut -d'/' -f2- | rev`"
					if [ "`echo \"$path\" | grep '/'`" = "" ]; then
						path="."
					fi
					gtts_speak "enter the new title"
					tput rc
					echo -ne "$WHITE_BLACK"
					printf '%*s' $(($COLUMNS - 14))
					tput rc
					echo -ne "$WHITE_BLACK"
					newname="`read_line`"
					if [ "$newname" == "" ]; then
						redraw_buffer
						draw_pitch
						draw_position
						gtts_speak "canceled"
						continue
					fi
					mv "$FILENAME" "${path}/$newname.$ext" >/dev/null 2>/dev/null
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						rm -f "$ALETHEIA/voices/$TITLE.mp3"
					fi
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "${path}/$newname.$ext.locked" >/dev/null 2>/dev/null
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "${path}/$newname.$ext.repeats" >/dev/null 2>/dev/null
					fi
					gtts_speak "rename complete" true
					if [ "$POSITION" = "" ]; then
						POSITION=1
					fi

					export TITLE="$newname"
					export FILENAME="${path}/$newname.$ext" >/dev/null 2>/dev/null
					queue_array[$(($POSITION-1))]="$FILENAME"

					reset_buffer
					draw_volume
					draw_equalizer
					redraw_buffer
					draw_pitch
					draw_position
					continue
				else
					gtts_speak "canceled"
				fi
				redraw_screen true
				;;
			'*')
				system_volume_change "-1% -1%"
				;;
			'(')
				system_volume_change "+1% +1%"
				;;
			'!')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME="$(($VOLUME-1))"
					echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
					gtts_speak "$VOLUME"
					draw_equalizer
					draw_volume
				fi
				;;
			'1')
				pcm_volume_change "$input"
				if [ "$?" != "200" ]; then
					return $?
				fi
				;;
			'2')
				pcm_volume_change "$input"
				;;
			'@')
				pcm_volume_change "$input"
				;;
			'3')
				fade_volume
				;;
			'V')
				set_loop_artist
				;;
			'e')
				track_toggle
				if [ "$?" == 200 ]; then
					JUMP=1
					kill $MPLAYER_PID >/dev/null 2>/dev/null
					killall play >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			'')
				toggle_colors
				;;
			'')
				invert_colors
				;;
			'')
				toggle_panels true
				;;
			'')
				if [ "$LOCKED_OFF" == true ]; then
					LOCKED_OFF=false
					gtts_speak "locked on"
					draw_banner "LOCK ON"
				else
					LOCKED_OFF=true
					gtts_speak "locked off"
					draw_banner "LOCK OFF"
				fi
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				;;
			'')
				load_loop_file
				;;
			'')
				if [ "$REPEAT_ONLY" == false ]; then
					REPEAT_ONLY=true
					gtts_speak "playing all loops"
					JUMP="$POSITION"
					kill $MPLAYER_PID
					return $RETURN_JUMP
				else
					REPEAT_ONLY=false
					gtts_speak "off"
				fi
				;;
			'E')
				set_loop
				;;
			'~')
				set_sleep
				;;
			'R')
				shuffle_queue
				SHUFFLED=true
				draw_pitch
				draw_position
				;;
			'A')
				sort_queue
				SHUFFLED=false
				draw_position
				;;
			'.')
				set_custom_int
				;;
			'u')
				scale
				;;
			'X')
				set_scale_speed
				;;
			'')
				set_random
				;;
			'-')
				scale_octave "-"
				;;
			'=')
				scale_octave "+"
				;;
			'_')
				scale_octave "-" true
				;;
			'+')
				scale_octave "+" true
				;;
			*)
				if [ "$input" == "" ]; then
					read -n2 -t 0.03 key >/dev/null 2>/dev/null
					case $key in
						'[B')
							pitch_down
							;;
						'[A')
							pitch_up
							;;
						'[D')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >"$ALETHEIA/pipe$$" &
								MUTE=false
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							;;
						'[C')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >"$ALETHEIA/pipe$$" &
								MUTE=false
								draw_pitch
							fi
							ps -p $MPLAYER_PID >/dev/null
							if [ "$?" == "1" ]; then
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
										JUMP="1"
										return $RETURN_JUMP
									else
										return 0
									fi
								fi
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							;;
						*)
							continue
							;;
					esac
				else
					process_key "$input"
				fi
				;;
		esac
	done
}

trap cleanup EXIT
trap cleanup_sigint SIGINT

if [ ! -d "$ALETHEIA" ]; then
	mkdir "$ALETHEIA"
fi

if [ ! -d "$ALETHEIA/voices/" ]; then
	mkdir "$ALETHEIA/voices/"
fi

if [ ! -d "$ALETHEIA/playlists/" ]; then
	mkdir "$ALETHEIA/playlists"
fi

if [ ! -d "$MUSICDIR" ]; then
	mkdir -p "$MUSICDIR"
fi

if [ ! -d "$SOUNDDIR" ]; then
	mkdir -p "$SOUNDDIR"
fi

if [ ! -d "$VIDEODIR" ]; then
	mkdir -p "$VIDEODIR"
fi

rm -f "$ALETHEIA/pipe*" >/dev/null 2>/dev/null

mkfifo "$ALETHEIA/pipe$$"


exec 3<> "$ALETHEIA/pipe$$"

if [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	mkfifo "$ALETHEIA/web_client_pipe$$"
fi

tput sc

if [ "$2" != "" ]; then
	KEYWORDS="`echo \"$@\" | cut -d' ' -f2-`"
fi

rendered=false

if [ "$1" == "--music" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE=$index
		if [ "$index" -lt "1" ]; then
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
			exit 0
		fi
	else
		unset queue_array
		IFS=$'\n'
		index=0
		for i in `find "$MUSICDIR" -iname "*.mp3" -o -iname "*.flac" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE=$index
		if [ "$index" -lt "1" ]; then
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}Nothing found in $MUSICDIR"
			exit 0
		fi
	fi
	SHUFFLED=true
elif [ "$1" == "--sound" ] || [ "$WEB_CLIENT" == "1" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		if [ -e "$SOUNDDIR" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$SOUNDDIR" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=true
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$SOUNDDIR does not exist."
			exit 0
		fi
	else
		if [ -e "$SOUNDDIR" ]; then
			unset queue_array

			IFS=$'\n'
			index=0
			for i in `find "$SOUNDDIR" -iname "*.mp3" -o -iname "*.flac" | sort`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=false
		else
			clear
			tput cup $LINES
			echo -e "\n${RED}Error: ${NOCOLOR}$SOUNDDIR does not exist."
			exit 0
		fi
	fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
		exit 0
	fi
	TOTAL_QUEUE=$index
	if [ "$WEB_CLIENT" == "1" ]; then
		node $HOME/webserver.js >/dev/null 2>/dev/null &
	fi
elif [ "$1" == "--video" ]; then
	if [ "$2" != "" ]; then
		for i in "$KEYWORDS"; do
			KEYWORD="$KEYWORD$i.*"
		done
		unset queue_array

		IFS=$'\n'
		index=0
		for i in `find "$VIDEODIR" -iregex ".*${KEYWORD}mkv" -o -iregex ".*${KEYWORD}mp4" -o -iregex ".*${KEYWORD}webm" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE=$(($index))
	else
		unset queue_array

		IFS=$'\n'
		index=0
		for i in `find "$VIDEODIR" -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.webm" | shuf`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
	fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
		exit 0
	fi
	TOTAL_QUEUE=$index
	VIDEO=false
elif [ "$1" == "--directory" ]; then
	if [ "$2" != "" ]; then
		echo -ne "" >"$ALETHEIA/queue"
		if [ -d "$2" ]; then
			unset queue_array
			IFS=$'\n'
			index=0
			for i in `find "$2" -iname "*.mp3" -o -iname "*.flac" -o -iname "*.mkv" -o -iname "*.mp4" | shuf`; do
				queue_array[$index]="$i"
				index=$(($index+1))
			done
			unset IFS
			SHUFFLED=true
			TOTAL_QUEUE=$index
		else
			clear
			tput cup $LINES
			echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
			exit 0
		fi
	else
		clear
		tput cup $LINES
		echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
		exit 0
	fi
	if [ "$index" -lt "1" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found in $2"
		exit 0
	fi
elif [ "$1" == "--file" ]; then
	if [ "$2" == "" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}No file specified."
		exit 0
	fi
	if [ -e "$2" ]; then
		queue_array[0]="`realpath \"$2\"`"
		TOTAL_QUEUE=1
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}'$2' does not exist."
		exit 0
	fi
elif [ "$1" == "--playlist" ]; then
	if [ -e "$2" ]; then
		unset queue_array

		IFS=$'\n'
		index=0
		for i in `cat "$2"`; do
			queue_array[$index]="$i"
			index=$(($index+1))
		done
		unset IFS
		TOTAL_QUEUE="$index"
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Playlist file '$2' does not exist."
		exit 0
	fi
elif [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	node $HOME/webserver.js >/dev/null 2>/dev/null &

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" != "" ]; then
	for i in "$@"; do
		KEYWORD="$KEYWORD$i.*"
	done
	#FIXME
	find "$MUSICDIR" "$SOUNDDIR" "$VIDEODIR" -iregex ".*${KEYWORD}mp3" -o -iregex ".*${KEYWORD}flac" >"$ALETHEIA/queue"
else
	if [ "$WEB_CLIENT" == "1" ]; then
		node $HOME/webserver.js >/dev/null 2>/dev/null &
	fi

	render_help_screen
	render_voice_settings_screen
	render_repeat_help_screen
	render_scale_help_screen
	rendered=true
	empty_pane

	if [ -e "$ALETHEIA/config" ]; then
		EQUALIZER="`cat $ALETHEIA/config | grep DEFAULT_EQUALIZER | cut -d'=' -f2`"
		if [ "$EQUALIZER" == "" ]; then
			EQUALIZER="$DEFAULT_EQUALIZER"
		fi
	fi
	draw_equalizer

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
fi

if [ "$rendered" == false ]; then
	render_help_screen
	render_voice_settings_screen
	render_repeat_help_screen
	render_scale_help_screen
	empty_pane
fi

if [ "$start_at_pos" == "" ]; then
	start_at_pos=1
fi

POSITION=$start_at_pos
RUNTHROUGH=false

while [ "$POSITION" -le "$TOTAL_QUEUE" ] && [ "$POSITION" -ge "1" ]; do
	FILENAME="${queue_array[$(($POSITION-1))]}"
	TITLE="`echo -ne \"$FILENAME\" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev`"
	line="`echo -ne \"$FILENAME\" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev`"

	ARTIST="`echo -ne \"$line\" | sed -e \"s/ - //g\" | cut -d'' -f1`"
	SONG="`echo -ne \"$line\" | rev | sed -e \"s/ - //g\" | cut -d'' -f1 | rev`"

	if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
		RUNTHROUGH=true
	fi

	if [ "$ONLY_LOCKED" == true ]; then
		if [ ! -e "$FILENAME.locked" ]; then
			if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					if [ "$RUNTHROUGH" == false ]; then
						JUMP="1"
						RETURN="$RETURN_JUMP"
						RUNTHROUGH=true
					else
						web_client_func
						main
						RETURN="$?"
					fi
				else
					RETURN="0"
				fi
			fi
		else
			if [ "$REPEAT_ONLY" == true ]; then
				if [ ! -e "$FILENAME.repeats" ]; then
					if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
						RETURN="0"
					fi
				else
					web_client_func
					main
					RETURN="$?"
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		fi
	else
		if [ "$REPEAT_ONLY" == true ]; then
			if [ ! -e "$FILENAME.repeats" ]; then
				if [ "$LOOP_ARTIST" == true ]; then
					RETURN="$RETURN_LOOP_ARTIST"
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						if [ "$RUNTHROUGH" == false ]; then
							JUMP="1"
							RETURN="$RETURN_JUMP"
							RUNTHROUGH=true
						else
							web_client_func
							main
							RETURN="$?"
						fi
					else
						if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
							RETURN="0"
						fi
					fi
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		else
			web_client_func
			main
			RETURN="$?"
		fi
	fi

	if [ "$RETURN" == "$RETURN_QUIT" ]; then
		echo -ne "$NOCOLOR"
		exit 0
	elif [ "$RETURN" == "$RETURN_BACK" ]; then
		if [ "$POSITION" == "1" ]; then
			POSITION=$TOTAL_QUEUE
		else
			POSITION=$(($POSITION - 1))
		fi
		TRACK_RANDOM=false
	elif [ "$RETURN" == "$RETURN_RESTART" ]; then
		continue
	elif [ "$RETURN" == "$RETURN_JUMP" ]; then
		POSITION="$JUMP"
		POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
		RIGHT_BANNER_WIDTH=$POSITION_WIDTH
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST" ]; then
		new_POSITION="`printf '%s\n' \"${queue_array[@]}\" | sed \"1,${POSITION}d\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$(($new_POSITION+$POSITION))"
		else
			POSITION="`printf '%s\n' \"${queue_array[@]}\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		fi
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST_BACK" ]; then
		new_POSITION="`printf '%s\n' \"${queue_array[@]}\" | sed \"${POSITION},${TOTAL_QUEUE}d\" | tac | grep -ni \"\/$LOOP_ARTIST_NAME -\" | head -1 | cut -d':' -f1`"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$(($POSITION-$new_POSITION))"
		else
			POSITION="`printf '%s\n' \"${queue_array[@]}\" | grep -ni \"\/$LOOP_ARTIST_NAME -\" | tail -1 | cut -d':' -f1`"
		fi
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM" ]; then
		POSITION="$((1 + $RANDOM % $TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM_BACK" ]; then
		POSITION="$((1 + $RANDOM % $TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_ONLY_LOCKED_BACK" ]; then
		POSITION="$(($POSITION-1))"
		if [ "$POSITION" == "0" ]; then
			POSITION="$TOTAL_QUEUE"
		elif [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=0
		fi
	else
		POSITION="$(($POSITION+1))"
	fi
done

echo -ne "$NOCOLOR"
exit 0
