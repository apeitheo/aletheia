#!/bin/bash

# aletheia: a media player with pitch controls and voice feedback
#
# Copyright 2021-2023 Brad Hermanson <apeitheo@gmail.com>
#
# Aletheia is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License, version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details,
# available at https://www.gnu.org/licenses/
#
# GitHub:  https://github.com/apeitheo/aletheia
# Support: https://www.patreon.com/aletheia_project

#OS=$(uname -s)
OS="Linux"
PROGRAM_NAME="aletheia"
VERSION="0.9.6"
ESPEAK_DIGITAL_VOICE=${ESPEAK_DIGITAL_VOICE:-false}
MAIN_REFRESH_TIME=${REFRESH_TIME:-0.2}
MPLAYER_PATH=${MPLAYER_PATH:-""}
if [ "$MPLAYER_PATH" != "" ] && [ "${MPLAYER_PATH: -1}" != "/" ]; then
	MPLAYER_PATH+="/"
fi
AUDIO_FORMATS="mp3,flac,ogg,wav,wma"
VIDEO_FORMATS="mkv,mp4,avi,webm,mpg,mpeg"
NO_HELP=${NO_HELP:-false}
NO_VERTICAL_PADDING=${NO_VERTICAL_PADDING:-false}
USE_TAGS=true

ALETHEIA="$HOME/.aletheia"
MUSICDIR=${MUSICDIR:-"$HOME/Music/"}
SOUNDDIR=${SOUNDDIR:-"$HOME/Sounds/"}
VIDEODIR=${VIDEODIR:-"$HOME/Videos/"}

export MAIN_REFRESH_TIME
export MPLAYER_PATH

if [ "$1" == "--version" ]; then
	echo "$VERSION"
	exit 0
elif [ "$1" == "--help" ]; then
	space="$(printf '%*s' ${#PROGRAM_NAME})"
	echo -e "Usage: $PROGRAM_NAME [option] [<file/directory>|keyword]"
	echo
	echo -e "        $space--file <file>"
	echo -e "        $space--directory <directory>"
	echo -e "        $space--playlist <file>"
	echo
	echo -e "        $space--music [keyword]"
	echo -e "        $space--sound [keyword]"
	echo -e "        $space--video [keyword]"
	echo
	echo -e "        $space--server"
	echo -e "        $space--version"
	echo
	echo -e "See \`man $PROGRAM_NAME\` for more help."
	exit 0
fi

tput init
tput civis
stty -echo
stty -ixon
clear

WEB_CLIENT=${WEB_CLIENT:-0}

export HELP_BUFFER=()
export SETUP_HELP_BUFFER=()
export TMP_BUFFER=()
export TWO_COLUMN=false
export OUTPUT=""

SCALE_SPEED=0.2
DEFAULT_SCALE_SPEED=$SCALE_SPEED
export DIMENSIONS_RESET=false
export SELECT_REPEAT_FILE=false
export LOOP_ON=false
export SAVED_POSITION=()
export CURRENT_POSITION=""
PANELS_ENABLED=true
MENTIONED=false
BANNER_WAIT_TIME=0.6
MPLAYER_WAIT_TIME=0.1

LINE_CHAR="\033(0"
LINE_CHAR_END="\033(B"
TOP_BAR_MENU="${LINE_CHAR}lqqqqqqqqk$LINE_CHAR_END"
BOTTOM_BAR_MENU="${LINE_CHAR}mqqqqqqqqj$LINE_CHAR_END"
BAR="${LINE_CHAR}x${LINE_CHAR_END}"
ESC="\033["
NOCOLOR="${ESC}0m"

if [ "$COLORS_ENABLED" == false ]; then
	BLUE_BLACK="${ESC}1;37;1;40m"
	RED="${ESC}1;37m"
	BLUE="${ESC}1;37m"
else
	RED="${ESC}1;31m"
	BLUE="${ESC}1;34m"
	if [ "$PANELS_ENABLED" == true ]; then
		BLUE_BLACK="${ESC}1;34;1;40m"
		WHITE_BLACK="${ESC}1;37;1;40m"
	else
		BLUE_BLACK="${ESC}1;34m"
		WHITE_BLACK="${ESC}1;37m"
	fi
fi

RETURN_NEXT="0"
RETURN_QUIT="1"
RETURN_BACK="2"
RETURN_RESTART="3"
RETURN_JUMP="4"
RETURN_LOOP_ARTIST="5"
RETURN_LOOP_ARTIST_BACK="6"
RETURN_TRACK_RANDOM="7"
RETURN_TRACK_RANDOM_BACK="8"
RETURN_ONLY_LOCKED_BACK="9"

DEFAULT_INTERVAL="0"
DEFAULT_EDO="60"
DEFAULT_VOLUME="50"
DEFAULT_EQUALIZER="0:0:0:0:0:0:0:0:0:0"
EQUALIZER="$DEFAULT_EQUALIZER"
LOCKED_EDO=$DEFAULT_EDO
VOLUME=""
ONLY_PITCH=false
DEFAULT_THEME=true
DARK_BACKGROUND=${DARK_BACKGROUND:-""}

LOCKING_POS=0
EDO_LIMIT="1000000"
INTERVAL_LIMIT=$(echo "$DEFAULT_EDO * 2.6" | bc)
INTERVAL_UPPER_LIMIT=$(echo "$DEFAULT_EDO * 2.1" | bc)
SAVED_INTERVAL=""
SAVED_EDO=""

KEYWORD=""
export KEYWORD
FILENAME=""
ARTIST=""
SONG=""

SLEEPING=false
SUSPEND=false

LOOP=false
LOOP_ARTIST=false
TRACK_RANDOM=false
ONLY_LOCKED=false
REPEAT_ONLY=false
SHUFFLED=false
export LOOPS_ONLY=false
export LOCKED_OFF=false

JUMP=0
POSITION=0
TOTAL_QUEUE=0
export LOOP_ARTIST_NAME=""
RIGHT_BANNER_WIDTH=0
LEFT_BANNER_WIDTH=0
CORNER_DIVIDER=":"

export VIDEO=false
export VIDEO_FLAGGED=false
export FULLSCREEN=true
ALWAYS_ON_TOP=true
NO_QUEUE_FLAG=false

export ARTIST=""
export SONG=""
PICK=""
NODE_PID=""
ESPEAK_PID=""
DOWNLOAD_POSITION=""
SONG_LENGTH=""
PADDING=" "

VOICE_ENABLED=false
VOICE_PITCH=0
VOICE_VOLUME=.85
ONLY_VOICE_TITLES=false

POSITION_WIDTH=0

get_system_volume() {
	if [ "$MENTIONED" == true ] || [ "$(echo -ne "$OS" | grep -i linux)" != "" ]; then
		IFS='/' read -r _ SYSTEM_VOLUME_LEFT _ SYSTEM_VOLUME_RIGHT _ <<<"$(pactl get-sink-volume @DEFAULT_SINK@)"
		SYSTEM_VOLUME_LEFT=${SYSTEM_VOLUME_LEFT// /}
		SYSTEM_VOLUME_RIGHT=${SYSTEM_VOLUME_RIGHT// /}
	elif [ "$OS" == "Darwin" ]; then
		volume_text=$(osascript -e 'output volume of (get volume settings) as text')
		# not sure it supports changing left and right channel separately;
		# at least with osascript?
		SYSTEM_VOLUME_LEFT=$volume_text
		SYSTEM_VOLUME_RIGHT=$volume_text
	else
		clear
		tput cup $((LINES-3))
		echo "NOTE"
		echo "Aletheia does not currently support audio control using the '8' and '9' keys for adjusting system volume on your OS. Contact the developer for information on how to port to your OS of choice."
		echo "Do you want to continue [Y/n]? "
		read -rsn1 yn
		if [ "$yn" == "Y" ] || [ "$yn" == "y" ]; then
			SYSTEM_VOLUME_LEFT=100
			SYSTEM_VOLUME_RIGHT=100
		else
			exit 0
		fi
	fi
	if [ "$MENTIONED" == false ]; then
		MENTIONED=true
	fi
}

if [ ! -d "$ALETHEIA" ]; then
	mkdir -p "$ALETHEIA"
fi

touch -m "$ALETHEIA/start"

get_system_volume

read_config() {
	echo -ne "$CONFIG" | grep -i "$1" | cut -d'=' -f2 | sed -e "s/^ *//g" | sed -e "s/* $//g" | tr '[:upper:]' '[:lower:]' | sed "s/\"//g" | sed "s/'//g"
}

if [ -e "$ALETHEIA/config" ]; then
	CONFIG="$(cat "$ALETHEIA/config")"

	if [ "$CONFIG" != "" ]; then
		value="$(read_config "AUDIO_FORMATS")"
		if [ "$value" != "" ]; then
			AUDIO_FORMATS="$value"
		fi

		value="$(read_config "VIDEO_FORMATS")"
		if [ "$value" != "" ]; then
			VIDEO_FORMATS="$value"
		fi

		value="$(read_config "NO_HELP")"
		if [ "$value" != "" ]; then
			NO_HELP="$value"
		fi

		value="$(read_config "DEFAULT_VOLUME")"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		value="$(read_config "DEFAULT_INTERVAL")"
		if [ "$value" != "" ]; then
			DEFAULT_INTERVAL="$value"
		fi

		value="$(read_config "DEFAULT_EDO")"
		if [ "$value" != "" ]; then
			DEFAULT_EDO="$value"
		fi

		value="$(read_config "DEFAULT_EQUALIZER")"
		if [ "$value" != "" ]; then
			DEFAULT_EQUALIZER="$value"
		fi

		value="$(read_config "DEFAULT_VOLUME")"
		if [ "$value" != "" ]; then
			DEFAULT_VOLUME="$value"
		fi

		value="$(read_config "VOICE_ENABLED")"
		if [ "$value" != "" ]; then
			VOICE_ENABLED="$value"
		fi

		value="$(read_config "ONLY_VOICE_TITLES")"
		if [ "$value" != "" ]; then
			ONLY_VOICE_TITLES="$value"
		fi

		value="$(read_config "VOICE_PITCH")"
		if [ "$value" != "" ]; then
			VOICE_PITCH="$value"
		fi

		value="$(read_config "VOICE_VOLUME")"
		if [ "$value" != "" ]; then
			VOICE_VOLUME="$value"
		fi

		value="$(read_config "ESPEAK_DIGITAL_VOICE")"
		if [ "$value" != "" ]; then
			ESPEAK_DIGITAL_VOICE="$value"
		fi

		value="$(read_config "PANELS_ENABLED")"
		if [ "$value" != "" ]; then
			PANELS_ENABLED="$value"
		fi

		if [ "$PANELS_ENABLED" == true ]; then
			BLUE_BLACK="${ESC}1;34;1;40m"
			WHITE_BLACK="${ESC}1;37;1;40m"
		else
			BLUE_BLACK="${ESC}1;34m"
			WHITE_BLACK="${ESC}1;37m"
		fi

		if [ "$DARK_BACKGROUND" == "" ]; then
			value="$(read_config "DARK_BACKGROUND")"
			if [ "$value" != "" ]; then
				DARK_BACKGROUND="$value"
			else
				DARK_BACKGROUND=true
			fi
		fi

		value="$(read_config "COLORS_ENABLED")"
		if [ "$value" != "" ]; then
			COLORS_ENABLED="$value"
		fi

		if [ "$DARK_BACKGROUND" == true ]; then
			WHITE="${ESC}1;37m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${ESC}1;37;1;40m"
			else
				WHITE_BLACK="${ESC}1;37m"
			fi
		else
			WHITE="${ESC}1;30m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${ESC}1;30;1;40m"
			else
				WHITE_BLACK="${ESC}1;30m"
			fi
		fi

		value="$(read_config "COLOR_HIGHLIGHT")"
		if [ "$value" != "" ]; then
			COLOR_HIGHLIGHT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			BLUE="${ESC}1;38;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_UNSELECTED")"
		if [ "$value" != "" ]; then
			COLOR_UNSELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			WHITE="${ESC}1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue};1;40m"
			else
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue}m"
			fi
		fi

		value="$(read_config "COLOR_PANEL")"
		if [ "$value" != "" ]; then
			COLOR_PANEL="$value"

			colorblue="${COLOR_PANEL#"#"}"
			red=$((16#${colorblue:0:2}))
			green=$((16#${colorblue:2:2}))
			blue=$((16#${colorblue:4:2}))

			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
				BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			fi
			COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"
		fi

		value="$(read_config "DEFAULT_THEME")"
		if [ "$value" != "" ]; then
			DEFAULT_THEME="$value"
			OVERRIDE=true
		else
			OVERRIDE=false
		fi

		if [ "$OVERRIDE" == false ]; then
			if [ "$COLOR_HIGHLIGHT" == "" ] || [ "$COLOR_PANEL" == "" ] || [ "$COLOR_UNSELECTED" == "" ]; then
				DEFAULT_THEME=true
			else
				DEFAULT_THEME=false
			fi
		fi

		if [ "$COLORS_ENABLED" == false ]; then
			BLUE_BLACK="${ESC}1;37;1;40m"
			RED="${ESC}1;37m"
			BLUE="${ESC}1;37m"
			DEFAULT_THEME=false
		fi
	fi
fi

if [ "$DARK_BACKGROUND" == "" ]; then
	DARK_BACKGROUND=true
fi

if [ "$DEFAULT_THEME" == true ]; then
	if [ "$DARK_BACKGROUND" == true ]; then
		COLOR_UNSELECTED="#CCCCCC"
		COLOR_PANEL="#272727"
		COLOR_HIGHLIGHT="#83B7E6"
	else
		COLOR_UNSELECTED="#333333"
		COLOR_PANEL="#E2E2E2"
		COLOR_HIGHLIGHT="#336699"
	fi

	color="${COLOR_UNSELECTED#"#"}"
	red=$((16#${color:0:2}))
	green=$((16#${color:2:2}))
	blue=$((16#${color:4:2}))
	WHITE="${ESC}1;38;2;$red;$green;${blue}m"

	color="${COLOR_HIGHLIGHT#"#"}"
	red=$((16#${color:0:2}))
	green=$((16#${color:2:2}))
	blue=$((16#${color:4:2}))
	BLUE="${ESC}1;38;2;$red;$green;${blue}m"

	color="${COLOR_PANEL#"#"}"
	red=$((16#${color:0:2}))
	green=$((16#${color:2:2}))
	blue=$((16#${color:4:2}))

	COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"

	if [ "$PANELS_ENABLED" == true ]; then
		WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
		BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
	else
		WHITE_BLACK="$WHITE"
		BLUE_BLACK="$BLUE"
	fi
fi

cache_metadata() {
	export db_file="$ALETHEIA/music.db"
	rm -f "$db_file" >/dev/null 2>/dev/null
	sqlite3 "$db_file" "CREATE TABLE IF NOT EXISTS music (filename TEXT PRIMARY KEY, artist TEXT, song TEXT, album TEXT, number TEXT);"

	AUDIO_FORMATS="mp3,flac,ogg"
	regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"

	mapfile -t music_array < <(find "$MUSICDIR" -type f -iregex "$regex")

	extract_func() {
		line=$(exiftool -Artist -Title -Album -TrackNumber "$1")
		artist="$(echo -ne "$line" | grep -E "^Artist")"
		song="$(echo -ne "$line" | grep -E "^Title")"
		album="$(echo -ne "$line" | grep -E "^Album")"
		tracknum="$(echo -ne "$line" | grep -E "^Track Number")"
		artist="${artist##*: }"
		song="${song##*: }"
		echo -e ": $artist - $song" >/dev/stderr
		album="${album##*: }"
		tracknum="${tracknum##*: }"
		artist="${artist//\'/\'\'}"
		song="${song//\'/\'\'}"
		album="${album//\'/\'\'}"
		tracknum="${tracknum//\'/\'\'}"
		i="${1##*/}"
		i="${i//\'/\'\'}"
		((index++))

		echo -ne "INSERT INTO music (filename, artist, song, album, number) VALUES ('$i', '$artist', '$song', '$album', '$tracknum');"
	}

	export -f extract_func
	parallel --citation <<< "will cite\n" >/dev/null 2>/dev/null
	draw_wait
	parallel -j0 extract_func {} ::: "${music_array[@]}" >"$ALETHEIA/useless_out" 2>"$ALETHEIA/useless" &
	parallel_pid=$!
	clear
	tail -f "$ALETHEIA/useless" | grep -E "^:" &

	while true; do
		if ! ps -p $parallel_pid >/dev/null 2>/dev/null; then
			break
		fi
	done

	line="$(cat "$ALETHEIA/useless_out")"
	sqlite3 "$db_file" "BEGIN;$line;END;"
}

compute() {
	# if no pitch change requested, eliminate the overhead of calling sox to
	# change the default pitch of Google's digital voice
	if [ "$VOICE_PITCH" == "0" ]; then
		gtts-cli " $1" -o "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
	else
		gtts-cli " $1" -o "/tmp/_$2-tmp.mp3" >/dev/null 2>/dev/null
		sox "/tmp/_$2-tmp.mp3" "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" speed "$(calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-)" >/dev/null 2>/dev/null
		rm -f "/tmp/_$2-tmp.mp3"
	fi
	if [ "$3" != true ]; then
		play -v "$VOICE_VOLUME" "$ALETHEIA/voices/$2${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
	fi
}

gtts_speak_chain() {
	pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		kill "$(cat "$ALETHEIA/espeak.pid" 2>/dev/null)" >/dev/null 2>/dev/null
	fi
	if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
		list=""
		for i in "$@"; do
			list+="$i, "
		done
		espeak-ng -v en-us+m1 "$list" &
		echo -ne "$!" >"$ALETHEIA/espeak.pid"
	else
		if (( $# > 2 )); then
			gtts_speak "please wait"
		fi
		if [ "$VOICE_ENABLED" == true ]; then
			CHAIN=()
			index=0
			for i in "$@"; do
				if [ "${i:0:1}" == " " ]; then
					clip="${i:1}"
				else
					clip="$i"
				fi
				if [ "${i:0:1}" == "\-" ]; then
					clip="\\$clip"
				fi
				if [ "$clip" == "" ]; then
					continue
				fi
				if [ -e "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" ]; then
					if [ "$(echo -ne "$clip" | rev | cut -c 1)" == "?" ]; then
						clip="$(echo -ne "$clip" | rev | cut -c 2- | rev)\\?"
					fi
				else
					compute "$clip" "$clip" true >/dev/null 2>/dev/null
				fi
				CHAIN[index]="$clip"
				index=$((index+1))
			done

			ind=0
			for i in "${CHAIN[@]}"; do
				CHAIN[ind]="$ALETHEIA/voices/$i${VOICE_PITCH}.mp3"
				ind=$((ind+1))
			done

			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			play -v $VOICE_VOLUME "${CHAIN[@]}" >/dev/null 2>/dev/null &
		fi
	fi
}

gtts_speak() {
	if [ "$VOICE_ENABLED" == true ] || [ "$2" == true ] || [ "$4" == true ]; then
		if [ "$ONLY_VOICE_TITLES" == false ] && [ "$VOICE_ENABLED" == false ] && [ "$4" != true ]; then
			return
		fi
		if [ "$6" == true ]; then
			until [ -z "$(pgrep -f "^play.*$ALETHEIA/voices")" ]; do
				sleep 0.35
			done
		elif [ "$5" != true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
		fi
		line_count="$(echo -ne "$1" | wc -l)"
		if [ "$line_count" -gt 1 ]; then
			clip="$(echo -ne "$1" | head -1) - $line_count"
		else
			if [ "$(echo -ne "$1" | cut -c 1)" == " " ]; then
				clip="$(echo -ne "$1" | cut -c 2-)"
			else
				clip="$1"
			fi
			if [ "$(echo -ne "$1" | cut -c 1)" == "\-" ]; then
				clip="\\$clip"
			fi
		fi
		if [ -e "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" ]; then
			if [ "$(echo -ne "$clip" | rev | cut -c 1)" == "?" ]; then
				clip="$(echo -ne "$clip" | rev | cut -c 2- | rev)\\?"
			fi
			if [ "$(echo -e "$VOICE_VOLUME > 1.0" | bc)" == "1" ]; then
				VOICE_VOLUME=.85
			fi
			if [ "$2" != true ]; then
				play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
			else
				play -v $VOICE_VOLUME "$ALETHEIA/voices/$clip${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null
			fi
		else
			if [ "$line_count" -gt 1 ]; then
				if [ "$2" == false ] || [ "$2" == "" ]; then
					compute "$1" "$clip" >/dev/null 2>/dev/null &
				else
					compute "$1" "$clip" >/dev/null 2>/dev/null
				fi
			else
				if [ "$2" == false ] || [ "$2" == "" ]; then
					compute "$clip" "$clip" >/dev/null 2>/dev/null &
				else
					compute "$clip" "$clip" >/dev/null 2>/dev/null
				fi
			fi
		fi
	fi
}

if [ "$ESPEAK_DIGITAL_VOICE" == true ]; then
	gtts_speak() {
		kill $(cat "$ALETHEIA/espeak.pid") >/dev/null 2>/dev/null
		espeak_say "$1" "$2" "$3" true &
	}
fi

draw_vanish_indicator() {
	tput cup $LINES $((COLUMNS-${#char_count}-2-${#word_count}-${#line_count}-${#PADDING}))
	echo -ne "$BLUE${char_count}$WHITE:$BLUE${word_count}$WHITE:$BLUE${line_count}$PADDING"
}

draw_vanish_banner() {
	tput cup $LINES
	echo -ne "${PADDING}$WHITE-- ${BLUE}$1$WHITE --"
	LEFTBANNER_WIDTH=$((6+${#1}))
}

clear_vanish_banner() {
	tput cup $LINES
	printf '%*s' $((LEFTBANNER_WIDTH+1)) ""
}

vanish() {
	local in_menu=$1
	feedback_enabled=$VOICE_ENABLED
	inputnew=""
	display=""
	char_count=0
	line_count=1
	word_count=0
	saved_spot=""
	width=$((COLUMNS-((${#char_count}+2+${#word_count}+${#line_count})*2)-(${#PADDING}*2)-20))
	tput cup $LINES
	tput el
	draw_vanish_banner "INSERT"
	tput cup $LINES $((COLUMNS/2))
	echo -ne "${BLUE}_"
	tput sc
	visible=true
	char=""
	draw_vanish_indicator
	tput rc
	tmpflag=true
	quit=false
	while true; do
		draw_vanish_banner "INSERT"
		draw_vanish_indicator
		if [ "$tmpflag" == false ]; then
			IFS=$'\n'
			char=""
			until [ "$char" != "" ]; do
				read -rsn1 -t 0.6 char
				if [ "$char" == "" ]; then
						tput cup $LINES $((saved_spot+${#newdisplay}))
					if [ "$visible" == true ]; then
						echo -ne "${BLUE} "
						visible=false
					else
						echo -ne "${BLUE}_"
						visible=true
					fi
				fi
			done
			unset IFS
		else
			tmpflag=false
		fi
		preword=false
		if [[ $char == $'\e' ]]; then
			tput cup $LINES
			old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
			LEFTBANNER_WIDTH="9"

			if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
				printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
			fi
			gtts_speak "command mode"
			draw_vanish_banner "VANISH"
			while true; do
				read -rsn1 newchar
				if [ "$newchar" == "q" ]; then
					if [ "$in_menu" != true ]; then
						draw_pitch
						draw_position
					else
						echo
					fi
					quit=true
					break
				elif [ "$newchar" == ":" ]; then
					clear_vanish_banner
					tput cup $LINES ${#PADDING}
					echo -ne ":"
					stty echo
					command_line="$(read_line)"
					stty -echo
					if [[ "$command_line" == *" "* ]]; then
						IFS=' ' read -r _ name <<< "$command_line"
						WRITE_AS="$name"
					else
						WRITE_AS=""
					fi
					if [ "$command_line" == "w" ] || [ "$WRITE_AS" != "" ] || [ "$command_line" == "wq" ]; then
						gtts_speak "saved"
						if [ "$WRITE_AS" == "" ]; then
							inputnew=$(fold -w 80 -s <<< "$inputnew")
							echo -ne "\n\n$(date)\n\n$inputnew\n" >>"$HOME/Documents/journal"
						else
							echo -ne "$inputnew" >"$HOME/$WRITE_AS"
						fi
						tput cup $LINES
						old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
						LEFTBANNER_WIDTH="11"

						if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
							printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
						fi
						draw_vanish_banner "SAVED"
						sleep $BANNER_WAIT_TIME
						draw_vanish_banner "VANISH"
						if [ "$command_line" == "wq" ]; then
							if [ "$in_menu" != true ]; then
								draw_pitch
								draw_position
							else
								echo
							fi
							quit=true
						fi
						break
					elif [ "$command_line" == "q" ]; then
						if [ "$in_menu" != true ]; then
							draw_pitch
							draw_position
						else
							echo
						fi
						quit=true
						break
					fi
				elif [ "$newchar" == "h" ]; then
					if [ "$width" -gt "$(((COLUMNS*5)/8))" ]; then
						continue
					fi
					width="$((width+2))"
					newdisplay="$(echo -ne "$display" | tail -c $width)"
					if [ "${char_count}" -le "$width" ]; then
						tput cup $LINES $(((COLUMNS/2)-$((char_count/2))))
					else
						tput cup $LINES $(((COLUMNS/2)-(width/2)))
					fi

					echo -ne "$WHITE${newdisplay}${BLUE}_"
					#FIXME
					tput el
					draw_vanish_indicator
				elif [ "$newchar" == "l" ]; then
					width="$((width-2))"
					if [ "$width" -lt "0" ]; then
						width=0
					fi
					newdisplay="$(echo -ne "$display" | tail -c $width)"
					if [ "${char_count}" -le "$width" ]; then
						tput cup $LINES $(((COLUMNS/2)-$((char_count/2))))
					else
						tput cup $LINES $(((COLUMNS/2)-(width/2)))
					fi
					tput cub1
					echo -ne " "
					echo -ne "$WHITE${newdisplay}${BLUE}_"
					tput el
					draw_vanish_indicator
				elif [ "$newchar" == "p" ]; then
					toggle_pause true
				elif [ "$newchar" == "w" ]; then
					gtts_speak "saved"
					inputnew=$(fold -w 80 -s <<< "$inputnew")
					echo -ne "\n\n$(date)\n\n$inputnew\n" >>"$HOME/Documents/journal"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="11"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
					fi
					draw_vanish_banner "SAVED"
					sleep $BANNER_WAIT_TIME
				elif [ "$newchar" == "n" ]; then
					gtts_speak "new entry"
					inputnew=""
					display=""
					char_count=0
					tput cup $LINES
					tput el
					draw_vanish_indicator
					break
				elif [ "$newchar" == "d" ]; then
					if [ "$VOICE_ENABLED" == true ]; then
						gtts_speak "off"
						VOICE_ENABLED=false
						feedback_enabled=false
					else
						VOICE_ENABLED=true
						gtts_speak "on"
						feedback_enabled=true
					fi
				elif [ "$newchar" == "v" ]; then
					fold -w $COLUMNS -s <<< "$inputnew" | less
					gtts_speak "insert mode"
					tput cup $LINES
					old_LEFTBANNER_WIDTH=$LEFTBANNER_WIDTH
					LEFTBANNER_WIDTH="12"

					if [ "$old_LEFTBANNER_WIDTH" -gt "$LEFTBANNER_WIDTH" ]; then
						printf '%*s' $((old_LEFTBANNER_WIDTH+1)) ""
					fi
					draw_vanish_banner "SAVED"
					tput el
					draw_vanish_indicator
					break
				elif [ "$newchar" == "i" ]; then
					draw_vanish_indicator
					gtts_speak "insert mode"
					break
				fi
			done
			if [ "$quit" == true ]; then
				break
			fi
		elif [ "$char" == $'' ]; then
			if [ "$char_count" -gt "0" ]; then
				newchar="$(echo -ne "$inputnew" | rev | cut -c 1)"
				if [ "$newchar" == " " ]; then
					if [ "$inword" == true ]; then
						inword=false
						word_count=$((word_count-1))
						draw_vanish_indicator
					fi
					preword=true
				elif [ "$newchar" != " " ]; then
					inword=true
				elif [ "$preword" == true ]; then
					inword=true
					preword=false
			fi
			inputnew="$(echo -ne "$inputnew" | rev | cut -c2- | rev)"
			display="$(echo -ne "$display" | rev | cut -c2- | rev)"
			char_count=$((char_count-1))
			draw_vanish_indicator
			if [ "$word" != "" ]; then
				word="$(echo -ne "$word" | rev | cut -c2- | rev)"
			fi
			if [ "${char_count}" -lt "$width" ]; then
				saved_spot=$(((COLUMNS/2)-(char_count/2)-1))
				tput cup $LINES $saved_spot
				echo -ne " "
			fi
			fi
		elif [ "$char" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			espeak-ng -v en-us+m1 " $inputnew" &
			ESPEAK_PID="$!"
		elif [ "$char" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
		else
			char_count=$((char_count+1))
			if [ "$char" == " " ]; then
				preword=false
				inputnew="${inputnew} "
				display="${display} "
				if [ "$feedback_enabled" == true ]; then
					espeak-ng -v en-us+m1 "$word" &
					ESPEAK_PID="$!"
				fi
				if [ "$inspace" == false ]; then
					word_count=$((word_count+1))
				fi
				inspace=true
				word=""
			else
				preword=false
				inputnew="${inputnew}${char}"
				display="${display}${char}"
				if [ "$inspace" == true ]; then
					inspace=false
					inword=true
				fi
				if [ "$char" == "." ] || [ "$char" == "?" ] || [ "$char" == "," ] || [ "$char" == "!" ]; then
					if [ "$feedback_enabled" == true ]; then
						espeak-ng -v en-us+m1 "$word" &
						ESPEAK_PID="$!"
					fi
					word_count=$((word_count+1))
					inword=false
					word=""
				else
					word="$word$char"
				fi
			fi
		fi
		newdisplay="$(echo -ne "$display" | tail -c $width)"
		tput sc
		if [ "${char_count}" -le "$width" ]; then
			saved_spot=$(((COLUMNS/2)-(char_count/2)))
			tput cup $LINES $saved_spot
		else
			saved_spot=$(((COLUMNS/2)-(width/2)))
			tput cup $LINES $saved_spot
		fi
		echo -ne "$WHITE${newdisplay}${BLUE}_ \b"
		draw_vanish_indicator
		tput rc
	done
}

if [ "$1" == "--vanish" ]; then
	vanish true
	clear
	tput cnorm
	stty echo
	exit 0
fi

if [ "$LINES" -lt "7" ] || [ "$COLUMNS" -lt "33" ]; then
	if [ "$BYPASS_WARNING" != true ]; then
		echo -e "${RED}Error:${NOCOLOR} Terminal dimensions too small (Requires >= 33x7)"
		sleep 5
	fi
fi

REPEAT_HELP="Loop Controls
6  Switch Loops
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
S  Start -0.01
F  Start +0.01
s  Start -0.05
f  Start +0.05
H  End -0.01
L  End +0.01
h  End -0.05
l  End +0.05
,  Gap -1
.  Gap +1
e  Play Transition
^H  Seek to Start
5  Start Position
7  End Position"

SETUP_HELP="#  Save Settings
Voice Controls
d  Toggle Voice
Voice Volume Settings
8  Volume Down
9  Volume Up
Voice Pitch Settings
J  Down
K  Up
Metadata Cache
c  Cache Tags
^T  Toggle Tags
Customization
^A  Select Theme
^P  Toggle Panels
^D  Toggle Dark Mode
^O  Invert Color
^Y  Toggle Color"


QUEUE_HELP="Queue Controls
j  Page Down
k  Page Up
h  Selection Down
l  Selection Up
x  Remove Song
<  Move Song Up
>  Move Song Down
s  Keyword Search
d  Speak Controls"

SCALE_HELP="Scale Controls
j  Scale Down
k  Scale Up
o  Double EDO
m  Halve EDO
c  Reverse Direction
y  $DEFAULT_EDO-EDO
v  Toggle Pitch"

HELP="Basic Controls
i  Menu
?  Key Controls
j  Page Down
k  Page Up
;  Queue
p  Pause
n  Next Song
b  Previous Song
m  Man Page
q  Quit
Voice Feedback
d  Toggle Voice
T  Feedback Level
#  Save Settings
^K  Read Interval
I  Read Corner
,  Read Title
^S  Read Lock Status
Volume Controls
*  1% Down
(  1% Up
8  3% Down
9  3% Up
!  PCM 1% Down
@  PCM 1% Up
1  PCM 5% Down
2  PCM 5% Up
c  Mute
3  Fade Up/Down
Interval Controls
j  Pitch Down
k  Pitch Up
x  Lock/Unlock
m  Half EDO
o  Double EDO
.  Set INT
/  Set EDO
w  Reset to Locked
H  Least Precise
L  Fully Precise
J  EDO Down
K  EDO Up
y  $DEFAULT_EDO-EDO
4  Reset INT/EDO
^U  Toggle Locked
Pitch Jump Controls
_  Octave Down
+  Octave Up 
M  Inverse INT
Y  Zero INT
Pitch Fade Controls
X  Scale Speed
t  Zero INT
u  INT Up/Down
U  EDO Up/Down
-  Octave Down
=  Octave Up
g  Inverse INT
G  Oscillate
Balance Controls
{  1% Left Up
}  1% Right Up
[  1% Left Down
]  1% Right Down
0  Reset Fade
)  Reset
Track Controls
h  Seek Backward
l  Seek Forward
b  Queue Backward
n  Queue Forward
p  Pause
\\  Restart 
r  Rename
D  Delete
P  Progress Bar
a  Equalizer
Queue Controls
;  Queue
O  Edit
R  Shuffle
A  Sort
\"  Last of Artist
'  First of Artist
N  Next Artist
B  Previous Artist
Z  Export As
e  Loop Toggle
$  Only Locked
^R  Random Mode
Loop Toggle Controls
E  Loop Song
V  Loop Artist
Search Controls
S  New Search
s  Jump To
^F  Add Songs
Loop Editor Controls
5  Start Position
7  End Position
6  Enter Loop 
6  Switch Loops
&  Lock New Loop
^X  Update Loop
%  Remove Loop
Z  Export Loop
^L  Exported Loop
^E  Play Only Loops
$  Save Position
^H  Seek to Position 
Video Controls
<  Enable Video
>  Fullscreen Video
Download Controls
W  Add Downloads
^W  Jump Downloads
^N  Add and Jump
Advanced Controls
^A  Select Theme
^P  Toggle Panels
^D  Toggle Dark Mode
^O  Invert Color
^Y  Toggle Color
z  Redraw Screen
~  Sleep mode
|  Vanish Editor"

HELP_LENGTH="$(echo -e "$HELP" | wc -l)"
SETUP_HELP_LENGTH="$(echo -e "$SETUP_HELP" | wc -l)"
SCALE_HELP_LENGTH="$(echo -e "$SCALE_HELP" | wc -l)"
REPEAT_HELP_LENGTH="$(echo -e "$REPEAT_HELP" | wc -l)"
QUEUE_HELP_LENGTH="$(echo -e "$QUEUE_HELP" | wc -l)"

export HELP_LENGTH
export SETUP_HELP_LENGTH
export SCALE_HELP_LENGTH
export REPEAT_HELP_LENGTH
export QUEUE_HELP_LENGTH

espeak_say() {
	if [ "$VOICE_ENABLED" == true ] || [ "$2" == true ]; then
		kill "$ESPEAK_PID" >/dev/null 2>/dev/null
		if [ "$3" == true ] && [ "$1" != " " ]; then
			espeak-ng -v en-us+m1 " $1"
		elif [ "$1" != " " ]; then
			espeak-ng -v en-us+m1 " $1" &
		fi
		ESPEAK_PID="$!"
		if [ "$4" == true ]; then
			echo -ne "$ESPEAK_PID" >"$ALETHEIA/espeak.pid"
		fi
	fi
}

draw_banner() {
	if [ "$3" != true ]; then
		LEFT_BANNER_WIDTH="$((${#i}+2))"
	else
		RIGHT_BANNER_WIDTH="$((${#i}+2))"
	fi
	if [ "$2" != true ]; then
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length="$POSITION_WIDTH"
		warning=false
	else
		COLOR1="$WHITE_BLACK"
		COLOR2="$BLUE_BLACK"
		length=12
		warning=true
	fi
	
	if [ "$3" == false ] || [ "$3" == "" ]; then
		tput cup $LINES
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1$COLOR1 --$COLOR2 "
		tput sc
		if [ "$RIGHT_BANNER_WIDTH" != "0" ]; then
			if [ "$4" == true ]; then
				length="$RIGHT_BANNER_WIDTH"
			fi
		fi
		if [ "$((${#1} + 6 + RIGHT_BANNER_WIDTH + (${#PADDING}*2)))" -lt "$COLUMNS" ]; then
			printf '%*s' $((COLUMNS - ${#1} - 7 - (${#PADDING}*2) - length)) ""
		fi
	else
		tput cup $LINES $((COLUMNS - ${#1} - 8))
		echo -ne "$BLUE_BLACK$PADDING$COLOR1-- ${COLOR2}$1$COLOR1 --$COLOR1 "
		RIGHT_BANNER_WIDTH=$((${#1}+6))
	fi

	if [ "$warning" == true ]; then
		echo -ne "$COLOR1${COLOR2}y${COLOR1}: ${WHITE_BLACK}yes $COLOR1${COLOR2}n${COLOR1}: ${WHITE_BLACK}no$PADDING"
	fi

	if [ "$4" != true ]; then
		if [ "$3" != true ]; then
			tput rc
		fi
	fi
}

set_loop() {
	local force_enable=$1
	if [ "$LOOP" == false ] || [ "$force_enable" == true ]; then
		gtts_speak "loop song"
		LOOP=true
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		ONLY_LOCKED=false
		echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
		draw_banner "LOOP SONG"
	else
		gtts_speak "loop off"
		LOOP=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_loop_artist() {
	local force_enable=$1
	if [ "$LOOP_ARTIST" == false ] || [ "$force_enable" == true ]; then
		if [ "$USE_TAGS" == true ]; then
			get_metadata "$POSITION" >/dev/null
			if [ "$artist" != "" ]; then
				LOOP_ARTIST_NAME="${artist,,}"
				LOOP=false
				LOOP_ARTIST=true
				TRACK_RANDOM=false
				ONLY_LOCKED=false
				gtts_speak "loop artist"
				draw_banner "LOOP ARTIST"
			fi
		else
			if [[ "$TITLE" == *" - "* ]]; then
				LOOP=false
				LOOP_ARTIST=true
				TRACK_RANDOM=false
				ONLY_LOCKED=false
				LOOP_ARTIST_NAME="${TITLE%% - *}"
				LOOP_ARTIST_NAME="${LOOP_ARTIST_NAME,,}"
				gtts_speak "loop artist"
				draw_banner "LOOP ARTIST"
			fi
		fi
	else
		gtts_speak "loop off"
		LOOP=false
		LOOP_ARTIST=false
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "RESET"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_random() {
	if [ "$TRACK_RANDOM" == false ]; then
		gtts_speak "random mode"
		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=true
		ONLY_LOCKED=false
		draw_banner "RANDOM MODE"
		reset_buffer
		redraw_buffer
	else
		gtts_speak "random mode off"
		TRACK_RANDOM=false
		draw_banner "RANDOM OFF"
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

set_only_locked() {
	if [ "$ONLY_LOCKED" == false ] || [ "$1" == true ]; then
		if [ "$3" != true ]; then
			gtts_speak "only locked"
		fi

		LOOP=false
		LOOP_ARTIST=false
		TRACK_RANDOM=false
		if [ "$5" != true ]; then
			ONLY_LOCKED=true
		fi
		if [ "$4" != true ]; then
			if [ "$PICK" == "" ]; then
				old_queue_array=("${queue_array[@]}")
				regex=".*\.\(${AUDIO_FORMATS//,/\.locked\\|})\.locked\)$"
				unset queue_array
				IFS=$'\n'
				index=0
				for i in $(find "$MUSICDIR" -type f -regex "$regex" | shuf); do
					if [ "$(echo -ne "$i" | grep '.repeat.')" == "" ]; then
						queue_array[index]="${i%.*}"
						index=$((index+1))
					fi
				done
				unset IFS
				if [ "$index" == "0" ]; then
					queue_array=("${old_queue_array[@]}")
					unset old_queue_array
					return 50
				else
					TOTAL_QUEUE=$index
				fi
					
			else
				unset queue_array
				c=$'\n'
				IFS=$'\n'
				index=0
				for i in $(printf '%s\n' "${queue_array[@]}"); do
					if [ -e "$i.locked" ]; then
						new_queue_array[$index]="$i"
						index=$((index+1))
					fi
				done
				unset IFS
				queue_array=("${new_queue_array[@]}")
				TOTAL_QUEUE=$((index-1))
			fi
			if [ -e "$FILENAME.locked" ]; then
				new_list=""
				minusone=0
				IFS=$'\n'
				o_list="$FILENAME$IFS"
				for i in $(seq 1 $TOTAL_QUEUE); do
					if [ "$i" != "$POSITION" ]; then
						new_list="$new_list${queue_array[$((i-1-minusone))]}$IFS"
					else
						minusone=1
					fi
				done
				new_list="$(echo -ne "$new_list" | grep -v "$FILENAME" | shuf)"
				o_list="$o_list$new_list"
				index=0
				for i in $(echo -ne "$o_list"); do
					queue_array[$index]="$i"
					index=$((index+1))
				done
				unset IFS
				POSITION=1
				ret=false
				flagp=true
			else
				JUMP=1
				ret=true
				flagp=false
			fi

			if [ "$flagp" == false ]; then
				POSITION=0
				tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1 | head -1)"
				if [ "$tmp" != "" ]; then
					POSITION="$tmp"
				fi
			fi
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			if [ "$5" != true ]; then
				draw_banner "ONLY LOCKED"
			fi
			reset_buffer
			redraw_buffer
			if [ "$ret" == true ]; then
				return 200
			fi
		else
			return 200
		fi
	elif [ "$2" == true ]; then
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	elif [ "$3" == true ]; then
		ONLY_LOCKED=false
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	else
		gtts_speak "all"
		ONLY_LOCKED=false
		draw_banner "RESET"
		queue_array=("${old_queue_array[@]}")
		TOTAL_QUEUE=${#queue_array[@]}
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		POSITION="$tmp"
		reset_buffer
		redraw_screen
	fi
	sleep $BANNER_WAIT_TIME
	draw_pitch
	draw_position
}

track_toggle() {
	if [ "$LOOP" == false ] && [ "$LOOP_ARTIST" == false ]; then
		set_loop true
	elif [ "$LOOP_ARTIST" == false ]; then
		echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		set_loop_artist true
	else
		gtts_speak "reset"
		LOOP=false
		LOOP_ARTIST=false
		draw_banner "RESET"
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
	fi
}

about() {
	echo -ne "$NOCOLOR"
	draw_banner "ABOUT"
	tput cup $LINES $((COLUMNS-${#PADDING}))
	echo -ne "$BLUE_BLACK${PADDING}"
	empty_pane
	lines_divided=$((LINES/2))
	cols_divided=$((COLUMNS/2))

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
		pad="_"
	else
		even=false
		pad=""
	fi
	if [ "$even" == true ]; then
		tput cup $((lines_divided-2)) $(((COLUMNS/2) - 4))
	else
		tput cup $((lines_divided-2)) $(((COLUMNS/2) - 3))
	fi
	echo -ne "${WHITE}aletheia${BLUE}_"
	tput sc

	tput cup $lines_divided $(((COLUMNS/2) - 7))
	if [ "$even" == true ]; then
		echo -ne "${WHITE}GPL${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2023"
		tput cup $((lines_divided+2)) $((cols_divided - 3))
	else
		echo -ne "${WHITE}GPL ${BLUE}3 ${WHITE}2021${BLUE}-${WHITE}2023"
		tput cup $((lines_divided+2)) $((cols_divided - 2))
	fi
	if [ "$even" == true ]; then
		echo -ne "${BLUE}v"
	fi
	echo -ne "$(echo -ne "$WHITE$VERSION" | sed "s/\./$(echo -ne "$BLUE").$(echo -ne "$WHITE")/g")"
	tput cup $((lines_divided-2)) $((cols_divided - 4))
}

set_scale_speed() {
	local reset=false
	tmp=""
	if [ "$SCALE_SPEED" != "$DEFAULT_SCALE_SPEED" ]; then
		reset=true
		draw_banner "RESET"
		stty -echo
		sleep $BANNER_WAIT_TIME
		stty echo
		draw_pitch
		draw_position		
		tmp="$DEFAULT_SCALE_SPEED"
	else
		gtts_speak "set scale speed"
		draw_banner "SPEED"
	fi

	if [ "$tmp" == "" ]; then
		tmp="$(read_line)"
	fi

	if [ "$(isnum "$tmp")" != "0" ]; then
		SCALE_SPEED=$tmp
		gtts_speak "scale speed set"
	else
		draw_pitch
		gtts_speak "closed" true
		return
	fi

	if [ "$reset" == true ]; then
		gtts_speak "speed reset"
	fi
	draw_pitch
}

less_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$EDO" -gt "$LOCKED_EDO" ]; do
		INTERVAL="$((INTERVAL/2))"
		EDO="$((EDO/2))"
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		sleep 0.01
	done
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	gtts_speak "less precise"
}

more_precise() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		MUTE=false
		echo "mute" >"$ALETHEIA/pipe$$" &
	fi
	while [ "$EDO" -lt "$EDO_LIMIT" ]; do
		if [ "$INTERVAL" -lt "$EDO_LIMIT" ]; then
			INTERVAL="$((INTERVAL*2))"
			EDO="$((EDO*2))"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			sleep 0.01
		else
			break
		fi
	done
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	draw_pitch
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	gtts_speak "precise"
}

zero_interval_jump() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$INTERVAL" != "0" ]; then
		SAVED_INTERVAL="$INTERVAL"
		SAVED_EDO="$EDO"
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$SAVED_EDO"
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			INTERVAL="$SAVED_INTERVAL"
			EDO="$SAVED_EDO"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		else
			return
		fi
	fi
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	draw_pitch
}

draw_loop() {
	tput cup $LINES $((COLUMNS-RIGHT_BANNER_WIDTH-${#PADDING}))
	echo -ne "$BLUE_BLACK$START_MARKER$WHITE_BLACK:$BLUE_BLACK$END_MARKER$WHITE_BLACK:$BLUE_BLACK$space$PADDING"
}

repeat() {
	echo -e "pausing_keep loop 0 1" >"$ALETHEIA/pipe$$" &
	echo "get_time_length" >"$ALETHEIA/pipe$$" &
	sleep $MPLAYER_WAIT_TIME
	TOTAL_TIME="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d '=' -f2)"
	if [ "$(isnum "$TOTAL_TIME")" == "0" ] || [ "$(echo -e "$TOTAL_TIME < 0.1" | bc)" == "1" ]; then
		TOTAL_TIME=0.1
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	if [ "$REPEAT_ONLY" == false ]; then
		gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
	fi
	if [ "$END_TIME" == "" ]; then
		if [ "$REPEATS" != "" ]; then
			repeats=$REPEATS
			START_MARKER="$(echo -ne "$repeats" | head -1 | cut -d '/' -f1)"
			if [ "$(isnum "$START_MARKER")" == "0" ] || [ "$(echo -e "$START_MARKER < 0" | bc)" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_START_MARKER=$START_MARKER
			if [ "$START_MARKER" == "" ]; then
				START_MARKER=0.0
			fi
			END_TIME="$(echo -ne "$repeats" | head -1 | cut -d '/' -f2)"
			if [ "$(isnum "$END_TIME")" == "0" ] || [ "$(echo -e "$END_TIME < 0" | bc)" == "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_END_TIME=$END_TIME
			if [ "$END_TIME" == "" ]; then
				END_TIME=5.0
			fi
			space="$(echo -ne "$repeats" | head -1 | cut -d '/' -f3 | cut -d'.' -f1)"
			if [ "$(isnum "$space")" != "1" ]; then
				gtts_speak "loop file error"
				draw_banner "ERROR"
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				return 200
			fi
			orig_space=$space
			if [ "$space" == "" ]; then
				space=0
			fi
		else
			REPEAT_ONLY=false
			draw_banner "NO LOOPS"
			gtts_speak "no loops"
			sleep $BANNER_WAIT_TIME
			draw_pitch
			draw_position
			if [ "$LOOP" == false ]; then
				echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
			fi
			return 200
		fi
	fi
	if [ "$END_TIME" != "" ]; then
		END_MARKER=$END_TIME
		date_time=$(/usr/bin/time -p date +%s.%N 2>&1 | head -1)
		date_time=$(calc "$date_time/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		timespent_timed=$(/usr/bin/time -p calc "10 + (1687968170.908741168-1687968192.276557242) * (0.35) + ($date_time * 0.35)" 2>&1 | head -1)
		timespent_timed=$(calc "$timespent_timed/1000000000000" | sed -e "s/\t//g" | cut -d'~' -f2)
		old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g" | cut -d'~' -f2)"
		s="$(calc "1/(2^($INTERVAL/$EDO))" | sed -e "s/\t//g" | cut -d'~' -f2)"
		orig_old_s=$old_s
		time="$(calc "($END_TIME-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)"
		input_char=""
		START_MARKER="$(printf '%.2f' $START_MARKER)"
		END_MARKER="$(printf '%.2f' $END_MARKER)"
		RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
		if [ "$REPEAT_TOTAL" == "0" ]; then
			draw_banner "LOOP 0/$REPEAT_TOTAL"
		else
			draw_banner "LOOP 1/$REPEAT_TOTAL" false false true
		fi
		draw_loop
		scale=false
		until [ "$input_char" == "q" ] || [ "$input_char" == "" ]; do
			if [ "$input_char" == "" ]; then
				timespent=0
				x=0
				if [ "$input_char" == "" ]; then
					if [ "$space" -gt "0" ]; then
						echo -e "pause" >"$ALETHEIA/pipe$$" &
						read -rsn1 -t "$(calc "$space/20" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char
						echo -e "pause" >"$ALETHEIA/pipe$$" &
					fi
				fi
				if [ "$input_char" != "" ]; then
					continue
				fi
				echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
				time_before=$(date +%s.%N)
				if [ "$scale" == true ]; then
					num="$(echo -ne "$time" | cut -d'.' -f1)"
					skip=false
					while [ "$num" -gt "0" ]; do
						old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
						if [ "$skip" == false ]; then
							if [ "$scale_down" == true ]; then
								INTERVAL=$((INTERVAL-1))
							elif [ "$scale_down" == false ]; then
								INTERVAL=$((INTERVAL+1))
							fi
						fi
						old_time_before=$time_before
						time_before=$(date +%s.%N)
						if [ "$skip" == false ]; then
							echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						else
							skip=false
						fi
						time_after=$(date +%s.%N)
						draw_pitch
						orig_old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
						time_x=$(date +%s.%N)
						timespent="$(calc "$timespent +($time_before-$old_time_before)*($old_s)+($time_x-$time_after)*($orig_old_s)+($date_time*2)*$old_s+($date_time*2)*$orig_old_s+$timespent_timed" | sed -e "s/\t//g" | cut -d'~' -f2)"
						s=$orig_old_s
						old_s=$s
						s="$(calc "1/$s" | sed -e "s/\t//g" | cut -d'~' -f2)"

						time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)
						numberz=$(calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2)
						if [ "$(echo "$numberz <= 0" | bc)" == "1" ]; then
							numberz=0
						fi
						if [ "$(echo -e "$numberz >= 0" | bc)" == "1" ]; then
							if [ "$numberz" == "0" ]; then
								input_char=""
								skip=true
							else
								if [ "$(echo "($numberz/$num) < 1" | bc)" == "1" ]; then
									skip=true
								fi
								time_y=$(date +%s.%N)
								timespent="$(calc "$timespent + (($time_y-$time_x) * ($old_s)) + ($date_time * $old_s)" | sed -e "s/\t//g" | cut -d'~' -f2)"
								if [ "$WEB_CLIENT" == "0" ]; then
									read -rsn1 -t "$(echo "$numberz/$num" | bc)" input_char
								else
									read -rsn1 -t "$(echo "$numberz/$num" | bc)" input_char <"$ALETHEIA/web_client_pipe$$"
								fi
								time_after=$(date +%s.%N)
							fi
						fi
						if [ "$input_char" != "" ]; then
							if [ "$input_char" == "q" ] || [ "$input_char" == "u" ] || [ "$input_char" == "" ]; then
								scale=false
								gtts_speak "scale closed"
								draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
								break
							elif [ "$input_char" == "c" ]; then
								if [ "$scale_down" == true ]; then
									scale_down=false
								else
									scale_down=true
								fi
								skip=true
							elif [ "$input_char" == "m" ]; then
								half_precise
								skip=true
							elif [ "$input_char" == "t" ]; then
								set_default_edo
								skip=true
							elif [ "$input_char" == "o" ]; then
								double_precise
								skip=true
							elif [ "$input_char" == "8" ]; then
								system_volume_change false 3 3
								skip=true
							elif [ "$input_char" == "9" ]; then
								system_volume_change true 3 3
								skip=true
							elif [ "$input_char" == "*" ]; then
								system_volume_change false 1 1
								skip=true
							elif [ "$input_char" == "(" ]; then
								system_volume_change true 1 1
								skip=true
							fi
						fi
						num=$((num-1))
					done
				else
					if [ "$(echo "$time <= 0" | bc)" == "1" ]; then
						time=0.01
						END_MARKER="$(echo "$START_MARKER+0.01" | bc)"
					fi
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$time" input_char
					else
						read -rsn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				time_after=$(date +%s.%N)
			fi
			if [ "$input_char" == "" ]; then
				continue
			fi
			if [ "$input_char" == "l" ] || [ "$input_char" == "h" ] || [ "$input_char" == "L" ] || [ "$input_char" == "H" ]; then
				case $input_char in
				'l')
					if [ "$(echo -e "($END_MARKER+0.05)<$TOTAL_TIME" | bc)" == "1" ]; then
						END_MARKER=$(calc "$END_MARKER+0.05" | sed -e "s/\t//g")
					else
						END_MARKER=$TOTAL_TIME
					fi
					;;
				'h')
					if [ "$(echo -e "(($END_MARKER-0.05) > $START_MARKER)" | bc)" == "1" ]; then
						END_MARKER=$(calc "$END_MARKER-0.05" | sed -e "s/\t//g")
					fi
					;;
				'L')
					if [ "$(echo -e "($END_MARKER < $TOTAL_TIME-0.05)" | bc)" == "1" ]; then
						END_MARKER=$(calc "$END_MARKER+0.01" | sed -e "s/\t//g")
					fi
					;;
				'H')
					if [ "$(echo -e "($END_MARKER > $START_MARKER+0.05)" | bc)" == "1" ]; then
						END_MARKER=$(calc "$END_MARKER-0.01" | sed -e "s/\t//g")
					fi
					;;
				esac

				time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)

				START_MARKER="$(printf '%.2f' "$START_MARKER")"
				END_MARKER="$(printf '%.2f' "$END_MARKER")"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop

				if [ "$(echo -e "$(calc "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$time" input_char
					else
						read -rsn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char
					else
						read -rsn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "s" ] || [ "$input_char" == "f" ] || [ "$input_char" == "S" ] || [ "$input_char" == "F" ]; then
				case $input_char in
				's')
					if [ "$(echo -e "(($START_MARKER-0.05) >= 0.0)" | bc)" == "1" ]; then
						START_MARKER=$(calc "$START_MARKER-0.05" | sed -e "s/\t//g")
					fi
					;;
				'f')
					if [ "$(echo -e "(($START_MARKER+0.05) < $END_MARKER)" | bc)" == "1" ]; then
						START_MARKER=$(calc "$START_MARKER+0.05" | sed -e "s/\t//g")
					fi
					;;
				'S')
					if [ "$(echo -e "(($START_MARKER-0.01) >= 0.0)" | bc)" == "1" ]; then
						START_MARKER=$(calc "$START_MARKER-0.01" | sed -e "s/\t//g")
					fi
					;;
				'F')
					if [ "$(echo -e "(($START_MARKER+0.01) <= ($END_MARKER-0.05))" | bc)" == "1" ]; then
						START_MARKER=$(calc "$START_MARKER+0.01" | sed -e "s/\t//g")
					fi
					;;
				esac
				truth="$(echo "$START_MARKER < 0.0" | bc)"
				if [ "$truth" == "1" ]; then
					START_MARKER="0.0"
				fi
				time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)
				START_MARKER="$(printf '%.2f' "$START_MARKER")"
				END_MARKER="$(printf '%.2f' "$END_MARKER")"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "d" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				toggle_voice
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "" ] || [ "$input_char" == "\\" ]; then
				input_char=""
				flagged=false
			elif [ "$input_char" == "u" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				gtts_speak "scale"
				draw_banner "SCALE"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$scale" == true ]; then
					scale=false
					if [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					fi
				else
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rsn1 inputchar
					else
						read -rsn1 inputchar <"$ALETHEIA/web_client_pipe$$"
					fi
					if [ "$inputchar" == "j" ]; then
						scale_down=true
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "k" ]; then
						scale_down=false
						scale=true
						input_char=""
						gtts_speak "scaling"
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=false
					elif [ "$inputchar" == "u" ] || [ "$inputchar" == "q" ] || [ "$inputchar" == "" ]; then
						gtts_speak "scale closed"
						draw_pitch
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
						flagged=true
					fi
				fi
			elif [ "$input_char" == "q" ]; then
				draw_pitch
				draw_position
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "a" ]; then
				toggle_pause
				set_equalizer
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "T" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				set_only_display_song
				redraw_buffer
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				load_loop_file
				if [ "$?" != "1" ]; then
					draw_pitch
					draw_position
					REPEAT_ONLY=false
					return 200
				fi
				flagged=true
			elif [ "$input_char" == "Z" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "WAIT" false false true
				gtts_speak "wait"
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				rm -f "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
				rm -f "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
				ffmpeg -i "$FILENAME" -ss "$START_MARKER" -t "$(calc "$END_MARKER-$START_MARKER+0.265")" -c copy "$filename_without_ext.repeat0.$ext" >/dev/null 2>/dev/null
				sox "$filename_without_ext.repeat0.$ext" "$filename_without_ext.repeat1.$ext" trim 0 -0.180 >/dev/null 2>/dev/null
				delay="$(echo "($space/20)" | bc)"
				ffmpeg -i "$filename_without_ext.repeat1.$ext" -af "apad=pad_dur=$delay" "$filename_without_ext.repeat.$ext" >/dev/null 2>/dev/null
				rm -f "$filename_without_ext.repeat0.$ext"
				rm -f "$filename_without_ext.repeat1.$ext"
				cp "$FILENAME.locked" "$filename_without_ext.repeat.$ext.locked" >/dev/null 2>/dev/null
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				gtts_speak "finished"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				if [ "$NO_VERTICAL_PADDING" == true ]; then
					tput cup $((LOCKING_POS+1)) 1
				else
					tput cup $((LOCKING_POS+2)) 1
				fi
				if [ -e "$FILENAME.locked" ]; then
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "$BLUE_BLACK${REP}$"
					fi
				else
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "${WHITE_BLACK} "
					fi
				fi
				flagged=true
			elif [ "$input_char" == "A" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				sort_queue
				SHUFFLED=false
				flagged=true
			elif [ "$input_char" == "R" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				shuffle_queue
				SHUFFLED=true
				flagged=true
			elif [ "$input_char" == "I" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				read_corner
				if [ "$REPEAT_ONLY" == true ]; then
					gtts_speak "back. playlist loop mode"
				else
					gtts_speak "back. loop editor"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "Y" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				zero_interval_jump
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				input_char=""
				flagged=false
			elif [ "$input_char" == "w" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				reset_to_locked
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_pitch
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "q" ] || [ "$input_char" == "" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				draw_pitch
				draw_position
				REPEAT_ONLY=false
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				return 200
			elif [ "$input_char" == "W" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				add_downloaded "noposition"
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					gtts_speak "playing downloaded"
					JUMP="$DOWNLOAD_POSITION"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
				fi
				flagged=true
			elif [ "$input_char" == "?" ]; then
				toggle_pause true
				RIGHT_BANNER_WIDTH="$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))"
				draw_banner "HELP" false false true
				tput cup $LINES $((COLUMNS-12))
				echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
				loop_help_screen
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				toggle_pause true
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				redraw_buffer
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "i" ]; then
				toggle_pause true
				POSITION_WIDTH=$RIGHT_BANNER_WIDTH
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					JUMP="1"
					return $RETURN_JUMP
				fi
				toggle_pause true
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				flagged=true
			elif [ "$input_char" == "M" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				orig_orig_old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
				INTERVAL="$((-(INTERVAL)))"
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				orig_old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
				draw_pitch
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				switch=true
				flagged=true
			elif [ "$input_char" == "v" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				toggle_scale_tempo
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "z" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_wait false
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				reset_dimensions
				draw_volume
				draw_equalizer
				reset_buffer
				redraw_buffer
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "," ]; then
				if [ "$space" -gt "0" ]; then
					space=$((space-1))
				fi
				gtts_speak "$space"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "$(echo -e "$(calc "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char
					else
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "." ]; then
				space=$((space+1))
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				gtts_speak "$space"
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				if [ "$(echo -e "$(calc "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char
					else
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "k" ] || [ "$input_char" == "j" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				orig_orig_old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
				if [ "$input_char" == "k" ]; then
					pitch_up true
				else
					pitch_down true
				fi
				orig_old_s="$(calc "(2^($INTERVAL/$EDO))" | sed -e "s/\t//g")"
				switch=true
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				flagged=true
			elif [ "$input_char" == "2" ] || [ "$input_char" == "1" ] || [ "$input_char" == "!" ] || [ "$input_char" == "@" ] || [ "$input_char" == "9" ] || [ "$input_char" == "8" ] || [ "$input_char" == "*" ] || [ "$input_char" == "(" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$input_char" == "2" ]; then
					if [ "$VOLUME" -le "95" ]; then
						VOLUME=$((VOLUME+5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "1" ]; then
					if [ "$VOLUME" -ge "5" ]; then
						VOLUME=$((VOLUME-5))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "@" ]; then
					if [ "$VOLUME" -le "99" ]; then
						VOLUME=$((VOLUME+1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "!" ]; then
					if [ "$VOLUME" -ge "1" ]; then
						VOLUME=$((VOLUME-1))
						echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
						draw_volume
					fi
					gtts_speak "$VOLUME"
				elif [ "$input_char" == "8" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change false 3 3
				elif [ "$input_char" == "9" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change true 3 3
				elif [ "$input_char" == "*" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change false 1 1
				elif [ "$input_char" == "(" ]; then
					PAUSE=false
					if [ "$MUTE" == true ]; then
						echo "mute" >"$ALETHEIA/pipe$$" &
						MUTE=false
						draw_pitch
					fi
					system_volume_change true 1 1
				fi
				flagged=true
			elif [ "$input_char" == "6" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" == "1" ]; then
					flagged=true
					gtts_speak "no more loops"
				else
					if [ "$REPEATS" != "" ]; then
						REPEAT_CURRENT=$((REPEAT_CURRENT+1))
						if [ "$REPEAT_CURRENT" -gt "$REPEAT_TOTAL" ]; then
							REPEAT_CURRENT=1
						fi
						gtts_speak "loop $REPEAT_CURRENT of $REPEAT_TOTAL"
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						orig_START_MARKER=$START_MARKER
						if [ "$START_MARKER" == "" ]; then
							START_MARKER=0.00
						fi
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						orig_END_TIME=$END_MARKER
						if [ "$END_MARKER" == "" ]; then
							END_MARKER=5.00
						fi
						if [ "$START_MARKER" == "$END_MARKER" ]; then
							START_MARKER=0.00
							END_MARKER=5.00
						fi

						START_MARKER="$(printf '%.2f' $START_MARKER)"
						END_MARKER="$(printf '%.2f' $END_MARKER)"
						
						time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
						orig_space=$space
						if [ "$space" == "" ]; then
							space=0
						fi
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
						draw_loop
					else
						gtts_speak "none"
						START_MARKER=0.00
						END_MARKER=5.00
						END_TIME=$END_MARKER
						space=0
						RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					fi
					if [ "$REPEAT_TOTAL" == "0" ]; then
						draw_banner "LOOP 0/$REPEAT_TOTAL"
					else
						draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
					fi
					draw_loop
					input_char=""
					flagged=false
				fi
			elif [ "$input_char" == "e" ]; then
				if [ "$(echo -e "$(calc "$END_MARKER-$START_MARKER") < 1.5" | bc)" == "1" ]; then
					echo "seek $START_MARKER 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$time" input_char
					else
						read -rn1 -t "$time" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				else
					echo "seek $(calc "$END_MARKER-1.5") 2" >"$ALETHEIA/pipe$$" &
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char
					else
						read -rn1 -t "$(calc "1.5*$s" | sed -e "s/\t//g" | cut -d'~' -f2)" input_char <"$ALETHEIA/web_client_pipe$$"
					fi
				fi
				flagged=false
			elif [ "$input_char" == "" ]; then
				load_loop_file
				break
			elif [ "$input_char" == "q" ]; then
				if [ "$LOOP" == false ]; then
					echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
				fi
				break
			elif [ "$input_char" == "5" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d'=' -f2)"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "7" ]; then
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_MARKER="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d'=' -f2)"
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "n" ]; then
				RIGHT_BANNER_WIDTH=0
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					return $RETURN_NEXT
				fi
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				gtts_speak " $INTERVAL" false false true
				flagged=true
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_ONLY" == false ]; then
					text="LOOP MODE"
					REPEAT_ONLY=true
					RIGHT_BANNER_WIDTH="${#text}"
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_banner "$text" false true
					gtts_speak "playlist loop mode"
					sleep $BANNER_WAIT_TIME
					RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_loop
				else
					text="OFF"
					REPEAT_ONLY=false
					RIGHT_BANNER_WIDTH="${#text}"
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_banner "$text" false true
					gtts_speak "playlist loop mode off"
					sleep $BANNER_WAIT_TIME
					RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
					draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
					draw_loop
				fi
				flagged=true
			elif [ "$input_char" == "b" ]; then
				RIGHT_BANNER_WIDTH=0
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$REPEAT_ONLY" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM_BACK
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST_BACK
					elif [ "$ONLY_LOCKED" == true ]; then
						return $RETURN_ONLY_LOCKED_BACK
					else
						return $RETURN_BACK
					fi
				fi
			elif [ "$input_char" == "y" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				set_default_edo
				time_x=$(date +%s.%N)
				LOCKED=false
				flagged=true
			elif [ "$input_char" == "p" ]; then
				RIGHT_BANNER_WIDTH=$((6+${#REPEAT_CURRENT}+${#REPEAT_TOTAL}))
				toggle_pause
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 input_char
				else
					read -rn1 input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				toggle_pause
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				time_x=$(date +%s.%N)
				flagged=true
			elif [ "$input_char" == "o" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				flagged=true
			elif [ "$input_char" == "m" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false true
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				flagged=true
			elif [ "$input_char" == "x" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				if [ "$NO_VERTICAL_PADDING" == true ]; then
					tput cup $((LOCKING_POS+1)) 1
				else
					tput cup $((LOCKING_POS+2)) 1
				fi
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					gtts_speak "unlocked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "$BLUE_BLACK "
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/1" >"$FILENAME".locked
					else
						echo "$INTERVAL/$EDO/0/0:0:0:0:0:0:0:0:0:0/0" >"$FILENAME".locked
					fi
					LOCKED=true
					gtts_speak "locked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "${WHITE_BLACK}${REP}$"
					fi
				fi
				flagged=true
			elif [ "$input_char" == "%" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEAT_TOTAL" -ge "1" ]; then
					gtts_speak "unlocked $REPEAT_CURRENT"
					draw_banner "UNLOCKED $REPEAT_CURRENT"
					draw_loop
					if [ "$WEB_CLIENT" == "0" ]; then
						read -rn1 -t $BANNER_WAIT_TIME t
					else
						read -rn1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
					fi
					input_char="$t"
					if [ "$REPEAT_TOTAL" == "1" ]; then
						rm -f "$FILENAME.repeats"
						REPEATS=""
						REPEAT_CURRENT=0
						REPEAT_TOTAL=0
					else
						sed -i "${REPEAT_CURRENT}d" "$FILENAME.repeats"
						REPEATS="$(echo -ne "$REPEATS" | sed "${REPEAT_CURRENT}d")"
						REPEAT_TOTAL=$((REPEAT_TOTAL-1))
						REPEAT_CURRENT=$((REPEAT_CURRENT-1))
					fi

					if [ "$REPEAT_TOTAL" == "0" ]; then
						if [ "$NO_VERTICAL_PADDING" == true ]; then
							tput cup $((LOCKING_POS+1)) 1
						else
							tput cup $((LOCKING_POS+2)) 1
						fi
						if [ -e "$FILENAME.locked" ]; then
							echo -ne "${WHITE}$"
						else
							echo -ne "${BLUE} "
						fi
					fi
					if [ "$REPEATS" != "" ]; then
						if [ "$REPEAT_CURRENT" == "0" ]; then
							REPEAT_CURRENT=1
						fi
						START_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f1)"
						END_MARKER="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f2)"
						END_TIME=$END_MARKER
						time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)
						space="$(echo -ne "$REPEATS" | sed -n "${REPEAT_CURRENT}p" | cut -d '/' -f3)"
					fi
				else
					gtts_speak "no repeats"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				input_char=""
				flagged=false
			elif [ "$input_char" == "" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEATS" != "" ]; then
					REPEATS="$(echo -ne "$REPEATS" | sed -e "s/$orig_START_MARKER\/$orig_END_TIME\/$orig_space/$START_MARKER\/$END_MARKER\/$space/g")"
					echo -ne "$REPEATS" >"$FILENAME.repeats"
					gtts_speak "saved loop"
				else
					gtts_speak "no loops"
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "SAVED" false false true
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 -t $BANNER_WAIT_TIME input_char
				else
					read -rn1 -t $BANNER_WAIT_TIME input_char <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL" false false true
				draw_loop
				flagged=true
			elif [ "$input_char" == "&" ]; then
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				if [ "$REPEATS" != "" ]; then
					echo "$START_MARKER/$END_MARKER/$space" >>"$FILENAME.repeats"
					REPEATS="$REPEATS\n$START_MARKER/$END_MARKER/$space"
					REPEAT_CURRENT=$((REPEAT_CURRENT+1))
					REPEAT_TOTAL=$((REPEAT_TOTAL+1))
					gtts_speak "locked $REPEAT_TOTAL"
					if [ "$NO_VERTICAL_PADDING" == true ]; then
						tput cup $((LOCKING_POS+1)) 1
					else
						tput cup $((LOCKING_POS+2)) 1
					fi
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
				else
					REPEATS="$START_MARKER/$END_MARKER/$space$(echo -ne "\n")"
					echo "$START_MARKER/$END_MARKER/$space" >"$FILENAME.repeats"
					gtts_speak "locked"
					if [ "$NO_VERTICAL_PADDING" == true ]; then
						tput cup $((LOCKING_POS+1)) 1
					else
						tput cup $((LOCKING_POS+2)) 1
					fi
					if [ -e "$FILENAME.locked" ]; then
						echo -ne "${WHITE_BLACK}#"
					else
						echo -ne "${WHITE_BLACK}&"
					fi
					REPEAT_CURRENT=1
					REPEAT_TOTAL=$((REPEAT_TOTAL+1))
				fi
				RIGHT_BANNER_WIDTH=$((${#START_MARKER}+${#END_MARKER}+${#space}+(${#CORNER_DIVIDER}*2)))
				draw_banner "LOCKED $REPEAT_TOTAL"
				draw_loop
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rn1 -t $BANNER_WAIT_TIME t
				else
					read -rn1 -t $BANNER_WAIT_TIME t <"$ALETHEIA/web_client_pipe$$"
				fi
				draw_banner "LOOP $REPEAT_CURRENT/$REPEAT_TOTAL"
				draw_loop
				input_char="$t"
				flagged=true
			else
				old_time_before=$time_before
				time_before=$(date +%s.%N)
				process_key "$input_char"
				flagged=true
			fi
			if [ "$flagged" == true ]; then
				time_x=$(date +%s.%N)
				flagged=false
				if [ "$switch" == true ]; then
					switch=false
					timespent="$(calc "$timespent +($time_after-$old_time_before)*($old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*3)*$orig_old_s+($date_time*1)*$orig_orig_old_s" | sed -e "s/\t//g" | cut -d'~' -f2)"
				else
					timespent="$(calc "$timespent +($time_after-$old_time_before)*($orig_old_s)+($time_x-$time_before)*($orig_old_s)+($date_time*4)*$orig_old_s" | sed -e "s/\t//g" | cut -d'~' -f2)"
				fi
				s=$orig_old_s
				old_s=$s
				s="$(calc "1/$s" | sed -e "s/\t//g" | cut -d'~' -f2)"

				time=$(calc "($END_MARKER-$START_MARKER)*($s)" | sed -e "s/\t//g" | cut -d'~' -f2)
				input_char=""
				numberz=$(calc "($time-$timespent*$s)" | sed -e "s/\t//g" | cut -d'~' -f2)
				if [ "$(echo "$numberz <= 0" | bc)" == "1" ]; then
					numberz=0
				fi
				if [ "$(echo -e "$numberz >= 0" | bc)" == "1" ]; then
					if [ "$numberz" == "0" ]; then
						input_char=""
					else
						time_y=$(date +%s.%N)
						time_before=$time_y
						timespent="$(calc "$timespent +(($time_y-$time_x)*($old_s))" | sed -e "s/\t//g" | cut -d'~' -f2)"
						if [ "$WEB_CLIENT" == "0" ]; then
							read -rn1 -t "$numberz" input_char
						else
							read -rn1 -t "$numberz" input_char <"$ALETHEIA/web_client_pipe$$"
						fi
						time_after=$(date +%s.%N)
					fi
				fi
			fi

		done
		scale=false
		REPEAT_ONLY=false
		if [ ! -e "$FILENAME.locked" ]; then
			gtts_speak "loop closed"
		fi

		END_TIME="$END_MARKER"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		if [ "$LOOP" == false ]; then
			echo -e "pausing_keep loop -1 1" >"$ALETHEIA/pipe$$" &
		fi
		return 200
	fi
}

zero_interval() {
	reverse=false
	zero=false
	if [ "$INTERVAL" != "0" ]; then
		draw_banner "ZERO" false true
		zero=true
		SAVED_INTERVAL=$INTERVAL
		SAVED_EDO=$EDO
		gtts_speak "scaling to original pitch"
		old_int="$INTERVAL"
		old_edo="$EDO"
		new_INTERVAL="$DEFAULT_INTERVAL"
		new_EDO="$EDO"
	else
		if [ "$SAVED_INTERVAL" != "" ]; then
			draw_banner "RESET" false true
			gtts_speak "scaling back"
			old_int="0"
			old_edo="$EDO"
			new_INTERVAL="$SAVED_INTERVAL"
			new_EDO="$SAVED_EDO"
			reverse=true
		else
			old_int="0"
			new_INTERVAL="$DEFAULT_INTERVAL"
			new_EDO="$EDO"
		fi
	fi
	
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi

	if [ "$old_int" -gt "$new_INTERVAL" ]; then
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -lt "$old_int" ]; do
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
			elif [ "$c" == "q" ]; then				
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "quit"
				fi
				read -rn1 input_char
				if [ "$input_char" == "y" ]; then
					echo -ne "$NOCOLOR"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					clear
					stty echo
					return $RETURN_QUIT
				elif [ "$input_char" == "q" ]; then
					flaggy=true
					draw_pitch
					break
				fi
			elif [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$((old_int-1))"
				INTERVAL="$((INTERVAL-1))"
				echo -e "speed_set $(calc "2^($old_int/$old_edo)")" >"$ALETHEIA/pipe$$" &
			fi
			draw_pitch 1
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	else
		if [ "$reverse" == true ]; then
			x="$SAVED_INTERVAL"
		else
			x=0
		fi
		flaggy=false
		while [ "$x" -gt "$old_int" ]; do
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch 1
				draw_position
				return
			fi
			secondary_scale_func "$c" "ZERO" true
			if [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				if [ "$zero" == true ]; then
					draw_banner "ZERO" false true
				else
					draw_banner "RESET" false true
				fi
				redraw_screen false 1 1 1 0
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "y" ]; then
				flaggy=true
				draw_pitch
				break
			elif [ "$c" == "" ]; then
				old_int="$((old_int+1))"
				INTERVAL="$((INTERVAL+1))"
				echo -e "speed_set $(calc "2^($old_int/$old_edo)")" >"$ALETHEIA/pipe$$" &
				draw_pitch 1
			fi
		done
		if [ "$flaggy" == false ]; then
			INTERVAL="$new_INTERVAL"
			EDO="$new_EDO"
		fi
	fi
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	LOCKED=false
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

scale_edo() {
	gtts_speak "scale e d o"
	draw_banner "SCALE"
	stopat=""
	read -rsn1 edo_change
	if [ "$edo_change" = "J" ]; then
		if [ "$EDO" -le "2" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=true
		time=2.5
		edo_change="$((EDO-1))"
	elif [ "$edo_change" = "K" ]; then
		if [ "$EDO" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		downwards=false
		time=2.5
		edo_change="$((EDO+1))"
	elif [ "$edo_change" == "j" ]; then
		gtts_speak "scaling"
		downwards=true
		time=$SCALE_SPEED
		edo_change="$((EDO-1))"
	elif [ "$edo_change" == "k" ]; then
		gtts_speak "scaling"
		downwards=false
		time=$SCALE_SPEED
		edo_change="$((EDO+1))"
	elif [ "$edo_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "" ] || [ "$edo_change" == "q" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$edo_change" == "?" ]; then
		scale_help_screen
		draw_pitch
		draw_position
		return
	elif [ "$(isnum "$edo_change")" != "0" ] || [ "$edo_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="$(read_line "$edo_change")"
		if [ "$tmp" -lt "$EDO" ]; then
			if [ "$tmp" -le "0" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=true
			time=$SCALE_SPEED
			edo_change="$((EDO-1))"
		elif [ "$tmp" -gt "$EDO" ]; then
			if [ "$tmp" -ge "2000000" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			downwards=false
			time=$SCALE_SPEED
			edo_change="$((EDO+1))"
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$edo_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		original_edo="$EDO"
		c=""
		flaggy=false
		orig_edo=$EDO
		orig_interval=$INTERVAL
		while [ "$edo_change" != "$original_edo" ]; do
			if [ "$downwards" == true ]; then # && [ "$edo_change" -lt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t "$time" c
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ]; then
					break
				elif [ "$c" == "c" ]; then
					downwards=false
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					edo_change="2000000"
					flaggy=false
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					original_edo="$EDO"
					EDO="$((EDO-1))"
					edo_change="$((edo_change-1))"
					INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
					INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
					if [ "$flaggy" == false ]; then
						temp="$(calc "$orig_edo/$EDO" | cut -d'~' -f2)"
						INTERVAL="$(echo "$orig_interval/$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
					fi
					if [ "$EDO" == "1" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "1" ]; then
					break
				fi

			elif [ "$downwards" == false ]; then # && [ "$edo_change" -gt "$original_edo" ]; then
				draw_pitch 2
				read -rsn1 -t "$time" c
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ]; then
					break
				elif [ "$c" == "c" ]; then
					sleep "$SCALE_SPEED"
					gtts_speak "order reversed"
					original_edo="$EDO"
					flaggy=false
					downwards=true
					edo_change="1"
				elif [ "$c" == "j" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "k" ]; then
					orig_interval=$INTERVAL
					orig_edo=$EDO
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					original_edo=$EDO
					EDO="$((EDO+1))"
					edo_change=$((edo_change+1))

					INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
					INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)

					if [ "$flaggy" == false ]; then
						temp="$(calc "$EDO/$orig_edo" | cut -d'~' -f2)"
						INTERVAL="$(echo "$orig_interval*$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
					fi

					if [ "$INTERVAL" == "0" ]; then
						flaggy=true
					fi
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch 2
				fi
				if [ "$EDO" == "$stopat" ]; then
					break
				fi
				if [ "$EDO" == "2000000" ]; then
					break
				elif [ "$EDO" == "0" ]; then
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

draw_menu() {
	menu_buf="$PADDING$(tput el; tput cuf $((COLUMNS/2-5-moveleft)))$COLOR_ACCENT$TOP_BAR_MENU$(tput el)"
	if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
		menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk${LINE_CHAR_END}$(tput el)"
	fi

	for i in $(seq 1 "$TOTAL_OPTS"); do
		pad="  "
		temp="${#OPT[$i]}"
		while [ "$temp" -le "$pad_" ]; do
			pad="$pad "
			temp="$((temp+1))"
		done
		if [ "${OPT[$i]}" == "Music" ]; then #|| [ "${OPT[$i]}" == "Sound" ] || [ "${OPT[$i]}" == "Video" ]; then
			arrow=" ›"
		else
			arrow="  "
		fi
		if [ "$i" = "$SELECTION" ]; then
			if [ "${#OPT[$i]}" -lt "5" ]; then
				pad=" "
			else
				pad=""
			fi
			menu_buf="$menu_buf\n$PADDING$COLOR_ACCENT$(tput el; tput cuf $((COLUMNS/2-5-moveleft)))$BAR$BLUE_BLACK ${OPT[$i]}$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR$(tput el)"
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$SELECTION" == "1" ]; then
					if [ "$MUSIC_SELECTION" == "1" ] && [ "$i" == "1" ]; then
						menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					elif [ "$i" == "1" ]; then
						menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					fi
				fi
			fi
			if [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [ "$SELECTION" == "1" ]; then
					menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk$LINE_CHAR_END$(tput el)"
				elif [ "$SELECTION" == "2" ]; then
					if [ "$SOUND_SELECTION" == "1" ] && [ "$i" == "2" ]; then
						menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					elif [ "$i" == "2" ]; then
						menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					fi
				fi
			fi
			if [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$i" == "2" ]; then
					menu_buf="$menu_buf\b${LINE_CHAR}wqqqqqqqk$LINE_CHAR_END$(tput el)"
				elif [ "$i" == "3" ] || [ "$i" == "4" ]; then
					if [ "$VIDEO_SELECTION" == "1" ] && [ "$i" == "3" ]; then
						menu_buf="${menu_buf}${BLUE_BLACK} Loops $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					elif [ "$i" == "3" ]; then
						menu_buf="${menu_buf}$WHITE Loops $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					fi
				fi
			fi
			if [ "$tagged" == false ] || [ "$tagged" == "" ]; then
				if [ "$nospeak" == false ]; then
					if [ "$menu_start_over" == true ]; then
						if [ "$SKIP_SPEAK_MENU" != true ]; then
							if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
								gtts_speak "menu, ${OPT[i]}, ${OPT_MUSIC_SUBMENU[MUSIC_SELECTION]}" false false false false true
							elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
								gtts_speak "${OPT[i]} ${OPT_MUSIC_SUBMENU[SOUND_SELECTION]}"
							elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
								gtts_speak "${OPT[i]} ${OPT_MUSIC_SUBMENU[VIDEO_SELECTION]}"
							else
								if [ "${OPT[i]}" == "Setup" ]; then
									opt="settings"
								else
									opt="${OPT[i]}"
								fi
								gtts_speak "menu, $opt" false false false false true
							fi
						fi
						menu_start_over=false
					else
						if [ "$NO_QUEUE_FLAG" == false ]; then
							if [ "$SKIP_SPEAK_MENU" != true ]; then
								if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
									gtts_speak "${OPT[i]} ${OPT_MUSIC_SUBMENU[MUSIC_SELECTION]}"
								elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
									gtts_speak "${OPT[i]} ${OPT_MUSIC_SUBMENU[SOUND_SELECTION]}"
								elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
									gtts_speak "${OPT[i]} ${OPT_MUSIC_SUBMENU[VIDEO_SELECTION]}"
								else
									if [ "${OPT[i]}" == "Setup" ]; then
										opt="settings"
									else
										opt="${OPT[i]}"
									fi
									gtts_speak "$opt"
								fi
							fi
						else
							NO_QUEUE_FLAG=false
						fi
					fi
				fi
			fi
		else
			if [ "${#OPT[$i]}" -lt "5" ]; then
				pad=" "
			else
				pad=""
			fi
			menu_buf="$menu_buf\n$PADDING$(tput el; tput cuf $((COLUMNS/2-5-moveleft)))$COLOR_ACCENT$BAR$WHITE ${OPT[$i]}$arrow$pad$NOCOLOR$COLOR_ACCENT$BAR$(tput el)"
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$SELECTION" == "1" ]; then
					if [ "$i" -ge "2" ]; then
							if [ "$MUSIC_SELECTION" == "$i" ] && [ "$i" == "2" ]; then
								menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$i]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
							elif [ "$i" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
								menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$i]} $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
							fi
					fi
				fi
			fi
			if [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [[ ( "$SELECTION" == "2" || "$SELECTION" == "3" ) && ( "$i" == "2" || "$i" == "3" ) ]]; then
					if [ "$SOUND_SELECTION" == "$((i-1))" ]; then
						menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$((i-1))]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					elif [ "$((i-1))" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
						menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$((i-1))]} $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					fi
				elif [ "$i" == "1" ]; then
					menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqk$LINE_CHAR_END$(tput el)"
				fi
			fi

			if [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$SELECTION" == "3" ] && [ "$i" == "4" ]; then
					if [ "$VIDEO_SELECTION" == "$((i-2))" ]; then
						menu_buf="${menu_buf}$BLUE_BLACK ${OPT_MUSIC_SUBMENU[$((i-2))]} $NOCOLOR$COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					elif [ "$((i-2))" -le "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
						menu_buf="${menu_buf}$WHITE ${OPT_MUSIC_SUBMENU[$((i-2))]} $COLOR_ACCENT$BAR$NOCOLOR$(tput el)"
					fi
				elif [ "$i" == "2" ]; then
					menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqk$LINE_CHAR_END$(tput el)"
				fi
			fi

			if [ "$i" == "3" ] && [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END$(tput el)"
			fi
			if [ "$i" == "4" ] && [ "$SOUND_RIGHT_WINDOW" == true ]; then
				menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END$(tput el)"
			fi
			if [ "$i" == "5" ] && [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				menu_buf="$menu_buf\b${LINE_CHAR}tqqqqqqqj$LINE_CHAR_END$(tput el)"
			fi
		fi
	done

	menu_buf="$menu_buf\n$PADDING$(tput el; tput cuf $((COLUMNS/2-5-moveleft)))$COLOR_ACCENT$BOTTOM_BAR_MENU$(tput el)"

	top=$(((LINES/2) - (TOTAL_OPTS/2)-1))	
	empty_pane 1 $((top-1))
	tput cup $top
	echo -ne "$menu_buf"
	empty_pane $((top+2+TOTAL_OPTS))
}

main_menu() {
	pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
	z=""
	old_LINES=$LINES
	old_COLUMNS=$COLUMNS
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		z="$_input"
		nospeak=true
	else
		z=""
		nospeak=false
	fi
	local initial_screen=$1
	tagged=false

	if [ "$((COLUMNS%2))" == "0" ]; then
		even=true
	else
		even=false
	fi
	
	OPT[1]="Music"
	OPT[2]="Sound"
	OPT[3]="Video"
	OPT[4]="Queue"
	OPT[5]="Setup"
	OPT[6]="Help"
	OPT[7]="Quit"
	if [ "$LINES" -gt "10" ]; then
		TOTAL_OPTS=${#OPT[@]}
	else
		TOTAL_OPTS=3
	fi

	OPT_MUSIC_SUBMENU[1]="Loops"
	OPT_MUSIC_SUBMENU[2]="Locks"

	TOTAL_OPTS_MUSIC_SUBMENU=${#OPT_MUSIC_SUBMENU[@]}

	SELECTION="1"

	pad_=1

	menu_start_over=true

	first=$(((LINES/2) - (TOTAL_OPTS/2)-1))
	last=$((first + TOTAL_OPTS - 1))

	until [ "$z" = "," ]; do
		if [ "$LINES" -le "10" ]; then
			TOTAL_OPTS=3
		else
			TOTAL_OPTS=${#OPT[@]}
		fi
		if [ "$z" == "" ]; then
			x=1
			if [ "$initial_screen" == true ]; then
				echo -ne "$NOCOLOR"
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
			else
				draw_banner "MENU"
				echo -ne "$NOCOLOR"
			fi

			if [ "$((COLUMNS%2))" == "0" ]; then
				moveleft=1
			else
				moveleft=0
			fi
			draw_menu
		fi

		if [ "$z" == "" ]; then
			until [ "$z" != "" ]; do
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.01 tmp_z <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$tmp_z" != "" ]; then
					z=$tmp_z
				else
					sleep 0.05
					if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
						clear
						draw_wait false
						if [ "$((COLUMNS%2))" == "0" ]; then
							even=true
						else
							even=false
						fi
						reset_buffer
						render_all_help_screens
						echo -ne "$NOCOLOR"
						clear
						screen_redrawn=true
						old_LINES=$LINES
						old_COLUMNS=$COLUMNS
						if [ "$initial_screen" == false ]; then
							draw_volume
							draw_equalizer
							draw_position
						fi
						break
					else
						screen_redrawn=false
					fi
					if read -rsn1 -t $BANNER_WAIT_TIME z; then
						break
					fi
				fi
			done
		fi
		if [ "$screen_redrawn" == true ]; then
			continue
		fi
		if [ "$z" == "j" ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$MUSIC_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					MUSIC_SELECTION=$((MUSIC_SELECTION+1))
				fi
			elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [ "$SOUND_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					SOUND_SELECTION=$((SOUND_SELECTION+1))
				fi
			elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$VIDEO_SELECTION" != "$TOTAL_OPTS_MUSIC_SUBMENU" ]; then
					VIDEO_SELECTION=$((VIDEO_SELECTION+1))
				fi
			else
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$((SELECTION+1))"
				else
					SELECTION="1"
				fi
			fi
			tagged=false
			z=""
			continue
		elif [ "$z" == "k" ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				if [ "$MUSIC_SELECTION" != "1" ]; then
					MUSIC_SELECTION=$((MUSIC_SELECTION-1))
				fi
			elif [ "$SOUND_RIGHT_WINDOW" == true ]; then
				if [ "$SOUND_SELECTION" != "1" ]; then
					SOUND_SELECTION=$((SOUND_SELECTION-1))
				fi
			elif [ "$VIDEO_RIGHT_WINDOW" == true ]; then
				if [ "$VIDEO_SELECTION" != "1" ]; then
					VIDEO_SELECTION=$((VIDEO_SELECTION-1))
				fi
			else
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$((SELECTION-1))"
				else
					SELECTION="$TOTAL_OPTS"
				fi
			fi
			tagged=false
			z=""
			continue
		elif [ "$z" == "l" ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			if [ "$SELECTION" == "1" ]; then
				MUSIC_RIGHT_WINDOW=true
				SOUND_RIGHT_WINDOW=false
				VIDEO_RIGHT_WINDOW=false
				MUSIC_SELECTION=1
			#elif [ "$SELECTION" == "2" ]; then
			#	SOUND_RIGHT_WINDOW=true
			#	MUSIC_RIGHT_WINDOW=false
			#	VIDEO_RIGHT_WINDOW=false
			#	SOUND_SELECTION=1
			#elif [ "$SELECTION" == "3" ]; then
			#	VIDEO_RIGHT_WINDOW=true
			#	SOUND_RIGHT_WINDOW=false
			#	MUSIC_RIGHT_WINDOW=false
			#	VIDEO_SELECTION=1
			fi
			z=""
			continue
		elif [ "$z" == "h" ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			echo -ne "$WHITE"
			MUSIC_RIGHT_WINDOW=false
			SOUND_RIGHT_WINDOW=false
			VIDEO_RIGHT_WINDOW=false
			MUSIC_SELECTION=1
			SOUND_SELECTION=1
			VIDEO_SELECTION=1
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			if [ "$initial_screen" == true ]; then
				menu_start_over=true
			fi
			draw_banner "MENU"
			draw_position
			z=""
			continue
		elif [ "$z" == "i" ]; then
			if [ "$initial_screen" == true ]; then
				z=""
				continue
			else
				z=","
			fi
		elif [ "$z" == "a" ]; then
			set_equalizer false true
			draw_equalizer
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_dark_mode
			draw_volume
			draw_equalizer
			draw_volume
			z=""
			continue
		elif [ "$z" == "" ]; then
			select_color true
			z=""
			continue
		elif [ "$z" == "|" ]; then
			vanish
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_colors true
			z=""
			continue
		elif [ "$z" == "" ]; then
			invert_colors true
			z=""
			continue
		elif [ "$z" == "#" ]; then
			save_settings
			z=""
			continue
		elif [ "$z" == "X" ]; then
			set_scale_speed
			draw_banner "MENU"
			z=""
			continue
		elif [ "$z" == "q" ]; then
			if [ "$initial_screen" == true ]; then
				clear
				tput cnorm
				stty echo
				exit 0
			fi
			z=","
		elif [ "$z" == "C" ]; then
			yt_artist
			z=""
			continue
		elif [ "$z" == "F" ]; then
			yt_search
			z=""
			continue
		elif [ "$z" == "f" ]; then
			tmux_attach
			z=""
			continue
		elif [ "$z" == "8" ]; then
			system_volume_change false 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "9" ]; then
			system_volume_change true 3 3
			tagged=true
			z=""
			continue
		elif [ "$z" == "*" ]; then
			system_volume_change false 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "(" ]; then
			system_volume_change true 1 1
			tagged=true
			z=""
			continue
		elif [ "$z" == "1" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "5" ]; then
					VOLUME=$((VOLUME-5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "2" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "95" ]; then
					VOLUME=$((VOLUME+5))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "!" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME=$((VOLUME-1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "@" ]; then
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" != "1" ]; then
				pcm_volume_change "$z"
				if [ "$?" != 200 ]; then
					return $?
				fi
			else
				if [ "$VOLUME" -le "99" ]; then
					VOLUME=$((VOLUME+1))
					gtts_speak "$VOLUME"
				fi
				draw_volume
			fi
			tagged=true
			z=""
			continue
		elif [ "$z" == "c" ]; then
			toggle_mute
			tagged=true
			z=""
			continue
		elif [ "$z" == "d" ]; then
			toggle_voice false false "MENU"
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "z" ]; then
			draw_wait false
			REDRAWN=true
			reset_dimensions
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
				reset_buffer
			fi
			z=""
			continue
		elif [ "$z" == ":" ]; then
			tput cup 1
			tput el
			tput cup $((LINES-2))
			tput el
			setup_screen "$initial_screen"
			if [ "$initial_screen" == false ]; then
				redraw_buffer
			fi
			z=""
			continue
		elif [ "$z" == "?" ]; then
			tput cup 1
			tput el
			tput cup $((LINES-2))
			tput el
			if [ "$initial_screen" == true ]; then
				help_screen true
			else
				help_screen false
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "S" ]; then
			new_playlist true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "" ]; then
			toggle_panels
			z=""
			continue
		elif [ "$z" == "s" ]; then
			if [ "$initial_screen" == false ]; then
				REPEAT_ONLY=false
			fi
			if (( SELECTION == 2 )); then
				dir="$SOUNDDIR"
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
			elif (( SELECTION == 3 )); then
				dir="$VIDEODIR"
				regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
			else
				dir="$MUSICDIR"
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
			fi
			VIDEO=false
			mapfile -t tmp_array < <(find "$dir" -type f -iregex "$regex" | sort)
			new_TOTAL_QUEUE=${#tmp_array[@]}
			if (( new_TOTAL_QUEUE == 0 )); then
				if (( SELECTION == 2 )); then
					draw_banner "NO SOUND"
					gtts_speak "no sound"
				elif (( SELECTION == 3 )); then
					draw_banner "NO VIDEO"
					gtts_speak "no video"
				else
					draw_banner "NO MUSIC"
					gtts_speak "no music"
				fi
				sleep $BANNER_WAIT_TIME
				NO_QUEUE_FLAG=true
				menu_start_over=true
				z=""
				continue
			else
				old_tq=$TOTAL_QUEUE
				old_qa=("${queue_array[@]}")
				TOTAL_QUEUE=$new_TOTAL_QUEUE
				queue_array=("${tmp_array[@]}")
				SHUFFLED=false
				echo -ne "$NOCOLOR"
			fi
			start_search true
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			else
				TOTAL_QUEUE=$old_tq
				queue_array=("${old_qa[@]}")
			fi
			menu_start_over=true
			z=""
			continue
		elif [ "$z" == "Q" ]; then
			queue_controls true
			if [ "$?" == "$RETURN_JUMP" ]; then
				JUMP=1
				return $RETURN_JUMP
			fi
			z=""
			continue
		elif [ "$z" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$SELECTION" -lt "$TOTAL_OPTS" ]; then
					SELECTION="$((SELECTION+1))"
				fi
				tagged=false
				z=""
				continue
				;;
			'[A')
				if [ "$SELECTION" -gt "1" ]; then
					SELECTION="$((SELECTION-1))"
				fi
				tagged=false
				z=""
				continue
				;;
			*)
				if [ "$initial_screen" == true ]; then
					exit 0
				else
					tput cup $((LINES-2))
					tput el
					z=","
				fi
				;;
			esac
		elif [ "$z" == "" ]; then
			z=""
		else
			z=""
			continue
		fi
		if [ "$z" == "" ] || [ "$z" == " " ]; then
			if [ "$MUSIC_RIGHT_WINDOW" == true ]; then
				MUSIC_RIGHT_WINDOW=false
				if [ "$MUSIC_SELECTION" == "1" ]; then
					VIDEO=false
					load_only_loops true
					if [ "$TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO LOOPS"
						gtts_speak "no music loops"
						sleep $BANNER_WAIT_TIME
						continue
						
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				elif [ "$MUSIC_SELECTION" == "2" ]; then
					VIDEO=false
					set_only_locked false false false false true
					if [ "$?" == "50" ]; then
						draw_banner "NO LOCKS"
						gtts_speak "no locked music" true
						sleep $BANNER_WAIT_TIME
						continue
					else
						draw_banner "WAIT"
					fi
					JUMP="1"
					echo -ne "$NOCOLOR"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
			case $SELECTION in
			*)
				if [ "${OPT[$SELECTION]}" == "Search" ]; then
					new_playlist true
					if [ "$?" == "$RETURN_JUMP" ]; then
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "Music" ]; then
					regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$MUSICDIR" -type f -regex "$regex" -and -not -iname "*.repeat.*" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO MUSIC"
						sleep $BANNER_WAIT_TIME
						gtts_speak "no music" true
						menu_start_over=true
						NO_QUEUE_FLAG=true
						continue
					else
						PICK=""
						REPEAT_ONLY=false
						VIDEO=false
						SHUFFLED=true
						queue_array=("${tmp_array[@]}")
						TOTAL_QUEUE=$new_TOTAL_QUEUE
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "Sound" ]; then
					regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$SOUNDDIR" -type f -regex "$regex" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO SOUNDS"
						gtts_speak "no sounds" true
						sleep $BANNER_WAIT_TIME
						menu_start_over=true
						NO_QUEUE_FLAG=true
						draw_position
						continue
					else
						PICK=""
						REPEAT_ONLY=false
						VIDEO=false
						SHUFFLED=true
						TOTAL_QUEUE="$new_TOTAL_QUEUE"
						queue_array=("${tmp_array[@]}")
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "Video" ]; then
					regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
					mapfile -t tmp_array < <(find "$VIDEODIR" -type f -regex "$regex" | shuf)
					new_TOTAL_QUEUE=${#tmp_array[@]}
					if [ "$new_TOTAL_QUEUE" == "0" ]; then
						draw_banner "NO VIDEOS"
						gtts_speak "no videos" true
						sleep $BANNER_WAIT_TIME
						NO_QUEUE_FLAG=true
						menu_start_over=true
						continue
					else
						REPEAT_ONLY=false
						SHUFFLED=true
						TOTAL_QUEUE=$new_TOTAL_QUEUE
						queue_array=("${tmp_array[@]}")
						JUMP="1"
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				elif [ "${OPT[$SELECTION]}" == "Queue" ]; then
					queue_controls true
					if [ "$?" == "$RETURN_JUMP" ]; then
						JUMP=1
						return $RETURN_JUMP
					fi
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "Setup" ]; then
					if [ "$NO_VERTICAL_PADDING" == false ]; then
						tput cup 1
						tput el
						tput cup $((LINES-2))
						tput el
					fi
					setup_screen "$initial_screen"
				elif [ "${OPT[$SELECTION]}" == "Help" ]; then
					tput cup 1
					tput el
					tput cup $((LINES-2))
					tput el
					if [ "$initial_screen" == true ]; then
						help_screen true
					else
						help_screen false
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					fi
					menu_start_over=true
				elif [ "${OPT[$SELECTION]}" == "Quit" ]; then
					clear
					exit 0
				else
					z=","
				fi

			esac
		fi
		if [ "$z" = "," ]; then
			if [ "$1" != true ]; then
				redraw_buffer
				draw_pitch
				draw_position
			fi
			gtts_speak "menu closed. main screen"
			z=","
		fi
	done
}

scale() {
	if [ "$WEB_CLIENT" != 1 ]; then
		gtts_speak "scale interval"
	fi
	draw_banner "SCALE"
	stopat=""
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 interval_change <&1
	else
		read -rsn1 interval_change <"$ALETHEIA/web_client_pipe$$"
	fi

	if [ "$interval_change" = "J" ]; then
		if [ "$INTERVAL" -le "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=2.5
		interval_change="$((INTERVAL-EDO))"
	elif [ "$interval_change" = "K" ]; then
		if [ "$INTERVAL" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=2.5
		interval_change="$((INTERVAL+EDO))"
	elif [ "$interval_change" == "j" ]; then
		if [ "$INTERVAL" -le "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=true
		time=$SCALE_SPEED
		interval_change="$((INTERVAL-EDO))"
	elif [ "$interval_change" == "k" ]; then
		if [ "$INTERVAL" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		gtts_speak "scaling"
		backwards=false
		time=$SCALE_SPEED
		interval_change="$((INTERVAL+EDO))"
	elif [ "$interval_change" == "d" ]; then
		toggle_voice
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "?" ]; then
		scale_help_screen
		RIGHT_BANNER_WIDTH=0
		redraw_buffer
		draw_pitch
		draw_position
		return
	elif [ "$interval_change" == "" ] || [ "$interval_change" == "q" ] || [ "$interval_change" == "u" ]; then
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	elif [ "$(isnum "$interval_change")" == "1" ] || [ "$interval_change" == "-" ]; then
		draw_position
		draw_banner "SCALE"
		tmp="$(read_line "$interval_change" true)"
		if [ "$?" == "1" ]; then
			gtts_speak "invalid number. main screen"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
		if [ "$tmp" -lt "$INTERVAL" ]; then
			if [ "$tmp" -le "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=true
			time=$SCALE_SPEED
			interval_change="$((INTERVAL-EDO))"
		elif [ "$tmp" -gt "$INTERVAL" ]; then
			if [ "$tmp" -ge "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
				gtts_speak "scale closed"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				return
			fi
			gtts_speak "scaling"
			stopat=$tmp
			backwards=false
			time=$SCALE_SPEED
			interval_change="$((INTERVAL+EDO))"
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "SCALE" false true
		else
			gtts_speak "scale closed"
			RIGHT_BANNER_WIDTH=0
			draw_pitch
			draw_position
			return
		fi
	else
		gtts_speak "scale closed"
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
		return
	fi
	if [ "$interval_change" != "" ]; then
		draw_banner "SCALE" false true
		draw_pitch
		PAUSE=false
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
		fi
		orig_int="$INTERVAL"
		c=""
		while [ "$interval_change" != "$orig_int" ]; do
			if [ "$interval_change" -le "$orig_int" ] || [ "$BACKWORDS" == true ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t "$SCALE_SPEED" c
				else
					read -rsn1 -t "$SCALE_SPEED" c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "u" ] || [ "$c" == "q" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ]; then
					if [ "$c" == "c" ]; then
						sleep "$SCALE_SPEED"
						gtts_speak "order reversed"
					fi
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						INTERVAL="$((INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						interval_change="$((interval_change * -1))"
					else 
						backwards=true
						interval_change="$((interval_change*-1))"
						INTERVAL="$((INTERVAL-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then
					echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
					INTERVAL="$((INTERVAL-1))"
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				fi

			elif [ "$interval_change" -ge "$orig_int" ] || [ "$backwards" == false ]; then
				draw_pitch 1
				if [ "$WEB_CLIENT" == "0" ]; then
					read -rsn1 -t "$SCALE_SPEED" c
				else
					read -rsn1 -t "$SCALE_SPEED" c <"$ALETHEIA/web_client_pipe$$"
				fi
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
					draw_pitch
					draw_position
					return
				fi
				secondary_scale_func "$c" "SCALE"
				if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "u" ] || [ "$c" == "" ]; then
					gtts_speak "scale closed"
					break
				elif [ "$c" == "c" ] || [ "$backwards" == true ]; then
					if [ "$c" == "c" ]; then
						sleep "$SCALE_SPEED"
						gtts_speak "order reversed"
					fi
					if [ "$backwards" == true ] && [ "$c" != "c" ]; then
						INTERVAL="$((INTERVAL-1))"
					elif [ "$backwards" == true ] && [ "$c" == "c" ]; then
						backwards=false
						INTERVAL="$((INTERVAL+1))"
					else
						backwards=true
						INTERVAL="$((INTERVAL-1))"
						interval_change="$((interval_change*-1))"
					fi
				elif [ "$c" == "J" ]; then
					edo_down
				elif [ "$c" == "K" ]; then
					edo_up
				elif [ "$c" == "d" ]; then
					toggle_voice
					draw_pitch
					draw_banner "SCALE" false true
				elif [ "$c" == "z" ]; then
					draw_wait false
					reset_dimensions
					draw_banner "SCALE" false true
					redraw_screen false 1 1 1 0
				elif [ "$c" == "" ]; then	
					INTERVAL="$((INTERVAL+1))"
					echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
					draw_pitch
				fi
				if [ "$INTERVAL" == "$stopat" ]; then
					gtts_speak "scale finished"
					break
				fi
				if [ "$INTERVAL" == "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				elif [ "$INTERVAL" == "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
					gtts_speak "limit reached"
					break
				fi
			fi
		done
		RIGHT_BANNER_WIDTH=0
		draw_pitch
		draw_position
	fi
}

scale_octave() {
	draw_banner "OCTAVE" false true
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	if [ "$1" == "-" ]; then
		orig_int=$INTERVAL
		if [ "$((INTERVAL-EDO))" -ge "-$(echo -n "$INTERVAL_LIMIT" | cut -d'.' -f1)" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$((INTERVAL-EDO))
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -lt "$EDO" ]; do
					read -rsn1 -t "$SCALE_SPEED" c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$((INTERVAL-1))"
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$((x+1))
					fi
				done
			fi
		fi
	elif [ "$1" == "+" ]; then
		orig_int=$INTERVAL
		if [ "$((INTERVAL+EDO))" -le "$(echo -n "$INTERVAL_UPPER_LIMIT" | cut -d'.' -f1)" ]; then
			if [ "$2" == true ]; then
				INTERVAL=$((INTERVAL+EDO))
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
				draw_pitch
			else
				gtts_speak "scaling"
				x=0
				while [ "$x" -le "$EDO" ]; do
					read -rsn1 -t "$SCALE_SPEED" c 
					secondary_scale_func "$c" "OCTAVE"
					if [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "OCTAVE" false true
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
					elif [ "$c" == "q" ] || [ "$c" == "" ]; then
						draw_pitch
						break
					elif [ "$c" == "" ]; then
						INTERVAL="$((INTERVAL+1))"
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x=$((x+1))
					fi
				done
			fi
		fi
	fi
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

set_custom_int() {
	gtts_speak "enter interval adjustment"
	draw_banner "INT"
	read -rn1 interval_jump
	if [ "$(isnum "$interval_jump")" == "1" ] || [ "$interval_jump" == "-" ]; then
		interval_jump="$(read_line "$interval_jump" true)"
		if [ "$?" == "1" ]; then
			gtts_speak "invalid number. main screen"
			draw_pitch
			return
		fi
		gtts_speak " $interval_jump"
	else
		gtts_speak "invalid number. main screen" true
		draw_pitch
		redraw_buffer
		return
	fi
	if [ "$interval_jump" != "" ]; then
		PAUSE=false
		echo -e "speed_set $(calc "2^($interval_jump/$EDO)")" >"$ALETHEIA/pipe$$" &
		INTERVAL="$interval_jump"
	else
		gtts_speak "closed" true
		draw_position
	fi
	draw_pitch
}

toggle_mute() {
	if [ "$MUTE" == false ]; then
		gtts_speak "muted" true
		if [ "$OS" == "Darwin" ]; then
			osascript -e 'set volume with output muted'
		elif [ "$OS" == "Linux" ]; then
			pactl set-sink-mute @DEFAULT_SINK@ 1 >/dev/null 2>/dev/null
		fi
		MUTE=true
		draw_banner "MUTE"
	else
		if [ "$OS" == "Linux" ]; then
			pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
		elif [ "$OS" == "Darwin" ]; then
			osascript -e "set volume output volume $SYSTEM_VOLUME_LEFT"
		fi
		gtts_speak "unmuted"
		MUTE=false
		draw_pitch
	fi
}

toggle_pause() {
	echo -e "pause" >"$ALETHEIA/pipe$$" &
	if [ $PAUSE = false ]; then
		PAUSE=true
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "paused"
			draw_banner "PAUSE" false false true
		fi
	else
		PAUSE=false
		if [ "$1" == false ] || [ "$1" == "" ]; then
			gtts_speak "unpaused"
			draw_pitch
		fi
	fi
}

interval_to_zero() {
	INTERVAL="0"
	echo "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	LOCKED=false
	draw_volume
	draw_equalizer
	draw_pitch
	draw_position
}

reset_all_tuning() {
	SCALETEMPO=false
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
	sleep $MPLAYER_WAIT_TIME
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	gtts_speak "reset"
	draw_volume
	draw_equalizer
	draw_pitch
}

read_locked_file() {
	CONTENTS="$1"
	IFS='/' read -r _int _edo _scaletempo_flag oldstyle1 oldstyle2 <<< "$CONTENTS"
	if [ "$oldstyle1" != "" ] && [ "$oldstyle2" != "" ]; then
		# backwards compatible with old style locked file
		_scaletempo_flag=$oldstyle2
	fi
	INTERVAL=$_int
	EDO=$_edo
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
}

reset_to_locked() {
	if [ -e "$FILENAME.locked" ]; then
		read_locked_file "$(cat "$FILENAME.locked")"
		LOCKED=true

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi
		
		if [ "$EQUALIZER" == "" ]; then
			EQUALIZER="$DEFAULT_EQUALIZER"
			equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
			equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
			equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"
		else
			if [ "$EQUALIZER" != "0:0:0:0:0:0:0:0:0:0" ]; then
				echo -e "af_del equalizer" >"$ALETHEIA/pipe$$" &
				echo -e "af_add equalizer=$EQUALIZER" >"$ALETHEIA/pipe$$" &

				equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
				equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
				equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"
			fi
		fi

		if [ "$_scaletempo_flag" == "" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "0" ]; then
			SCALETEMPO=false
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "1" ]; then
			SCALETEMPO=true
			ONLY_PITCH=false
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=tempo" >"$ALETHEIA/pipe$$" &
		elif [ "$_scaletempo_flag" == "2" ]; then
			SCALETEMPO=true
			ONLY_PITCH=true
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		fi
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		sleep $MPLAYER_WAIT_TIME
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	else
		INTERVAL="$DEFAULT_INTERVAL"
		EDO="$DEFAULT_EDO"
		INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
		INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
		echo "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		VOLUME="$DEFAULT_VOLUME"
		echo -e "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
	fi
	gtts_speak "tuning reset"
	draw_equalizer
	draw_volume
	draw_pitch
	draw_position
}

set_custom_edo() {
	draw_banner "EDO"
	gtts_speak "enter e d o"
	read -rn1 new_edo
	if [ "$(isnum "$new_edo")" == "1" ]; then
		new_edo="$(read_line "$new_edo" true)"
		if [ "$?" == "1" ]; then
			gtts_speak "invalid number. main screen"
			draw_pitch
			return
		fi
	else
		gtts_speak "invalid number. main screen"
		draw_pitch
		redraw_buffer
		return
	fi

	reset_buffer
	if [ "$new_edo" = "" ]; then
		gtts_speak "closed" true
		draw_pitch
		redraw_buffer
		return
	fi

	if [ "$(isnum "$new_edo")" != "0" ]; then
		gtts_speak "$new_edo" true
		PAUSE=false
		if [ "$new_edo" -lt "1" ]; then
			return
		fi
		if [ "$new_edo" -gt "$EDO" ]; then
			temp="$(calc "$new_edo/$EDO" | cut -d'~' -f2)"
			INTERVAL="$(echo "$INTERVAL*$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
		elif [ "$new_edo" -lt "$EDO" ]; then
			temp="$(calc "$EDO/$new_edo" | cut -d'~' -f2 | bc)"
			INTERVAL="$(echo "$INTERVAL/$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
		else
			draw_pitch
			draw_position
			return
		fi

		EDO="$new_edo"
		LOCKED_EDO="$EDO"
		INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
		INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		LOCKED=false
		draw_volume
		draw_equalizer
		redraw_buffer
		draw_pitch
		draw_position
	fi
}

double_precise() {
	if [ "$EDO" -lt "$EDO_LIMIT" ]; then
		INTERVAL=$((INTERVAL * 2))
		EDO=$((EDO*2))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		draw_pitch
		INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
		INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
		gtts_speak "$EDO"
	else
		gtts_speak "limit"
	fi
}

half_precise() {
	old="$(calc "($INTERVAL/$EDO)")"
	if [ "$((EDO % 2))" = "0" ]; then
		new_edo="$((EDO/2))"
		if [ "$new_edo" -ge "2" ]; then
			temp="$(calc "$new_edo/$EDO" | cut -d'~' -f2)"
			INTERVAL="$(echo "$INTERVAL*$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
			if [ "$(isnum "$INTERVAL")" == "0" ]; then
				INTERVAL=0
			fi
			EDO="$new_edo"
			new="$(calc "($INTERVAL/$EDO)")"
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
			INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
			gtts_speak "$EDO"
		else
			gtts_speak "limit"
		fi
		if [ "$old" != "$new" ]; then
			LOCKED=false
		fi
		draw_pitch
	fi
}

pitch_down() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" != true ]; then
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -gt "-${INTERVAL_LIMIT%.*}" ]; then
		INTERVAL=$((INTERVAL-1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" != true ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

pitch_up() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then 
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		if [ "$2" != true ]; then 
			draw_pitch
		fi
	fi
	if [ "$INTERVAL" -lt "${INTERVAL_UPPER_LIMIT%.*}" ]; then
		INTERVAL=$((INTERVAL+1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		if [ "$2" != true ]; then
			draw_pitch 1
		fi
	else
		gtts_speak "limit"
	fi

	return 200
}

edo_down() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -gt "1" ]; then
		EDO=$((EDO-1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
		tmpz=$((EDO*2))
		if [ "$INTERVAL" -gt "$tmpz" ] || [ "$INTERVAL" -lt "$((-tmpz))" ]; then
			if [ "$INTERVAL" -lt "0" ]; then
				INTERVAL=-$tmpz
			else
				INTERVAL=$tmpz
			fi
		fi

		LOCKED=false
		draw_pitch 2
		gtts_speak " $EDO"
	else
		gtts_speak "limit"
	fi

	return 200
}

set_default_edo() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	new_edo="$DEFAULT_EDO"
	if [ "$new_edo" -gt "$EDO" ]; then
		temp="$(calc "$new_edo/$EDO" | cut -d'~' -f2)"
		INTERVAL="$(echo "$INTERVAL*$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
	elif [ "$new_edo" -lt "$EDO" ]; then
		temp="$(calc "$EDO/$new_edo" | cut -d'~' -f2)"
		INTERVAL="$(echo "$INTERVAL/$temp" | bc | cut -d'~' -f2 | cut -d'.' -f1)"
	fi
	EDO="$new_edo"
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	LOCKED=false
	draw_pitch 1
	gtts_speak "$EDO"
}

edo_up() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
		draw_pitch
	fi
	if [ "$EDO" -lt "2000000" ]; then
		EDO=$((EDO+1))
		echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &

		LOCKED=false
		draw_pitch 2
		gtts_speak "$EDO"
	else
		gtts_speak "limit"
	fi

	return 200
}

toggle_scale_tempo() {
	if [ "$SCALETEMPO" == false ]; then
		echo -e "af_add scaletempo" >"$ALETHEIA/pipe$$" &
		gtts_speak "tempo"
		SCALETEMPO=true
		ONLY_PITCH=false
	else
		if [ "$ONLY_PITCH" == false ]; then
			ONLY_PITCH=true
			gtts_speak "pitch"
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			sleep $MPLAYER_WAIT_TIME
			echo -e "af_add scaletempo=speed=pitch" >"$ALETHEIA/pipe$$" &
		else
			echo -e "af_del scaletempo" >"$ALETHEIA/pipe$$" &
			gtts_speak "pitch and tempo"
			SCALETEMPO=false
			ONLY_PITCH=false
		fi
	fi
	if [ "$PAUSE" == true ]; then
		PAUSE=false
	fi
	draw_pitch 3
}

secondary_scale_func() {
	if [ "$1" == "v" ]; then
		toggle_scale_tempo
	elif [ "$1" == "j" ]; then
		pitch_down
	elif [ "$1" == "k" ]; then
		pitch_up
	elif [ "$1" == "l" ]; then
		gtts_speak "forward"
		echo "seek +5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "h" ]; then
		gtts_speak "backward"
		echo "seek -5%" >"$ALETHEIA/pipe$$" &
	elif [ "$1" == "8" ]; then
		system_volume_change false 3 3
	elif [ "$1" == "9" ]; then
		system_volume_change true 3 3
	elif [ "$1" == "*" ]; then
		system_volume_change false 1 1
	elif [ "$1" == "(" ]; then
		system_volume_change true 1 1
	elif [ "$1" == "I" ]; then
		read_corner
		gtts_speak "scaling"
	elif [ "$1" == "H" ]; then
		less_precise
	elif [ "$1" == "L" ]; then
		more_precise
	elif [ "$1" == "o" ]; then
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$"
			mute=false
			draw_pitch
		fi
		double_precise
	elif [ "$1" == "m" ]; then
		if [ "$mute" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$"
			mute=false
			draw_pitch
		fi
		half_precise				
	elif [ "$1" == "M" ]; then
		invert_int
	elif [ "$1" == "a" ]; then
		PAUSE=false
		draw_banner "$2" false true
		set_equalizer
		draw_banner "$2" false true
	elif [ "$1" == "y" ]; then
		set_default_edo
	elif [ "$1" == "!" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "@" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "1" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "2" ]; then
		pcm_volume_change "$1"
	elif [ "$1" == "p" ]; then
		toggle_pause
		draw_banner "$2" false true
		if [ "$WEB_CLIENT" == "0" ]; then
			read -rn1 input_char
		else
			read -rn1 input_char <"$ALETHEIA/web_client_pipe$$"
		fi

		toggle_pause
		draw_banner "$2" false true
	elif [ "$1" == "" ]; then
		gtts_speak " $INTERVAL" false false true
	elif [ "$1" == "\\" ]; then
		echo "seek 0 2" >"$ALETHEIA/pipe$$" &
	else
		process_key "$1"
		return
	fi
}

oscillate() {
	old_int="$INTERVAL"
	gtts_speak "oscillate; enter an interval to oscillate to or push enter to invert"
	draw_banner "OSCILLATE"
	tput rc
	read -rsn1 result
	if [ "$result" == "q" ] || [ "$result" == "G" ] || [ "$result" == "" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi
	if [ "$result" != "" ]; then
		result="$(read_line "$result")"
	fi
	if [ "$result" != "" ]; then
		if [ "$INTERVAL" -lt "0" ] && [ "$result" -lt "0" ]; then
			if [ "$INTERVAL" -lt "$result" ]; then
				NEGATIVE=true
			else
				NEGATIVE=false
			fi
			abs_int=${INTERVAL#-}
			abs_result=${result#-}
			if [ "$abs_int" -gt "$abs_result" ]; then
				result="$(echo -e "$abs_int - $abs_result" | bc)"
			elif [ "$abs_int" -lt "$abs_result" ]; then
				result="$(echo -e "$abs_result - $abs_int" | bc)"
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -gt "0" ]; then
			if [ "$INTERVAL" -gt "$result" ]; then
				result="$(echo -e "$INTERVAL - $result" | bc)"
				NEGATIVE=false
			elif [ "$INTERVAL" -lt "$result" ]; then
				result="$(echo -e "$result - $INTERVAL" | bc)"
				NEGATIVE=true
			else
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			fi
		elif [ "$INTERVAL" -gt "0" ] && [ "$result" -lt "0" ]; then
			abs_result=${result#-}
			result="$(echo -e "$abs_result + $INTERVAL" | bc)"
			NEGATIVE=false
		elif [ "$INTERVAL" -lt "0" ] && [ "$result" -gt "0" ]; then
			abs_int=${INTERVAL#-}
			result="$(echo -e "$result + $abs_int" | bc)"
			NEGATIVE=true
		elif [ "$INTERVAL" == "0" ] || [ "$result" == "0" ]; then
			if [ "$INTERVAL" == "0" ] && [ "$result" == "0" ]; then
				gtts_speak "closed" true
				draw_pitch
				draw_position
				return
			elif [ "$INTERVAL" == "0" ]; then
				if [ "$result" -lt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				result="$(calc "abs($result)" | sed "s/\t//g")"
			elif [ "$result" == "0" ]; then
				if [ "$INTERVAL" -lt "0" ]; then
					NEGATIVE=true
				else
					NEGATIVE=false
				fi
				result="$(calc "abs($INTERVAL)" | sed "s/\t//g")"
			fi
		fi
	fi
	if [ "$result" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		draw_position
		return
	fi
	if [ "$INTERVAL" == "0" ]; then
		gtts_speak "can't oscillate; interval at zero"
		draw_pitch
		draw_position
		return
	fi
	draw_banner "OSCILLATE" false true
	gtts_speak "oscillating"
	if [ "$result" == "" ]; then
		old_int="$INTERVAL"
		INTERVAL="$((-(INTERVAL)))"
		if [ "$INTERVAL" -lt "0" ]; then
			result="$old_int"
		else
			result="$INTERVAL"
		fi
		result="$((result*2))"
		if [ "$old_int" -gt "0" ]; then
			NEGATIVE=false
		else
			NEGATIVE=true
		fi
	fi
	x=0

	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	while [ "$x" -lt "$result" ]; do
		read -rsn1 -t "$SCALE_SPEED" c
		ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "o" ]; then
			old_int=$((old_int*2))
			if [ "$EDO" -lt "$EDO_LIMIT" ]; then
				x=$((x*2))
				result=$((result*2))
			fi
		elif [ "$c" == "m" ]; then
			if [ "$((EDO % 2))" == "0" ]; then
				old_int=$((old_int/2))
				x=$((x/2))
				result=$((result/2))
			fi
		fi
		secondary_scale_func "$c" "OSCILLATE"
		if [ "$c" == "c" ]; then
			x=$((result-x-2))
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
		elif [ "$c" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "OSCILLATE" false true
			redraw_screen false 1 1 1 0
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_pitch
			draw_banner "OSCILLATE" false true
		elif [ "$c" == "q" ] || [ "$c" == "" ]; then
			break
		elif [ "$c" == "" ]; then
			if [ "$NEGATIVE" == false ]; then
				INTERVAL="$((old_int-1))"
				old_int="$((old_int-1))"
			else
				INTERVAL="$((old_int+1))"
				old_int="$((old_int+1))"
			fi
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			draw_pitch
			x="$((x+1))"
		fi

		if [ "$x" == "$result" ]; then
			x=0
			if [ "$NEGATIVE" == true ]; then
				NEGATIVE=false
			else
				NEGATIVE=true
			fi
			read -rsn1 -t "$SCALE_SPEED" c
			ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$?" == "1" ]; then
				RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
				draw_pitch
				draw_position
				return
			fi
			if [ "$c" == "o" ]; then
				old_int=$((old_int*2))
				if [ "$EDO" -lt "$EDO_LIMIT" ]; then
					x=$((x*2))
					result=$((result*2))
				fi
			elif [ "$c" == "m" ]; then
				if [ "$((EDO % 2))" == "0" ]; then
					old_int=$((old_int/2))
					x=$((x/2))
					result=$((result/2))
				fi
			fi
			secondary_scale_func "$c" "OSCILLATE"
			if [ "$c" == "c" ]; then
				x=$((result-x-2))
				if [ "$NEGATIVE" == true ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
			elif [ "$c" == "H" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "L" ]; then
				old_int=$INTERVAL
			elif [ "$c" == "d" ]; then
				toggle_voice
				draw_pitch
			elif [ "$c" == "z" ]; then
				draw_wait false
				reset_dimensions
				draw_banner "OSCILLATE" false true
				redraw_screen false 1 1 1 0
			elif [ "$c" == "q" ] || [ "$c" == "" ]; then
				break
			elif [ "$c" == "" ]; then
				echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			fi
		fi

	done
	RIGHT_BANNER_WIDTH=0
	draw_pitch
	draw_position
}

pcm_volume_change() {
	if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
		if [ "$TRACK_RANDOM" == true ]; then
			return $RETURN_TRACK_RANDOM
		elif [ "$LOOP_ARTIST" == true ]; then
			return $RETURN_LOOP_ARTIST
		else
			return $RETURN_NEXT
		fi
	fi
	if [ "$1" == "1" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "5" ]; then
			VOLUME="$((VOLUME-5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "2" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "95" ]; then
			VOLUME="$((VOLUME+5))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "!" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -ge "1" ]; then
			VOLUME="$((VOLUME-1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	elif [ "$1" == "@" ]; then
		if [ "$PAUSE" == true ]; then
			PAUSE=false
			draw_pitch
		fi
		if [ "$MUTE" == true ]; then
			echo "mute" >"$ALETHEIA/pipe$$" &
			MUTE=false
			draw_pitch
		fi
		if [ "$VOLUME" -le "99" ]; then
			VOLUME="$((VOLUME+1))"
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			draw_equalizer
			draw_volume 1
		fi
	fi
	read -rn1 -t 0.1 key
	if [ "$key" != "" ]; then
		if [ "$key" == "1" ] || [ "$key" == "2" ] || [ "$key" == "!" ] || [ "$key" == "@" ]; then
			pcm_volume_change "$1"
			if [ "$?" != "200" ]; then
				return $?
			fi
		fi
	fi
	return 200
}

set_system_volume() {
	if [ "$1" == true ]; then
		dir="+"
	else
		dir="-"
	fi
	if [ "$OS" == "Linux" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ "$dir$2%" "$dir$3%"
	elif [ "$OS" == "Darwin" ]; then
		osascript -e "set volume output volume $1" 
	fi
}

system_volume_change() {
	leftvolume=${SYSTEM_VOLUME_LEFT%\%}
	rightvolume=${SYSTEM_VOLUME_RIGHT%\%}
	if [ "$leftvolume" == "" ]; then
		leftvolume=0
	fi
	if [ "$OS" == "Linux" ]; then
		pactl set-sink-mute @DEFAULT_SINK@ 0 >/dev/null 2>/dev/null
	elif [ "$OS" == "Darwin" ]; then
		osascript -e "set volume without output muted"
	else
		return
	fi
	if [ "$1" == true ]; then
		if (( leftvolume + 1 <= 100 )) && (( rightvolume + 1 <= 100 )); then
			l=$((leftvolume + $2))
			r=$((rightvolume + $3))
			if (( l > 100 )) && (( r > 100 )); then
				set_system_volume true "$((100 - leftvolume))" "$((100 - rightvolume))"
			elif (( l > 100 )); then
				set_system_volume true "$((100 - leftvolume))" "$2"
			elif (( r > 100 )); then
				set_system_volume true "$1" "$((100 - rightvolume))"
			else
				set_system_volume "$1" "$2" "$3"
			fi
		fi
	else
		if (( leftvolume - 1 >= 0 )) && (( rightvolume - 1 >= 0 )); then
			l=$((leftvolume - $2))
			r=$((rightvolume - $3))
			if [ "$OS" == "Linux" ]; then
				if (( l < 0 )) && (( r < 0 )); then
					set_system_volume false "$leftvolume" "$rightvolume"
				elif (( l < 0 )); then
					set_system_volume false "$leftvolume" "$2"
				elif (( r < 0 )); then
					set_system_volume false "$1" "$rightvolume"
				else
					set_system_volume "$1" "$2" "$3"
				fi
			fi
		fi
	fi
	get_system_volume
	draw_volume 2 3
}

fade_volume() {
	inputchar=""
	if [ "$WEB_CLIENT" == "1" ]; then
		read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$_input" != "" ]; then
		inputchar="$_input"
	fi
	draw_banner "FADE"
	gtts_speak "select direction to fade"
	PAUSE=false
	MUTE=false
	x=0
	if [ "$inputchar" == "" ]; then
		read -rn1 inputchar
	fi
	down=false
	up=false
	if [ "$inputchar" == "j" ]; then
		down=true
		gtts_speak "down"
	elif [ "$inputchar" == "k" ]; then
		up=true
		gtts_speak "up"
	else
		gtts_speak "closed" true
		draw_pitch
		return
	fi

	if [ "$down" == true ] && [ "$VOLUME" == "0" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	if [ "$up" == true ] && [ "$VOLUME" == "100" ]; then
		gtts_speak "closed" true
		draw_pitch
		return
	fi
	while [ "$x" -le "100" ] && [ "$VOLUME" -ge "0" ] && [ "$VOLUME" -le "100" ]; do
		if [ "$up" == true ]; then
			if [ "$VOLUME" == "100" ]; then
				draw_pitch
				return
			fi
			VOLUME="$((VOLUME+1))"
		elif [ "$down" == true ]; then
			if [ "$VOLUME" == "0" ]; then
				draw_pitch
				return
			fi
			VOLUME="$((VOLUME-1))"
		fi
		echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
		draw_volume
		read -rsn1 -t $BANNER_WAIT_TIME c
		ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$?" == "1" ]; then
			RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
			draw_pitch
			draw_position
			return
		fi
		if [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "3" ]; then
			gtts_speak "closed" true
			draw_pitch
			break
		elif [ "$c" == "d" ]; then
			toggle_voice
			draw_banner "FADE"
		elif [ "$c" == "c" ]; then
			if [ "$down" == true ]; then
				down=false
				up=true
			else
				down=true
				up=false
			fi
			gtts_speak "order reversed"
		elif [ "$c" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "FADING"
			redraw_screen false 1 1 0 1
		fi
		x=$((x+1))
	done
	draw_pitch
	redraw_buffer
}

sleep_countdown() {
	if [ "$WEB_CLIENT" == "0" ]; then
		read -rsn1 -t "$(echo "$1 * 60" | bc)" tmp
	else
		read -rsn1 -t "$(echo "$1 * 60" | bc)" tmp <"$ALETHEIA/web_client_pipe$$"
	fi
	if [ "$tmp" != "" ]; then
		gtts_speak "sleep canceled. main screen"
		echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
		draw_banner "CANCELED"
		sleep $BANNER_WAIT_TIME
		draw_pitch
		return
	fi
	if [ "$SLEEPING" == true ]; then
		SLEEPING=false
		draw_banner "SLEEPING"
		x="$VOLUME"
		while [ "$x" -ge "0" ] && [ "$VOLUME" -gt "0" ]; do
			VOLUME="$((VOLUME-1))"
			echo "volume $x 1" >"$ALETHEIA/pipe$$" &
			draw_volume
			if [ "$WEB_CLIENT" == "0" ]; then
				read -rsn1 -t 0.7 tmp
			else
				read -rsn1 -t 0.7 tmp <"$ALETHEIA/web_client_pipe$$"
			fi
			if [ "$tmp" != "" ]; then
				echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
				return
			fi
			x=$((x-1))
		done

		kill "$MPLAYER_PID" >/dev/null 2>/dev/null
		if [ "$SUSPEND" == true ]; then
			systemctl suspend
		fi
		exit 0
	fi
}

set_sleep() {
	if [ "$WEB_CLIENT" == "0" ]; then
		draw_banner "MINUTES"
		gtts_speak "enter time to sleep, in minutes"
		answer="$(read_line)"
	else
		answer="180"
	fi

	if [ "$answer" != "" ]; then
		if [ "$(isnum "$answer")" != "0" ]; then
			SLEEPING=true
			if [ "$WEB_CLIENT" == "0" ]; then
				gtts_speak "do you want to suspend? enter y, or n, or q to cancel"
				draw_banner "SUSPEND" true
				read -rsn1 suspend
			else
				suspend="y"
			fi
		
			if [ "$suspend" == "y" ] || [ "$suspend" == "Y" ]; then
				SUSPEND=true
			elif [ "$suspend" == "q" ] || [ "$suspend" == "" ] || [ "$suspend" == "~" ]; then
				gtts_speak "sleep canceled. main screen"
				draw_pitch
				draw_position
				return
			else
				SUSPEND=false
			fi

			if [ "$SUSPEND" == true ]; then
				draw_banner "SUSPEND ${answer}"
				draw_position
				gtts_speak "suspending in" true false true
			else
				draw_banner "SLEEP ${answer}"
				draw_position
				gtts_speak "sleeping in" true false true
			fi
			gtts_speak "$answer" true false true
			if [ "$answer" == "1" ]; then
				gtts_speak "minute"
			else
				gtts_speak "minutes"
			fi
			PAUSE=false
			if [ "$MUTE" == true ]; then
				echo "mute" >"$ALETHEIA/pipe$$" &
				MUTE=false
			fi
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_position
			sleep_countdown "$answer"
			draw_pitch
			draw_position
		else
			gtts_speak "sleep canceled. main screen"
			draw_pitch
			draw_position
		fi
	else
		gtts_speak "sleep canceled. main screen"
		draw_pitch
		redraw_buffer
	fi
}

read_line() {
	first_char=$1
	only_numbers=$2

	IFS=$'\n'
	line=""
	stty -echo
		
	if [ "$first_char" != "" ]; then
		x="$1"
	else
		read -rn1 x
	fi
	if [ "$x" == "" ]; then
		unset IFS
		return
	elif [ "$x" == "" ]; then
		unset IFS
		return
	fi
	if [ "$only_numbers" == true ] && [ "$x" != "" ] && [ "$x" != "-" ]; then
		if [ "$(isnum "$x")" == "0" ]; then
			unset IFS
			return 1
		fi
	fi

	echo -ne "$x" >/dev/stderr
	if [ "$VOICE_ENABLED" == true ]; then
		if [ "$x" == "-" ]; then
			gtts_speak "negative"
		elif [ "$x" == "." ]; then
			gtts_speak "point"
		else
			gtts_speak " $x"
		fi
	fi


	if [ "$x" != "" ]; then
		line="$x"
	fi

	read -rn1 x
	while [ -n "$x" ]; do
		if [ "$only_numbers" == true ] && [ "$x" != "" ] && [ "$x" != "" ]; then
			if [ "$(isnum "$x")" == "0" ]; then
				unset IFS
				return 1
			fi
		fi
		if [ "$x" == "" ]; then
			unset IFS
			return
		elif [ "$x" == "" ]; then
			if [ "${#line}" -lt "1" ]; then
				read -rn1 x
				continue
			fi
			line="$(echo "${line}" | rev | cut -c2- | rev)"
			echo -ne "\b \b" >/dev/stderr
			read -rn1 x
			continue
		elif [ "$x" == "" ]; then
			echo -n "$line"
			unset IFS
			return
		else
			line="$line$x"
		fi

		echo -ne "$x" >/dev/stderr
		if [ "$VOICE_ENABLED" == true ]; then
			if [ "$x" == "-" ]; then
				gtts_speak "negative"
			elif [ "$x" == "." ]; then
				gtts_speak "point"
			else
				gtts_speak " $x"
			fi
		fi
		read -rn1 x
		if [ "$only_numbers" == true ] && [ "$x" != "" ]; then
			if [ "$(isnum "$x")" == "0" ]; then
				unset IFS
				return 1
			fi
		fi
	done

	unset IFS
	echo -n "$line"
}

read_number() {
	stty -echo
	number="0"
	echo -ne "$number" >/dev/stderr
	read -rn1 x
	if [ "$x" == "" ]; then
		return
	fi
	while [ -n "$x" ]; do
		if [ "$x" == "j" ]; then
			if [ "$number" -gt "-12" ]; then
				for i in $(seq 1 ${#number}); do
					echo -ne "\b" >/dev/stderr
					if [ "$number" == "10" ]; then
						echo -ne " \b" >/dev/stderr
					fi
				done
				number="$((number-1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "k" ]; then
			if [ "$number" -lt "12" ]; then
				for i in $(seq 1 ${#number}); do
					echo -ne "\b" >/dev/stderr
					if [ "$number" == "-10" ] || [ "$number" == "-1" ]; then
						echo -ne " \b" >/dev/stderr
					fi
				done
				number="$((number+1))"
				echo -ne $number >/dev/stderr
				gtts_speak " $number"
			fi
		elif [ "$x" == "-" ]; then
			for i in $(seq 1 ${#number}); do
				echo -ne "\b" >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			if [ "$VOICE_ENABLED" == true ]; then
				gtts_speak " $x"
			fi
			tmp="$(read_line)"
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$tmp" == "" ]; then
				echo -ne ""
				return
			fi
			if [ "$(isnum "$tmp")" != "0" ]; then
				echo -ne "-$tmp"
				return
			fi
		elif [ "$(isnum "$x")" != "0" ]; then
			for i in $(seq 1 ${#number}); do
				echo -ne "\b" >/dev/stderr
			done
			echo -ne "$x" >/dev/stderr
			gtts_speak " $x"
			tmp=""
			if [ "$tmp" == "" ]; then
				echo -ne "$x"
				return
			elif [ "$(isnum "$tmp")" != "0" ]; then
				echo -ne "$x$tmp"
				return
			fi
		elif [ "$x" == "" ]; then
			echo -e ""
			return
		elif [ "$x" == "q" ]; then
			echo -e ""
			return
		elif [ "$x" == "" ]; then
			break
		fi
		read -rsn1 x
	done
	echo -ne "$number"
	return
}

reset_dimensions() {
	if [ "$LINES" != "$old_LINES" ] || [ "$COLUMNS" != "$old_COLUMNS" ]; then
		DIMENSIONS_RESET=true
	fi
	render_all_help_screens
}

redraw_screen() {
	reset_buffer

	if [ "$2" == "" ]; then
		draw_volume
		draw_equalizer
		draw_pitch
		draw_position
	else
		if [ "$2" == "1" ]; then
			draw_volume
		fi
		if [ "$3" == "1" ]; then
			draw_equalizer
		fi
		if [ "$4" == "1" ]; then
			draw_pitch
		fi
		if [ "$5" == "1" ]; then
			draw_position
		fi
	fi

	redraw_buffer
	if [ "$NO_VERTICAL_PADDING" == false ]; then
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
	fi
}

reset_buffer() {
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi
	original_number_per_page="$number_per_page"

	BUFFER=""

	HALF="$((POSITION % number_per_page + (number_per_page/2 + 1)))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		HALF="1"
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
		number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$((number_per_page*2 - 1))" ]; then
		HALF="$((POSITION-original_number_per_page/2))"
	fi

	if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
		number_per_page="$TOTAL_QUEUE"
		FLAGGED=true
	fi

	half_page="$((number_per_page/2))"

	if [ "$POSITION" -gt "$half_page" ]; then
		if [ "$((number_per_page % 2))" != "" ]; then
			HALF=$(((POSITION - (half_page))))
		else
			HALF=$((1+(POSITION - (half_page))))
		fi

		if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$((TOTAL_QUEUE-number_per_page+1))"
		fi
	fi

	HALF_OFFSET="0"
	if [ "$HALF" -lt "1" ]; then
		HALF_OFFSET="$((HALF*-1)) - 1"
		HALF="1"
	fi

	pos_on_page=0
	_last=$((HALF+(number_per_page)-HALF_OFFSET))
	diff=$((_last-HALF))
	if [ "$TOTAL_QUEUE" -lt "$diff" ]; then
		diff="$TOTAL_QUEUE"
	fi

	for i in $(seq 1 "$diff"); do
		pos=$((i-1+HALF))
		new_line="${queue_array[i+HALF-2]}"
		orig_line="$new_line"

		line="$(get_metadata "$pos")"

		ext=${orig_line##*.}
		filename_without_ext=${orig_line%%.*}

		_REP="$WHITE"
		if [ "$pos" == "$POSITION" ] && [ "$PANELS_ENABLED" == true ]; then
			_REP="$WHITE_BLACK"
		fi

		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			if [ "$pos" == "$POSITION" ] && [ "$PANELS_ENABLED" ]; then
				REP="$BLUE_BLACK"
			else
				REP="$BLUE"
			fi
		else
			REP=""
		fi

		if [ -e "$orig_line.locked" ]; then
			if [ -e "$orig_line.repeats" ]; then
				INDICATOR="${_REP}$REP#"
			else
				INDICATOR="${_REP}$"
			fi
		else
			if [ -e "$orig_line.repeats" ]; then
				INDICATOR="${_REP}$REP&"
			else
				INDICATOR="${_REP} "
			fi
		fi
		
		if (( pos < 10 && TOTAL_QUEUE > 9 )); then
			pad="0"
			display_pad=" "
		else
			pad=""
			display_pad=""
		fi

		pos_on_page=$((pos_on_page+1))
		
		if [ "$pos" == "$POSITION" ]; then
			offset="$((COLUMNS - 11 - ${#pos} - ${#pad}))"
		else
			offset="$((COLUMNS - 5 - ${#pos} - ${#pad}))"
		fi
		if [ "${#line}" -gt "$offset" ]; then
			line="${line## .*}"
			line="${line:0:$((offset-1))}…"
		fi
		if [[ "$line" == *" - "* ]]; then
			first_part="${line%% - *}"
			second_part="${line##* - }"
			combined=false
		else
			combined=true
		fi

		if [ "$combined" == false ]; then
			line="$first_part - $second_part"
		fi

		if [ "$pos" == "$POSITION" ]; then
			SONG_LENGTH="$(ffprobe -i "$new_line" -show_entries format=duration -v quiet -of csv="p=0" | cut -d'.' -f1)"
			if [ "$SONG_LENGTH" == "" ]; then
				SONG_LENGTH="--:--"
			else
				SONG_LENGTH="$(date -u -d @$SONG_LENGTH +%H:%M:%S)"
			fi
			IFS=':' read -r hours minutes seconds <<< "$SONG_LENGTH"
			if [ "$hours" != "00" ]; then
				buf_space="$(printf '%*s' $((COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-8)) "")"
				APPEND_BLACK="${BLUE_BLACK}$hours${WHITE_BLACK}:${BLUE_BLACK}"
				APPEND="${BLUE}$hours${WHITE}:$BLUE"
			else
				buf_space="$(printf '%*s' $((COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3-5)) "")"
				APPEND=""
				APPEND_BLACK=""
			fi
		else
			buf_space="$(printf '%*s' $((COLUMNS-${#pos}-${#pad}-(${#PADDING}*2)-${#line}-3)) "")"
		fi
		if [ "$PANELS_ENABLED" == true ] && [ "$pos" == "$POSITION" ]; then
			BUFFER="$BUFFER$BLUE_BLACK$PADDING$BLUE_BLACK$INDICATOR$BLUE_BLACK $BLUE_BLACK$display_pad$BLUE_BLACK$pos $line$buf_space$APPEND_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING$(tput sgr0)\n"
			LOCKING_POS="$((i-1))"
		else
			if [ "$PANELS_ENABLED" == false ]; then
				if [ "$pos" == "$POSITION" ]; then
					BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $BLUE$display_pad$BLUE$pos $line$buf_space$APPEND$BLUE$minutes$WHITE:$BLUE$seconds$PADDING\n"
					LOCKING_POS="$((i-1))"
				else
					BUFFER="$BUFFER$PADDING$WHITE$INDICATOR $BLUE$display_pad$BLUE$pos $WHITE$line$buf_space$PADDING\n"
				fi
			else
				BUFFER="$BUFFER$PADDING$BLUE$INDICATOR $display_pad$BLUE$pos $WHITE$line$buf_space$PADDING\n"
			fi
		fi
	done
}

cleanup_sigint() {
	kill "$ESPEAK_PID" "$MPLAYER_PID" >/dev/null 2>/dev/null
	kill "$(cat "$ALETHEIA/espeak.pid" 2>/dev/null)" >/dev/null 2>/dev/null
	pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	if [ "$WEB_CLIENT" == "1" ]; then
		kill "$NODE_PID" >/dev/null 2>/dev/null
	fi
	echo -ne "$NOCOLOR"
	clear
	tput cnorm
	stty ixon
	stty echo
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	exit 1
}

cleanup() {
	kill "$ESPEAK_PID" >/dev/null 2>/dev/null
	kill "$(cat "$ALETHEIA/espeak.pid" 2>/dev/null)" >/dev/null 2>/dev/null
	pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	tmp_volume_left="$(echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1)"
	tmp_volume_right="$(echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1)"
	if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ $SYSTEM_VOLUME_LEFT >/dev/null 2>/dev/null
	elif [ "$tmp_volume_left" -lt "$tmp_volume_right" ]; then
		pactl set-sink-volume @DEFAULT_SINK@ $SYSTEM_VOLUME_RIGHT >/dev/null 2>/dev/null
	fi
	echo -ne "$NOCOLOR"
	tput cnorm
	stty ixon
	stty echo
	rm -f "$ALETHEIA/pipe$$" >/dev/null 2>/dev/null
	rm -f "$ALETHEIA/web_client_pipe$$" >/dev/null 2>/dev/null
	kill "$MPLAYER_PID" 2>/dev/null >/dev/null
	exit 0
}

redraw_buffer() {
	echo -ne "$NOCOLOR"
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup 1
	else
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
		tput cup 2
	fi
	echo -ne "$BUFFER"

	if [ "$number_per_page" -lt "$TOTAL_QUEUE" ]; then
		number_per_page=$TOTAL_QUEUE
	fi

	if [ "$((COLUMNS-TOTAL_QUEUE-4))" -gt "0" ]; then
		empty_pane $((2+TOTAL_QUEUE))
	fi

	tput cup $((LINES-2))
}

empty_pane() {
	tput civis
	lineno=$1
	stop=$2
	pane=$((LINES-2))

	if [ -n "$stop" ]; then
		pane=$stop
	fi

	if [ "$NO_VERTICAL_PADDING" == false ]; then
		tput cup 1
		tput el
		tput cup $((LINES-2))
		tput el
	fi

	if [ "$lineno" == "" ]; then
		lineno="1"
	fi

	for (( i=lineno; i <= pane; i++ )); do
		tput cup "$i"
		tput el
	done
}

draw_volume() {
	tput cup 0

	tmp_volume_left=${SYSTEM_VOLUME_LEFT%\%}
	tmp_volume_right=${SYSTEM_VOLUME_RIGHT%\%}
	if [ "$tmp_volume_left" == "" ]; then
		tmp_volume_left="0"
		tmp_volume_right="0"
	fi
	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	echo -ne "$BLUE_BLACK$PADDING$VOLUME$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_left$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$tmp_volume_right"
	printf '%*s' $((COLUMNS - (${#CORNER_DIVIDER}*2) - ${#equal} -${#VOLUME} - (${#PADDING}*2) - ${#tmp_volume_left} - ${#tmp_volume_right})) ""
	echo -ne "$NOCOLOR"
}

draw_position() {
	RIGHT_BANNER_WIDTH=0
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
	tput cup $LINES $((COLUMNS-${#POSITION} - ${#TOTAL_QUEUE} - 1 - (${#CORNER_DIVIDER}*2) - ${#PADDING}))
	if [ "$LOOP" == true ]; then
		center="1"
	elif [ "$LOOP_ARTIST" == true ]; then
		center="2"
	elif [ "$TRACK_RANDOM" == true ]; then
		center="3"
	elif [ "$ONLY_LOCKED" == true ]; then
		center="4"
	else
		center="0"
	fi
	echo -ne "$BLUE_BLACK$POSITION$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$TOTAL_QUEUE$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$center$PADDING$NOCOLOR"
	return
}

yt_artist() {
	if which yt_artist; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "artist" yt_artist "$(echo "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)" 1
		else
			tmux new-session -s "artist" yt_artist "$(echo "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)" 0
		fi
		tput civis
		gtts_speak "closed" true
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

yt_search() {
	if which yt_search; then
		if [ "$VOICE_ENABLED" == true ]; then
			tmux new-session -s "search" yt_search 1 "$(echo "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)"
		else
			tmux new-session -s "search" yt_search 0 "$(echo "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)"
		fi
		gtts_speak "closed" true
		tput civis
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

tmux_attach() {
	if which yt_search; then
		gtts_speak "attached"
		tmux attach >/dev/null 2>/dev/null
		tput civis
		gtts_speak "closed" true
		draw_pitch
		draw_position
		redraw_screen true
	else
		gtts_speak "feature not installed"
	fi
}

toggle_panels() {
	if [ "$PANELS_ENABLED" == true ]; then
		gtts_speak "panels disabled"
		PANELS_ENABLED=false
		if [ "$COLORS_ENABLED" == false ]; then
			BLUE_BLACK="${ESC}1;37m"
			WHITE_BLACK="${ESC}1;37m"
		else
			BLUE_BLACK="${BLUE}"
			WHITE_BLACK="${WHITE}"
		fi
	else
		gtts_speak "panels enabled"
		PANELS_ENABLED=true
		if [ "$COLORS_ENABLED" == false ]; then
			BLUE_BLACK="${ESC}1;37;1;40m"
			WHITE_BLACK="${ESC}1;37;1;40m"
		else
			color="${COLOR_PANEL#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))
			BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
		fi
	fi
	reset_buffer
	draw_volume
	draw_equalizer
	if [ "$1" == true ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
}

draw_select_color_indicator() {
	RIGHT_BANNER_WIDTH="29"
	if [ "$((COLUMNS-RIGHT_BANNER_WIDTH-LEFT_BANNER_WIDTH-2-(${#PADDING}*2)))" -gt "1" ]; then
		tput cup $LINES $((COLUMNS-${#PADDING}-RIGHT_BANNER_WIDTH))
		echo -ne "${BLUE_BLACK}v:${WHITE_BLACK}invert ${BLUE_BLACK}#:${WHITE_BLACK}save ${BLUE_BLACK}n:${WHITE_BLACK}next ${BLUE_BLACK}b:${WHITE_BLACK}back$PADDING"
		echo -ne "$COLOR_TEXT"
	else
		draw_position
	fi
}

select_color() {
	orig_BLUE=$BLUE
	orig_BLUE_BLACK=$BLUE_BLACK
	orig_WHITE=$WHITE
	orig_WHITE_BLACK=$WHITE_BLACK
	orig_COLOR_ACCENT=$COLOR_ACCENT
	SKIP_SPEAK_MENU=true
	gtts_speak "select color"
	char=""
	index=0
	unset color_array
	color_array[0]="${BLUE}X${BLUE_BLACK}X${WHITE}X${WHITE_BLACK}X${COLOR_ACCENT}"
	until [ "$char" == "q" ]; do
		if [ "$char" == "n" ]; then
			gtts_speak "next color"
			if [ "$index" -lt "$((${#color_array[@]}-1))" ]; then
				IFS=X read -r BLUE BLUE_BLACK WHITE WHITE_BLACK COLOR_ACCENT <<< "${color_array[index]}"
				((index++))
			else
				panel_color=$(generate_panel_color $DARK_BACKGROUND)
				color="${panel_color#"#"}"
				panel_red=$((16#${color:0:2}))
				panel_green=$((16#${color:2:2}))
				panel_blue=$((16#${color:4:2}))

				primary_color=$(generate_random_color ${!DARK_BACKGROUND})
				color="${primary_color#"#"}"
				primary_red=$((16#${color:0:2}))
				primary_green=$((16#${color:2:2}))
				primary_blue=$((16#${color:4:2}))
				BLUE="${ESC}1;38;2;${primary_red};${primary_green};${primary_blue}m"

				secondary_color=$(generate_random_color ${!DARK_BACKGROUND})
				color="${secondary_color#"#"}"
				secondary_red=$((16#${color:0:2}))
				secondary_green=$((16#${color:2:2}))
				secondary_blue=$((16#${color:4:2}))
				WHITE="${ESC}1;38;2;${secondary_red};${secondary_green};${secondary_blue}m"
				WHITE_BLACK="${ESC}1;38;2;${secondary_red};${secondary_green};${secondary_blue}m"

				if [ "$PANELS_ENABLED" == true ]; then
					WHITE_BLACK="${ESC}1;38;2;$secondary_red;$secondary_green;$secondary_blue;48;2;$panel_red;$panel_green;${panel_blue}m"
					BLUE_BLACK="${ESC}1;38;2;$primary_red;$primary_green;$primary_blue;48;2;$panel_red;$panel_green;${panel_blue}m"
				else
					WHITE_BLACK="$WHITE"
					BLUE_BLACK="$BLUE"
				fi
				COLOR_ACCENT="${ESC}1;38;2;$panel_red;$panel_green;${panel_blue}m"
				((index++))
				color_array[$index]="${BLUE}X${BLUE_BLACK}X${WHITE}X${WHITE_BLACK}X${COLOR_ACCENT}"
			fi
		elif [ "$char" == "b" ]; then
			if [ "$index" -ge 1 ]; then
				((index--))
				gtts_speak "previous color"
				IFS=X read -r BLUE BLUE_BLACK WHITE WHITE_BLACK COLOR_ACCENT <<< "${color_array[index]}"
			fi
		elif [ "$char" == "#" ]; then
			DEFAULT_THEME=false
			COLORS_ENABLED=true
			_save_setting "DEFAULT_THEME" "$DEFAULT_THEME"
			_save_setting "COLORS_ENABLED" "$COLORS_ENABLED"
			clean_sequence=${BLUE#*\033}
			clean_sequence=${clean_sequence%m}
			IFS=';' read -ra color_values <<< "$clean_sequence"
			r=$(printf "%02x" "${color_values[3]}")
			g=$(printf "%02x" "${color_values[4]}")
			b=$(printf "%02x" "${color_values[5]}")
			hex_color="#$r$g$b"
			_save_setting "COLOR_HIGHLIGHT" "$hex_color"
			clean_sequence=${WHITE#*\033}
			clean_sequence=${clean_sequence%m}
			IFS=';' read -ra color_values <<< "$clean_sequence"
			r=$(printf "%02x" "${color_values[3]}")
			g=$(printf "%02x" "${color_values[4]}")
			b=$(printf "%02x" "${color_values[5]}")
			hex_color="#$r$g$b"
			_save_setting "COLOR_UNSELECTED" "$hex_color"
			if [ "$PANELS_ENABLED" == true ]; then
				clean_sequence=${BLUE_BLACK#*\033}
				clean_sequence=${clean_sequence%m}
				IFS=';' read -ra color_values <<< "$clean_sequence"
				r=$(printf "%02x" "${color_values[8]}")
				g=$(printf "%02x" "${color_values[9]}")
				b=$(printf "%02x" "${color_values[10]}")
				hex_color="#$r$g$b"
				_save_setting "COLOR_PANEL" "$hex_color"
			fi
			echo -e "$CONFIG" >"$ALETHEIA/config"
			draw_banner "SAVED"
			draw_position
			tput el
			gtts_speak "color saved"
			sleep $BANNER_WAIT_TIME
			break
		elif [ "$char" == "v" ]; then
			tmpBLUE=$BLUE
			tmpBLUE_BLACK=$BLUE_BLACK
			BLUE=$WHITE
			BLUE_BLACK=$WHITE_BLACK
			WHITE=$tmpBLUE
			WHITE_BLACK=$tmpBLUE_BLACK
			gtts_speak "color inverted"
		fi
		reset_buffer
		draw_volume
		draw_equalizer
		if [ "$1" != true ]; then
			redraw_buffer
		else
			draw_menu
		fi
		draw_select_color_indicator
		draw_banner "COLOR" false false true
		if [ "$flaggy" != true ]; then
			read -rsn1 char
		else
			flaggy=false
		fi
	done
	RIGHT_BANNER_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+3))"
	if [ "$char" != "q" ]; then
		draw_banner "WAIT"
		render_all_help_screens
	else
		SKIP_SPEAK_MENU=false
		draw_banner "WAIT"
		draw_position
		BLUE=$orig_BLUE
		BLUE_BLACK=$orig_BLUE_BLACK
		WHITE=$orig_WHITE
		WHITE_BLACK=$orig_WHITE_BLACK
		COLOR_ACCENT=$orig_COLOR_ACCENT
		reset_buffer
	fi
	if [ "$1" != true ]; then
		redraw_screen
	fi
}

toggle_dark_mode() {
	if [ -z "$TOGGLE_CUSTOM" ]; then
		TOGGLE_CUSTOM=false
	fi
	if [ "$DARK_BACKGROUND" == true ] && [ "$TOGGLE_CUSTOM" == false ]; then
		DARK_BACKGROUND=false
		TOGGLE_CUSTOM=false
		DEFAULT_THEME=true
		draw_banner "LIGHT"
		gtts_speak "light theme"
	elif [ "$DARK_BACKGROUND" == false ] && [ "$TOGGLE_CUSTOM" == false ]; then
		DARK_BACKGROUND=true
		TOGGLE_CUSTOM=true
		DEFAULT_THEME=true
		draw_banner "DARK"
		gtts_speak "dark theme"
	else
		TOGGLE_CUSTOM=false
		DEFAULT_THEME=false
		draw_banner "CUSTOM"
		gtts_speak "custom color"
	fi
	menu_start_over=true
	sleep $BANNER_WAIT_TIME

	if [ "$DEFAULT_THEME" == true ]; then
		if [ "$DARK_BACKGROUND" == true ]; then
			COLOR_UNSELECTED="#CCCCCC"
			COLOR_PANEL="#272727"
			COLOR_HIGHLIGHT="#83B7E6"
		elif [ "$DARK_BACKGROUND" == false ]; then
			COLOR_UNSELECTED="#333333"
			COLOR_PANEL="#E2E2E2"
			COLOR_HIGHLIGHT="#336699"
		fi
		color="${COLOR_UNSELECTED#"#"}"
		red=$((16#${color:0:2}))
		green=$((16#${color:2:2}))
		blue=$((16#${color:4:2}))
		WHITE="${ESC}1;38;2;$red;$green;${blue}m"

		color="${COLOR_HIGHLIGHT#"#"}"
		red=$((16#${color:0:2}))
		green=$((16#${color:2:2}))
		blue=$((16#${color:4:2}))
		BLUE="${ESC}1;38;2;$red;$green;${blue}m"

		color="${COLOR_PANEL#"#"}"
		red=$((16#${color:0:2}))
		green=$((16#${color:2:2}))
		blue=$((16#${color:4:2}))

		COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"
	else
		value="$(read_config "COLOR_HIGHLIGHT")"
		if [ "$value" != "" ]; then
			COLOR_HIGHLIGHT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			BLUE="${ESC}1;38;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_UNSELECTED")"
		if [ "$value" != "" ]; then
			COLOR_UNSELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			WHITE="${ESC}1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue};1;40m"
			else
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue}m"
			fi
		fi

		value="$(read_config "COLOR_PANEL")"
		if [ "$value" != "" ]; then
			COLOR_PANEL="$value"

			colorblue="${COLOR_PANEL#"#"}"
			red=$((16#${colorblue:0:2}))
			green=$((16#${colorblue:2:2}))
			blue=$((16#${colorblue:4:2}))

			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
				BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			fi
			COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"
		fi
	fi

	if [ "$PANELS_ENABLED" == true ]; then
		WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
		BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
	else
		WHITE_BLACK="$WHITE"
		BLUE_BLACK="$BLUE"
	fi
	render_all_help_screens
}

toggle_colors() {
	draw_wait false
	if [ "$COLORS_ENABLED" == false ]; then
		COLORS_ENABLED=true
		value="$(read_config "COLOR_HIGHLIGHT")"
		if [ "$value" != "" ]; then
			COLOR_HIGHLIGHT="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			BLUE="${ESC}1;38;2;${red};${green};${blue}m"
		fi

		value="$(read_config "COLOR_UNSELECTED")"
		if [ "$value" != "" ]; then
			COLOR_UNSELECTED="$value"

			color="${value#"#"}"
			red=$((16#${color:0:2}))
			green=$((16#${color:2:2}))
			blue=$((16#${color:4:2}))

			WHITE="${ESC}1;38;2;${red};${green};${blue}m"
			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue};1;40m"
			else
				WHITE_BLACK="${ESC}1;38;2;${red};${green};${blue}m"
			fi
		fi

		value="$(read_config "COLOR_PANEL")"
		if [ "$value" != "" ]; then
			COLOR_PANEL="$value"

			colorblue="${COLOR_PANEL#"#"}"
			red=$((16#${colorblue:0:2}))
			green=$((16#${colorblue:2:2}))
			blue=$((16#${colorblue:4:2}))

			if [ "$PANELS_ENABLED" == true ]; then
				WHITE_BLACK="${WHITE%m};48;2;$red;$green;${blue}m"
				BLUE_BLACK="${BLUE%m};48;2;$red;$green;${blue}m"
			fi
			COLOR_ACCENT="${ESC}1;38;2;$red;$green;${blue}m"
		fi
	else
		COLORS_ENABLED=false
		PANELS_ENABLED=true
		BLUE_BLACK="${ESC}1;37;1;40m"
		WHITE_BLACK="${ESC}1;37;1;40m"
		RED="${ESC}0;37m"
		BLUE="${ESC}0;37m"
		WHITE="${ESC}0;37m"
	fi
	render_all_help_screens
	if [ "$1" != true ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" != true ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	if [ "$COLORS_ENABLED" == false ]; then
		gtts_speak "color disabled"
	else
		gtts_speak "color enabled"
	fi
}

invert_colors() {
	local orig_blue=$BLUE
	local orig_blue_black=$BLUE_BLACK
	BLUE=$WHITE
	WHITE=$orig_blue
	BLUE_BLACK=$WHITE_BLACK
	WHITE_BLACK=$orig_blue_black
	draw_wait false
	render_all_help_screens
	if [ "$1" == false ] || [ "$1" == "" ]; then
		reset_buffer
	fi
	draw_volume
	draw_equalizer
	if [ "$1" == false ] || [ "$1" == "" ]; then
		redraw_buffer
		draw_pitch
	fi
	draw_position
	gtts_speak "color inverted"
}

draw_wait() {
	local clear_screen=$1
	if [ "$clear_screen" != true ]; then
		echo -ne "$NOCOLOR"
		clear
	fi
	tput cup $((LINES/2)) $(((COLUMNS/2)-5))
	echo -ne "$NOCOLOR${WHITE}-- ${BLUE}WAIT ${WHITE}--$NOCOLOR"
	gtts_speak "wait" false true
}

web_client_func() {
	if [ "$WEB_CLIENT" == "1" ]; then
		number_per_page="4"
		original_number_per_page="$number_per_page"

		BUFFER=""

		HALF="$((POSITION % number_per_page + (number_per_page/2 + 1)))"

		if [ "$POSITION" -lt "$number_per_page" ]; then
			HALF="1"
		elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
			number_per_page="$original_number_per_page"
		elif [ "$POSITION" -gt "$((number_per_page*2 - 1))" ]; then
			HALF="$((POSITION-original_number_per_page/2))"
		fi

		if [ "$TOTAL_QUEUE" -le "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi

		half_page="$((number_per_page/2))"

		if [ "$POSITION" -gt "$half_page" ]; then
			if [ "$((number_per_page % 2))" != "" ]; then
				HALF=$(((POSITION - (half_page))))
			else
				HALF=$((1+(POSITION - (half_page))))
			fi

			if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				HALF="$((TOTAL_QUEUE-number_per_page+1))"
			fi
		fi

		HALF_OFFSET="0"
		if [ "$HALF" -lt "1" ]; then
			HALF_OFFSET="$((HALF * -1)) - 1"
			HALF="1"
		fi

		COLOR2="$BLUE"

		pos_on_page=0
		_last=$((HALF+number_per_page-HALF_OFFSET))
		if [ "$((_last-HALF))" -lt "5" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			if [ "$POSITION" == "$TOTAL_QUEUE" ] || [ "$POSITION" == "$((TOTAL_QUEUE-1))" ]; then
				HALF=$((_last-5))
			fi
		fi
		if [ "$HALF" == "1" ]; then
			HALF=2
			_last=$((_last+1))
		fi
		lines="$(printf '%s\n' "${queue_array[@]}" | sed -n "$((HALF-1)),$((_last-1))p")"
		diff=$((_last-HALF))
		if [ "$POSITION" -lt "3" ]; then
			pos=$POSITION
		else
			pos=2
		fi
		echo -ne "$lines" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/\n/<br\/>/g" >"$ALETHEIA/current_queue"
		if [ "$POSITION" -lt "3" ]; then
			pos=$((pos-1))
		elif [ "$POSITION" -gt "$((TOTAL_QUEUE-1))" ]; then
			pos=$((pos+1))
		fi
		if [ "$POSITION" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=4
		elif [ "$POSITION" == "$((TOTAL_QUEUE-1))" ] && [ "$TOTAL_QUEUE" -ge "5" ]; then
			pos=3
		fi
		echo -ne "$pos" >"$ALETHEIA/current_pos"
	fi
}

say_locked_and_loops() {
	while true; do
		if ! ps aux | pgrep -f "^play.*$ALETHEIA/voices.*$" >/dev/null 2>/dev/null; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "locked" true false true
	gtts_speak "$INTERVAL" true false true
	gtts_speak "$EDO" true false true
	sleep 0.2
	gtts_speak "$REPEAT_TOTAL" true false true
	if [ "$REPEAT_TOTAL" == "1" ]; then
		gtts_speak "loop" true false true
	else
		gtts_speak "loops" true false true
	fi
}

say_unlocked_and_loops() {
	while true; do
		if ! ps aux | pgrep -f "^play.*$ALETHEIA/voices.*$" >/dev/null 2>/dev/null; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "unlocked" true false true
	gtts_speak "$REPEAT_TOTAL" true false true
	if [ "$REPEAT_TOTAL" == "1" ]; then
		gtts_speak "loop" true false true
	else
		gtts_speak "loops" true false true 
	fi
}

say_locked_and_no_loops() {
	while true; do
		if ! ps aux | pgrep -f "^play.*$ALETHEIA/voices.*$" >/dev/null 2>/dev/null; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "locked" true false true
	gtts_speak "$(echo -ne "$INTERVAL" | sed "s/\-/negative /g")" true false true
	gtts_speak "$EDO" true false true
	gtts_speak "no loops" true false true
}

say_unlocked_and_no_loops() {
	while true; do
		if ! ps aux | pgrep -f "^play.*$ALETHEIA/voices.*$" >/dev/null 2>/dev/null; then
			break
		fi
		sleep 0.1
	done
	gtts_speak "unlocked" true false true
	gtts_speak "no loops" true false true
}

jump_to_first_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | head -1 | cut -d':' -f1)"
	kill "$MPLAYER_PID" >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

jump_to_last_of_artist() {
	artist=$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)
	JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -ne "/$artist -" | tail -1 | cut -d':' -f1)"
	kill "$MPLAYER_PID" >/dev/null 2>/dev/null
	return $RETURN_JUMP
}

load_only_loops() {
	if [ "$LOOPS_ONLY" == false ] || [ "$1" == true ]; then
		draw_banner "WAIT"
		if [ "$ONLY_LOCKED" == true ]; then
			gtts_speak "only locked loops"
		else
			gtts_speak "loops" true
		fi
		artist="$(echo -ne "$TITLE" | sed -e "s/ - //g" | cut -d'' -f1)"
		if [ "$LOOP_ARTIST" == true ]; then
			if [ "$(find "$MUSICDIR" | grep -e "^$artist - " | grep -e "\.repeats$")" == "" ]; then
				LOOP_ARTIST=false
			fi
		fi
		if [ "$ONLY_LOCKED" == true ]; then
			regex=".*\.\(${AUDIO_FORMATS//,/\.locked\\|}\.locked\)$"
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $(find "$MUSICDIR" -type f -regex "$regex" -and -not -iname "*.repeat.*" | sort); do
				var1="$(echo -ne "$i" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$var1.repeats" ]; then
					queue_array[$index]="$var1"
					index=$((index+1))
				fi
			done
			unset IFS
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $(find "$MUSICDIR" -iname "*\.repeats" | shuf | sed -e "s/\.repeats$//g"); do
				if [ -e "$i" ]; then
					queue_array[$index]="$i"
					index=$((index+1))
				fi
			done
			unset IFS
		fi
		SHUFFLED=true
		TOTAL_QUEUE="$index"
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1 | head -1)"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
	else
		draw_banner "WAIT"
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
		unset queue_array
		IFS=$'\n'
		index=0
		for i in $(find "$MUSICDIR" -type f -regex "$regex" | shuf); do
			queue_array[$index]="$i"
			index=$((index+1))
		done
		unset IFS
		SHUFFLED=true
		TOTAL_QUEUE=$index
		tmp="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
		if [ "$tmp" != "" ]; then
			POSITION="$tmp"
		else
			POSITION=1
		fi
		reset_buffer
		redraw_buffer
	fi
}

process_key() {
	case "$1" in
	'[')
		system_volume_change false 1 0
		;;
	']')
		system_volume_change false 0 1
		;;
	'{')
		system_volume_change true 1 0
		;;
	'}')
		system_volume_change true 0 1
		;;
	esac
}

generate_panel_color() {
	dark="$1"
	if [ "$dark" == true ]; then
		printf "#%02x%02x%02x" $((RANDOM%92+20)) $((RANDOM%92+20)) $((RANDOM%92+20))
	else
		printf "#%02x%02x%02x" $((RANDOM%56+200)) $((RANDOM%56+200)) $((RANDOM%56+200))
	fi
}

generate_random_color() {
	dark=$1
	l=$((RANDOM%3+1))
	if [ "$l" == 1 ]; then
		if [ "$dark" == true ]; then
			first=$((RANDOM%92+20))
		else
			first=$((RANDOM%56+200))
		fi
	else
		first=$((RANDOM%256))
	fi
	if [ "$l" == 2 ]; then
		if [ "$dark" == true ]; then
			second=$((RANDOM%92+20))
		else
			second=$((RANDOM%56+200))
		fi
	else
		second=$((RANDOM%256))
	fi

	if [ "$l" == 3 ]; then
		if [ "$dark" == true ]; then
			third=$((RANDOM%92+20))
		else
			third=$((RANDOM%56+200))
		fi
	else
		third=$((RANDOM%256))
	fi
	printf "#%02x%02x%02x\n" $first $second $third
}

load_loop_file() {
	if [ "$LOOP_ON" == false ]; then
		LOOP_ON=true
		ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
		filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
		if [ -e "$filename_without_ext.repeat.$ext" ]; then
			echo "volume 0 1" >"$ALETHEIA/pipe$$" &
			draw_banner "LOOP ON"
			gtts_speak "loading loop"
			sleep $MPLAYER_WAIT_TIME
			if [ -e "$filename_without_ext.repeat.$ext.repeats" ]; then
				REPEATS="$(cat "$filename_without_ext.repeat.$ext.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$filename_without_ext.repeat.$ext.locked" ]; then
				read_locked_file "$(cat "$filename_without_ext.repeat.$ext.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			fi
			sleep 0.05
			echo -e "loadfile '$filename_without_ext.repeat.$ext'" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "loop 0 1" >"$ALETHEIA/pipe$$" &
			LOOP=true
			draw_pitch
			draw_position
		else
			LOOP_ON=false
			return 1
		fi
	else
		LOOP_ON=false
		if [ -e "$FILENAME" ]; then
			echo "volume 0 1" >"$ALETHEIA/pipe$$" &
			draw_banner "LOOP OFF" 
			gtts_speak "loop disabled"
			if [ -e "$FILENAME.repeats" ]; then
				REPEATS="$(cat "$FILENAME.repeats")"
				REPEAT_CURRENT=1
				REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
			else
				REPEATS=""
				REPEAT_CURRENT=0
				REPEAT_TOTAL=0
				END_TIME=""
			fi
			if [ -e "$FILENAME.locked" ]; then
				read_locked_file "$(cat "$FILENAME.locked")"
				if [ "$_scaletempo_flag" != "0" ]; then
					if [ "$_scaletempo_flag" == "1" ]; then
						SCALETEMPO=true
						ONLY_PITCH=false
					elif [ "$_scaletempo_flag" == "2" ]; then
						SCALETEMPO=true
						ONLY_PITCH=true
					fi
				else
					SCALETEMPO=false
					ONLY_PITCH=false
				fi
			fi
			sleep 0.05
			echo -e "loadfile \"$FILENAME\"" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
			sleep 0.05
			echo -e "loop -1 1" >"$ALETHEIA/pipe$$" &
			LOOP=false
			draw_pitch
			draw_position
		fi
	fi
}

invert_int() {
	PAUSE=false
	if [ "$MUTE" == true ]; then
		echo "mute" >"$ALETHEIA/pipe$$" &
		MUTE=false
	fi
	INTERVAL="$((-(INTERVAL)))"
	echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
	gtts_speak " $INTERVAL"
	draw_pitch
}

render_all_help_screens() {
	if [ "$NO_HELP" != true ]; then
		render_help_screen
		render_repeat_help_screen
		render_scale_help_screen
		rendered=true
	else
		rendered=false
	fi
	render_setup_screen
}

get_metadata() {
	pos=$1
	if [ "$USE_TAGS" == true ]; then
		if [ -e "$ALETHEIA/music.db" ]; then
			#   ,___,
			#  ( o,o )
			#  { `" }
			# -"---"--
			x="${queue_array[$((pos-1))]##*/}"
			x="${x//\'/\'\'}"
			query_result=$(sqlite3 "$ALETHEIA/music.db" "SELECT artist, song, album FROM music WHERE filename='$x';")

			IFS='|' read -r artist song album <<< "$query_result"
		else
			artist=""
			album=""
			song=""
		fi

		if [ "$artist" == "" ] || [ "$song" == "" ]; then
			line="${queue_array[$((pos-1))]##*/}"
			line="${line%.*}"

			if [[ "$line" == *" - "* ]]; then
				artist="${line%% - *}"
				song="${line##* - }"
				line="$artist - $song"
			else
				line="${queue_array[$((pos-1))]##*/}"
				line="${line%.*}"
			fi
		else
			if [ "$album" == "" ]; then
				line="$artist ~ $song"
			else
				line="$artist ~ $album ~ $song"
			fi
		fi
	else
		line="${queue_array[$((pos-1))]}"
		line=${line##*/}
		line=${line%.*}

		if [[ "$line" == *" - "* ]]; then
			artist="${line%% - *}"
			song="${line##* - }"
			line="$artist - $song"
		fi
	fi
	echo -ne "$line"
}

draw_pitch() {
	if [ "$PAUSE" == true ]; then
		draw_banner "PAUSE"
		return
	elif [ "$MUTE" == true ]; then
		draw_banner "MUTE"
		return
	fi

	tput cup $LINES

	if [ "$SCALETEMPO" == true ]; then
		if [ "$ONLY_PITCH" == true ]; then
			toggle=2
		else
			toggle=1
		fi
	else
		toggle=0
	fi

	echo -ne "$BLUE_BLACK$PADDING$INTERVAL$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$EDO$WHITE_BLACK$CORNER_DIVIDER${BLUE_BLACK}$toggle"

	POSITION_WIDTH="$((${#POSITION}+${#TOTAL_QUEUE}+1+(${#CORNER_DIVIDER}*2)))"
	if [ "$POSITION_WIDTH" -lt "$RIGHT_BANNER_WIDTH" ]; then
		printf '%*s' $((COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - RIGHT_BANNER_WIDTH)) ""
	else
		printf '%*s' $((COLUMNS - ${#toggle} - (${#CORNER_DIVIDER}*4) - ${#INTERVAL} - ${#EDO} - POSITION_WIDTH)) ""
	fi
	echo -ne "$NOCOLOR"
}

draw_equalizer() {
	stty -echo
	IFS=':' read -r bass _ _ _ mid _ _ treble _ _ _ <<< "$EQUALIZER"
	equal="$bass:$mid:$treble"
	tput cup 0 $((COLUMNS-${#bass}-${#mid}-${#treble}-(${#CORNER_DIVIDER}*2)-${#PADDING}))
	echo -ne "$BLUE_BLACK$bass$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$mid$WHITE_BLACK$CORNER_DIVIDER$BLUE_BLACK$treble$PADDING$NOCOLOR"
}

toggle_voice() {
	if [ "$VOICE_ENABLED" == false ]; then
		VOICE_ENABLED=true
		if [ "$1" != true ]; then
			gtts_speak "on" false true
		fi
	else
		if [ "$1" != true ]; then
			if [ "$ONLY_VOICE_TITLES" == true ]; then
				gtts_speak "reading only artist and title" false true
			else
				gtts_speak "off" false true
			fi
		fi
		VOICE_ENABLED=false
		ONLY_VOICE_TITLES=false
	fi
}

queue_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak "queue controls"
	local flagged=false
	original_number_per_page="$number_per_page"
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi

	FLAGGED=false
	if [ "$QUEUE_HELP_LENGTH" -le "$number_per_page" ]; then
		number_per_page="$QUEUE_HELP_LENGTH"
		FLAGGED=true
	fi

	pos=1
	while [ "$pos" -le "$QUEUE_HELP_LENGTH" ]; do
		buf=""
		tput cup 0
		if [ "$((QUEUE_HELP_LENGTH-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((QUEUE_HELP_LENGTH-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
			return
		fi
		for i in $(seq $pos $((pos + (number_per_page-1)))); do
			line="$(echo -e "$QUEUE_HELP" | sed -n "${i}p")"
			if [ "$(echo "$line" | cut -b2)" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
			else
				tmp1="$BLUE $(echo "$line" | cut -b1)"
				tmp2="$WHITE$(echo "$line" | cut -d' ' -f2-)"
			fi

			buf="$buf$PADDING$tmp1 $tmp2$(tput el)\n"
		done
		draw_banner "CONTROLS" false true

		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR$buf"

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$((number_per_page + 2))"
		fi

		read -rsn1 inputchar
		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$((pos+number_per_page))"
			if [ "$pos" -gt "$QUEUE_HELP_LENGTH" ]; then
				pos="$((QUEUE_HELP_LENGTH-number_per_page-1))"
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$((pos-number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$inputchar" == "d" ]; then
			echo -e "$QUEUE_HELP" | sed -n "$pos,$((pos+number_per_page-1))p" | sed "s/$/\n/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -v en-us+m1 -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		else
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			draw_pitch
			draw_position
			redraw_buffer
			empty_pane $((number_per_page+2))
			return
		fi
	done
}

scale_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak "scale controls"
	draw_banner "HELP" false true

	width="$(echo -ne "$SCALE_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#SCALE_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
			tput cup 1
		else
			number_per_page=$((LINES-4))
			tput cup 2
		fi
		original_number_per_page=$number_per_page

		echo -ne "$NOCOLOR${SCALE_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${SCALE_HELP_BUFFER[page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$((page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			echo "$SCALE_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/|/vertical slash/g" | sed "s/?/question mark/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed "s/-/ /g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "SCALE"
			draw_banner "HELP" false true
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#SCALE_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

add_downloaded() {
	regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	list=$(find "$MUSICDIR" -cnewer "$ALETHEIA/start" -regex "$regex")
	if [ "${list:0:1}" != "" ]; then
		mapfile -O $TOTAL_QUEUE -t queue_array < <(echo -ne "$list")
		DOWNLOAD_POSITION=$((TOTAL_QUEUE+1))
		TOTAL_QUEUE=${#queue_array[@]}
		if [ "$1" != true ]; then
			gtts_speak "queued downloads"
		fi
		if [ "$1" != "noposition" ]; then
			draw_position
		fi
		reset_buffer
		redraw_buffer
	else
		unset IFS
		if [ "$1" != true ]; then
			gtts_speak "nothing downloaded"
			draw_banner "NONE"
		fi
		sleep $BANNER_WAIT_TIME
		draw_pitch
		draw_position
	fi
	touch -m "$ALETHEIA/start"
}

read_corner() {
	pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	z=""
	draw_banner "READ" false false true
	while true; do
		gtts_speak "enter a corner to read from. u, upper left. i, upper right. j, lower left. k, lower right, or q to quit"
		if [ "$z" != "" ]; then
			x="$z"
		else
			read -rn1 x
		fi
		if [ "$x" == "u" ]; then
			tmp="$(echo "$SYSTEM_VOLUME_LEFT" | cut -d'%' -f1)"
			tmp2="$(echo "$SYSTEM_VOLUME_RIGHT" | cut -d'%' -f1)"
			tmp3="$(echo "$VOLUME" | cut -d'%' -f1)"
			gtts_speak "$tmp3" true false true
			read -rn1 -t 0.05 z
			if [ -n "$z" ]; then continue; fi
			gtts_speak "$tmp" true false true
			if [ "$SYSTEM_VOLUME_LEFT" != "$SYSTEM_VOLUME_RIGHT" ]; then
				read -rn1 -t 0.05 z
				if [ -n "$z" ]; then continue; fi
				gtts_speak "$tmp2" true false true
			fi
		elif [ "$x" == "i" ]; then
				res="$(echo -ne "$equal" | sed -e "s/:/, /g")"
				if [ "$res" == "0, 0, 0" ]; then
					gtts_speak "0" true false true
				else
					gtts_speak " $bass" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					gtts_speak " $mid" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					gtts_speak " $treble" true false true
				fi
		elif [ "$x" == "j" ]; then
				if [ "$LOCKED" == true ]; then
					tmp_int="$(cut -d'/' -f1 < "$FILENAME.locked")"
					gtts_speak "$EDO" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					gtts_speak "locked" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					gtts_speak "$tmp_int" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					if [ "$SCALETEMPO" == true ]; then
						gtts_speak "tempo" true false true
					fi
				else
					gtts_speak "$EDO" true false true
					read -rn1 -t 0.05 z
					if [ -n "$z" ]; then continue; fi
					if [ "$SCALETEMPO" == true ]; then
						gtts_speak "tempo" true false true
					fi
				fi
		elif [ "$x" == "k" ]; then
			gtts_speak "$POSITION" true false true
			read -rn1 -t 0.05 z
			if [ -n "$z" ]; then continue; fi
			gtts_speak "of" true false true
			read -rn1 -t 0.05 z
			if [ -n "$z" ]; then continue; fi
			gtts_speak "$TOTAL_QUEUE" true false true
			read -rn1 -t 0.05 z
			if [ -n "$z" ]; then continue; fi
			if [ "$LOOP" == true ]; then
				gtts_speak "loop enabled" true false true
			elif [ "$LOOP_ARTIST" == true ]; then
				gtts_speak "playing" true false true
				read -rn1 -t 0.05 z
				if [ -n "$z" ]; then continue; fi
				gtts_speak "$ARTIST" true false true
			elif [ "$TRACK_RANDOM" == true ]; then
				gtts_speak "random mode" true false true
			elif [ "$ONLY_LOCKED" == true ]; then
				gtts_speak "only locked" true false true
			fi
		elif [ "$x" == "I" ] || [ "$x" == "" ] || [ "$x" == "q" ]; then
			break
		else
			gtts_speak "upper left, 'u' key. upper right, 'i' key. lower left, 'j' key. lower right, 'k' key. 'q' key to exit"
			z=""
			while [ -z "$z" ]; do
				read -rn1 -t 0.1 z
				if ! ps aux | pgrep -f "^play.*$ALETHEIA/voices.*$" >/dev/null 2>/dev/null; then
					break
				fi
			done
		fi
		if [ "$z" == "I" ] || [ "$z" == "" ] || [ "$z" == "q" ]; then
			break
		fi
	done
}

sort_queue() {
	gtts_speak "sorted"

	IFS=$'\n'
	mapfile -t queue_array < <(printf "%s\n" "${queue_array[@]}" | sort)
	unset IFS
	tmp=$(printf '%s\n' "${queue_array[@]}" | grep --text -n "$FILENAME" | cut -d':' -f1 | head -1)

	POSITION="$tmp"
	web_client_func

	reset_buffer
	redraw_buffer
}

shuffle_queue() {
	gtts_speak "shuffled"

	IFS=$'\n'
	mapfile -t tmp_array < <(printf "%s\n" "${queue_array[@]}" | shuf | grep --text -v "$FILENAME")
	queue_array=("$FILENAME" "${tmp_array[@]}")
	unset IFS tmp_array

	POSITION=1
	TRACK_RANDOM=false
	POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))

	web_client_func
	reset_buffer
	redraw_buffer
}

render_setup_screen() {
	render $((SETUP_HELP_LENGTH+1)) "$(echo -ne "$SETUP_HELP" | wc -L)" "$SETUP_HELP"
	SETUP_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

render_scale_help_screen() {
	render $((SCALE_HELP_LENGTH+1)) "$(echo -ne "$SCALE_HELP" | wc -L)" "$SCALE_HELP"
	SCALE_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

setup_screen() {
	gtts_speak "settings"
	flagged=false

	width="$(echo -ne "$SETUP_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#SETUP_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page
		draw_banner "SETUP"
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${SETUP_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${SETUP_HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if $NO_VERTICAL_PADDING; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				first=1
				last=$((number_per_page*2))
			else
				first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				first=1
				last=$number_per_page
			else
				first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$((page+1))" -lt "${#SETUP_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
			fi
		elif [ "$inputchar" == "J" ]; then
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			if [ "$VOICE_PITCH" -gt "-30" ]; then
				VOICE_PITCH="$((VOICE_PITCH-1))"
			fi
			if [ ! -e "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" ]; then
				draw_banner "WAIT"
				gtts-cli " $VOICE_PITCH" -o /tmp/voice-pitch${VOICE_PITCH}.mp3 >/dev/null 2>/dev/null
				sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" speed "$(calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-)" >/dev/null 2>/dev/null
				rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"
				draw_banner "VOICE"
				draw_position
			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
		elif [ "$inputchar" == "K" ]; then
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			if [ "$VOICE_PITCH" -lt "30" ]; then
				VOICE_PITCH="$((VOICE_PITCH+1))"
			fi
			if [ ! -e "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" ]; then
				draw_banner "WAIT"
				gtts-cli " $VOICE_PITCH" -o /tmp/voice-pitch${VOICE_PITCH}.mp3
				sox "/tmp/voice-pitch${VOICE_PITCH}.mp3" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" speed "$(calc "2^($VOICE_PITCH/60)" | cut -d'~' -f2-)"
				rm -f "/tmp/voice-pitch${VOICE_PITCH}.mp3"
				draw_banner "VOICE"
				draw_position
			fi
			play -v "$VOICE_VOLUME" "$ALETHEIA/voices/voice-pitch${VOICE_PITCH}.mp3" >/dev/null 2>/dev/null &
		elif [ "$inputchar" == "" ]; then
			select_color "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			toggle_panels "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			toggle_dark_mode
			draw_volume
			draw_equalizer
			draw_position
		elif [ "$inputchar" == "" ]; then
			invert_colors  "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			toggle_colors "$initial_screen"
		elif [ "$inputchar" == "" ]; then
			if [ "$USE_TAGS" == true ]; then
				draw_banner "FILENAME"
				USE_TAGS=false
			else
				draw_banner "TAGS"
				USE_TAGS=true
			fi
			sleep $BANNER_WAIT_TIME
			if [ "$1" != true ]; then
				reset_buffer
			fi
		elif [ "$inputchar" == "#" ]; then
			save_settings true
		elif [ "$inputchar" == "c" ]; then
			cache_metadata
			draw_volume
			draw_equalizer
			if [ "$1" == true ]; then
				draw_position
				return
			else
				if [ "$in_menu" != true ]; then
					reset_buffer
					redraw_buffer
				else
					draw_banner "MENU"
				fi
				draw_position
				return
			fi
		elif [ "$inputchar" == "8" ]; then
			if [ "$(echo -e "$VOICE_VOLUME > 0.05" | bc)" == "1" ]; then
				VOICE_VOLUME="$(echo "$VOICE_VOLUME-0.05" | bc)"
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "9" ]; then
			if [ "$(echo -e "$VOICE_VOLUME < 1.0" | bc)" == "1" ]; then
				VOICE_VOLUME="$(echo "$VOICE_VOLUME+0.05" | bc)"
			fi
			gtts_speak "$VOICE_VOLUME" false false true
			flagged=true
		elif [ "$inputchar" == "d" ]; then
			echo "$SETUP_HELP" | sed -n "$first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/PCM/p,c,m/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | espeak-ng --stdin --punct -v en-us+m1 -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			draw_banner "VOICE"
			draw_position
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#SETUP_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				number_per_page="$original_number_per_page"
				if [ "$1" != true ]; then
					redraw_screen
				fi
				return
				;;
			esac
		else
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			if [ "$1" != true ]; then
				redraw_screen
			fi
			return
		fi
	done
}

render() {
	TMP_BUFFER=()
	local length="$1"
	local width="$2"
	local text="$3"
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi
	original_number_per_page="$number_per_page"

	mapfile -t text_array <<< "$text"

	FLAGGED=false

	length=${#text_array[@]}

	if [ "$length" -le "$number_per_page" ]; then
		number_per_page="$length"
		FLAGGED=true
	fi
	
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		if [ "$FLAGGED" == true ]; then
			TWO_COLUMN=false
		else
			TWO_COLUMN=true
		fi
	else
		TWO_COLUMN=false
	fi

	pos=1
	while [ "$pos" -lt "$length" ]; do
		buf=""
		if [ "$((length-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((length-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$length" ]; then
			return
		fi
		x=0
		for i in $(seq $pos $((pos + (number_per_page-1)))); do
			line="${text_array[$((i-1))]}"
			if [ "$TWO_COLUMN" == false ]; then
				pmt_line=""
			else
				pmt_line="${text_array[$((i+number_per_page-1))]}"
			fi
			if [ "${line:2:1}" != " " ]; then
				tmp1="$BLUE$line"
				tmp2=""
					if [ "$TWO_COLUMN" == true ]; then
						if (( (i+number_per_page-2) < ${#text_array[@]} )); then
							if [ "${pmt_line:2:1}" != " " ]; then
								pmt1="$BLUE$pmt_line"
								pmt2=""
							else
								pmt1="$BLUE ${pmt_line:0:2}"
								pmt2="$WHITE${pmt_line#* * }"
								pmt_line=" $BLUE ${pmt_line:0:2} $WHITE${pmt_line# * * }"
							fi
						fi
					else
						pmt_line=""
					fi
			else
				tmp1="$BLUE ${line:0:2}"
				tmp2="$WHITE${line#* * }"
				if [ "$TWO_COLUMN" == true ]; then
					if (( (i+number_per_page-2) < ${#text_array[@]} )); then
						pmt1="$BLUE ${pmt_line:0:2}"
						pmt2="$WHITE${pmt_line#* * }"
					fi
				else
					pmt_line=""
				fi

				if [ "${pmt_line:2:1}" != " " ]; then
					pmt1="$BLUE$pmt_line"
					pmt2=""
				fi

			fi

			if [ "$TWO_COLUMN" == true ]; then
				difference=$((((COLUMNS/2) - width + 2) / 2))
			else
				difference=$(((COLUMNS - width + 2) / 2 ))
			fi

			if [ "$NO_VERTICAL_PADDING" == true ]; then
				offset=$((x+1))
			else
				offset=$((x+2))
			fi

			if [ "$pmt_line" != "" ] && [ "$line" != "" ]; then
				buf[x]="$(tput el; tput cuf $difference)$tmp1 $tmp2$(tput el)$(tput cup $offset $(((COLUMNS/2+difference))))$pmt1 $pmt2$(tput el)\n"
			else
				buf[x]="$(tput el; tput cuf $difference)$tmp1 $tmp2$(tput el)\n"
			fi

			((x++))
		done

		until [ "$x" == "$original_number_per_page" ]; do
			buf[x]="\n"
			((x++))
		done

		TMP_BUFFER+=("$(printf '%s' "${buf[@]}")")

		if [ "$TWO_COLUMN" == false ]; then
			pos="$((pos+number_per_page))"
		else
			if [ "$((pos+(number_per_page*2)))" -lt "$length" ]; then
				pos="$((pos+(number_per_page*2)))"
			else
				return
			fi
		fi
	done
}

render_repeat_help_screen() {
	render $((REPEAT_HELP_LENGTH+1)) "$(echo -ne "$REPEAT_HELP" | wc -L)" "$REPEAT_HELP"
	REPEAT_HELP_BUFFER=("${TMP_BUFFER[@]}")
}

loop_help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak "loop controls"

	width="$(echo -ne "$REPEAT_HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#REPEAT_HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page

		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${REPEAT_HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${REPEAT_HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$((page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			echo "$REPEAT_HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/|/vertical slash/g" | sed "s/?/question mark/g" | sed "s/-/minus /g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			draw_volume
			draw_equalizer
			empty_pane
			draw_banner "HELP" false false true
			tput cup $LINES $((COLUMNS-12))
			echo -ne "${BLUE_BLACK}BEG$WHITE_BLACK:${BLUE_BLACK}END$WHITE_BLACK:${BLUE_BLACK}GAP$PADDING"
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#REPEAT_HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				return
				;;
			esac
		else
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

render_help_screen() {
	render $((HELP_LENGTH+1)) "$(echo -ne "$HELP" | wc -L)" "$HELP"
	tput rc
	HELP_BUFFER=("${TMP_BUFFER[@]}")
}

help_screen() {
	if [ "$NO_HELP" == true ]; then
		return
	fi
	gtts_speak "key controls"
	local initial_screen=$1

	width="$(echo -ne "$HELP" | wc -L)"
	if [ "$COLUMNS" -ge "$(((width*2)+3))" ]; then
		TWO_COLUMN=true
	else
		TWO_COLUMN=false
	fi

	page=0
	until [ "$page" -lt "0" ] || [ "$page" -gt "${#HELP_BUFFER[@]}" ]; do
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			number_per_page=$((LINES-2))
		else
			number_per_page=$((LINES-4))
		fi
		original_number_per_page=$number_per_page

		tput cup 0
		echo -ne "$BLUE_BLACK${PADDING}PCM${WHITE_BLACK}:${BLUE_BLACK}LEF${WHITE_BLACK}:${BLUE_BLACK}RIG"
		printf '%*s' $((COLUMNS - 24)) ""
		echo -ne "${BLUE_BLACK}BAS${WHITE_BLACK}:${BLUE_BLACK}MID${WHITE_BLACK}:${BLUE_BLACK}TRE$PADDING$NOCOLOR"

		tput cup $LINES
		echo -ne "${BLUE_BLACK}${PADDING}INT${WHITE_BLACK}:${BLUE_BLACK}EDO${WHITE_BLACK}:${BLUE_BLACK}TOG"
		printf '%*s' $((COLUMNS - 24)) ""
		echo -ne "${BLUE_BLACK}POS${WHITE_BLACK}:${BLUE_BLACK}QUE${WHITE_BLACK}:${BLUE_BLACK}TOG$PADDING$NOCOLOR"

		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR${HELP_BUFFER[$page]}"

		helpbuflines=$(echo -ne "${HELP_BUFFER[$page]}" | grep -cvE "^$")
		if [ "$helpbuflines" -lt "$original_number_per_page" ]; then
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				empty_pane "$((helpbuflines+1))"
			else
				empty_pane "$((helpbuflines+2))"
			fi
		fi

		if [ "$TWO_COLUMN" == true ]; then
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			else
				_first=$(((page*number_per_page*2)+1))
				last=$(((page*number_per_page*2)+(number_per_page*2)))
			fi
		else
			if [ "$page" == "0" ]; then
				_first=1
				last=$(((page*number_per_page)+number_per_page))
			else
				_first=$(((page*number_per_page)+1))
				last=$(((page*number_per_page)+number_per_page))
			fi
		fi

		read -rsn1 inputchar <&1
		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page down"
			if [ "$((page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
				page=$((page+1))
				gtts_speak "page down"
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "page up"
			if [ "$page" -gt "0" ]; then
				page=$((page-1))
				gtts_speak "page up"
			fi
		elif [ "$inputchar" == "d" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			echo "$HELP" | sed -n "$_first,${last}p" | sed "s/$/\n/g" | sed "s/-EDO/ EDO/g" | sed "s/EDO/e d o/g" | sed "s/INT/interval/g" | sed "s/PCM/p c m/g" | sed "s/'/single quote/g" | sed "s/\"/double quote/g" | sed "s/\./period/g" | sed "s/|/vertical slash/g" | sed "s/-[0-9]/minus &/g" | sed "s/\([a-zA-Z]\)\/\([a-zA-Z]\)/\1 or \2/g" | sed "s/?/question mark/g" | sed "s/[A-Z][A-Za-z]/\L&/g" | sed "s/\\/[A-Z]/\L&/g" | sed "s/[Aa] /&\n\n/g" | sed "s/I /I \n\n/g" | sed "s/  /\n\n/g" | sed "s/$/\n\n/g" | sed -E 's/\^([[:alpha:]])/\Lcontrol \1/g' | espeak-ng --stdin --punct -v en-us+m1 -k 2 >/dev/null 2>/dev/null &
			ESPEAK_PID="$!"
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			page=0
			reset_dimensions
			empty_pane
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ] || [ "$inputchar" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			if [ "$initial_screen" == false ]; then
				draw_volume
				draw_equalizer
				draw_banner "MENU"
				draw_position
			fi
			return
		elif [ "$inputchar" == "m" ]; then
			man aletheia
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$((page+1))" -lt "${#HELP_BUFFER[@]}" ]; then
					page=$((page+1))
				fi
				;;
			'[A')
				if [ "$page" -gt "0" ]; then
					page=$((page-1))
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				gtts_speak "closed" true
				number_per_page="$original_number_per_page"
				if [ "$initial_screen" == false ]; then
					draw_volume
					draw_equalizer
					draw_banner "MENU"
					draw_position
				fi
				return
				;;
			esac
		else
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak "closed" true
			number_per_page="$original_number_per_page"
			return
		fi
	done
}

start_search() {
	kill "$ESPEAK_PID" >/dev/null 2>/dev/null
	draw_banner "SEARCH"
	draw_position
	tput rc
	echo -ne "$BLUE_BLACK"
	gtts_speak "search keywords"
	if [ "$WEB_CLIENT" == "0" ]; then
		jump="$(read_line)"
	else
		read -r -t 0.1 jump <"$ALETHEIA/web_client_pipe$$"
		if [ "$jump" == "" ]; then
			jump="$(read_line)"
		fi
	fi
	jump_regex="${jump// /.*}"
	if [ "$jump" != "" ]; then
		if [ "$(isnum "$jump")" != "0" ]; then
			jump="${jump#"${jump%%[!0]*}"}"
			if [ "$jump" -lt "1" ]; then
				if [ "$1" == false ]; then
					redraw_buffer
				fi
			elif [ "$jump" -le "$TOTAL_QUEUE" ]; then
				if [ "$jump" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jump"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					if [ "$1" == false ]; then
						redraw_buffer
						draw_pitch
					fi
					draw_position
				fi
			else
				if [ "$1" == false ]; then
					redraw_buffer
					draw_pitch
				fi
				draw_position
			fi
		else
			jump="$(echo -ne "$jump" | iconv -f utf-8 -t ascii//TRANSLIT)"
			mapfile -t search_array < <(printf '%s\n' "${queue_array[@]}" | iconv -f utf-8 -t ascii//TRANSLIT | grep -niE "$jump_regex" | grep -v '.repeat.')
			length=${#search_array[@]}
			if [ "$length" == "1" ]; then
				LOOP_ARTIST=false
				JUMP=${search_array[0]%%:*}
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				return $RETURN_JUMP
			elif [ "$length" == "0" ]; then
				if [ "$1" == false ]; then
					draw_pitch
					draw_position
					redraw_buffer
				fi
			else
				search_queue "$1"
				if [ "$?" == "$RETURN_JUMP" ]; then
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
			fi
		fi
	else
		if [ "$1" == true ]; then
			gtts_speak "search canceled"
		else
			gtts_speak "search canceled. main screen"
			draw_pitch
			draw_position
			redraw_buffer
		fi
	fi
}

new_playlist() {
	local initial_screen=$1
	KEYWORD=""
	gtts_speak "enter keywords to start new playlist"
	draw_banner "SEARCH"
	keyw="$(read_line)"
	if [ "$keyw" == "" ]; then
		draw_pitch
	else
		KEYWORD="${keyw// /.*}"
		file_list="$(find "$MUSICDIR" -type f)"
		matches="$(echo -e "$file_list" | grep -n "" | iconv -f utf-8 -t ascii//TRANSLIT | grep -iE ".*${KEYWORD}.*mp3$|.*${KEYWORD}.*flac$" | grep -v '.repeat.')"
		if [ "$2" == "true" ]; then
			IFS=$'\n'
			index=$TOTAL_QUEUE
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[$index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$((index+1))
			done
			unset IFS
			if [ "$index" == "$TOTAL_QUEUE" ]; then
				gtts_speak "nothing found" true
				draw_pitch
				draw_position
				return
			fi
		else
			unset queue_array
			IFS=$'\n'
			index=0
			for i in $matches; do
				ind="$(echo -n "$i" | cut -d':' -f1)"
				queue_array[$index]="$(echo -n "$file_list" | sed -n "${ind}p")"
				index=$((index+1))
			done
			unset IFS
			if [ "$index" == "0" ]; then
				gtts_speak "nothing found" true
				draw_pitch
				draw_position
				return
			fi
		fi
		VIDEO=false
		TOTAL_QUEUE="$index"
		echo -ne "$NOCOLOR"
		if [ "$2" == true ]; then
			gtts_speak "closed" true
			reset_buffer
		else
			JUMP="1"
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			return $RETURN_JUMP
		fi
	fi
}

search_queue() {
	page=0
	already_said=false
	total=${#search_array[@]}
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		local number_per_page="$((LINES-2))"
	else
		local number_per_page="$((LINES-4))"
	fi
	local original_number_per_page="$number_per_page"

	local FLAGGED=false
	local REDRAWN=false
	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	new_page=false
	current_pos=1
	local pos=1
	while [ "$pos" -le "$total" ] || [ "$FLAGGED" == false ]; do
		BUFFER=""
		tput cup 0
		if [ "$((total-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((total-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		tmp_buf=""
		_last=$((pos+number_per_page))
		diff=$((_last-pos))
		for i in $(seq 1 $diff); do
			truepos=$i
			line="${search_array[$(((pos+i-1)-1))]}"
			m="$(echo -ne "$line" | cut -d':' -f1)"
			if [ "$m" == "" ]; then
				break
			fi

			line="${line##*/}"
			line="${line%.*}"
			tmp_buf[$((i-1))]="$m$line"

			if (( m < 10 )); then
				pad=" "
			else
				pad=""
			fi

			line="${line:0:$((COLUMNS-${#m}-4-${#pad}))}"
			if (( ( pos + i - 1) == current_pos || m == POSITION)); then
				BUFFER="$BUFFER$BLUE_BLACK$PADDING ${m} $WHITE_BLACK$line$(tput el)$NOCOLOR\n"
			else
				BUFFER="$BUFFER$BLUE$PADDING ${m} $WHITE$line$(tput el)$NOCOLOR\n"
			fi
		done
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR$BUFFER"
		
		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$((number_per_page+2))"
		fi
		draw_banner "SEARCH"
		printf '%*s' $((COLUMNS - 14)) ""
		tput rc
		if [ "$new_page" == true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			new_page=false
			ind=$((current_pos-(page*number_per_page-1)-2))
			one=${tmp_buf[ind]%%*}
			two=${tmp_buf[ind]##*}
			gtts_speak_chain "$one" "$two" &
		fi

		if [ "$already_said" != true ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			chained=()
			index=0
			for i in $(seq 0 $((${#tmp_buf[@]}-1))); do
				chained[index]="${tmp_buf[i]%%*}"
				((index++))
				chained[index]="${tmp_buf[i]##*}"
				chained[index]=${chained[index]//\~/\-}
				((index++))
			done
			gtts_speak_chain "${chained[@]}" &
			already_said=true
		fi

		if [ "$WEB_CLIENT" == "0" ]; then
			read -rsn1 inputchar <&1
		else
			read -rsn1 -t 0.1 inputchar <"$ALETHEIA/web_client_pipe$$"
			if [ "$inputchar" == "" ]; then
				read -rsn1 inputchar <&1
			fi
		fi

		if [ "$inputchar" = "j" ]; then
			if (( (pos + number_per_page) <= total )); then
				already_said=false
				kill %% >/dev/null 2>/dev/null
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				gtts_speak "page down"
				((page++))
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+original_number_per_page))"
				current_pos=$pos
			fi
		elif [ "$inputchar" = "k" ]; then
			already_said=false
			if (( (pos - number_per_page) <= 1 )); then
				pos=1
				current_pos=$pos
				continue
			else
				FLAGGED=false
			fi
			kill %% >/dev/null 2>/dev/null
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			gtts_speak "page up"
			((--page))
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos=$((pos-original_number_per_page))
			current_pos=$pos
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$inputchar" == "h" ]; then
			if (( current_pos < total )); then
				((current_pos++))
			else
				continue
			fi
			kill %% >/dev/null 2>/dev/null
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			if [ "$current_pos" -gt "${#tmp_buf[@]}" ]; then
				ind=$((current_pos-(page*original_number_per_page-1)-2))
				one=${tmp_buf[ind]%%*}
				two=${tmp_buf[ind]##*}
			else
				ind=$((current_pos-1))
				one=${tmp_buf[ind]%%*}
				two=${tmp_buf[ind]##*}
			fi
			if [ "$current_pos" -gt "$((pos+i-1))" ]; then
				((page++))
				new_page=true
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$((pos+original_number_per_page))" -le "$total" ]; then
					pos="$((pos+original_number_per_page))"
				fi
			else
				gtts_speak_chain "$one" "$two" &
			fi
		elif [ "$inputchar" == "l" ]; then
			if (( current_pos > 1 )); then
				((--current_pos))
			else
				continue
			fi
			kill %% >/dev/null 2>/dev/null
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			if [ "$current_pos" -gt "${#tmp_buf[@]}" ]; then
				one=${tmp_buf[$((current_pos-(page*original_number_per_page-1)-2))]%%*}
				two=${tmp_buf[$((current_pos-(page*original_number_per_page-1)-2))]##*}
			else
				one=${tmp_buf[$((current_pos-1))]%%*}
				two=${tmp_buf[$((current_pos-1))]##*}
			fi
			if [ "$current_pos" -lt "$pos" ]; then
				((--page))
				CHANGED=true
				new_page=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				current_pos="$((pos+number_per_page-1))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			else
				gtts_speak_chain "$one" "$two" &
			fi
		elif [ "$inputchar" == "" ]; then
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			JUMP=${search_array[$((current_pos-1))]%%:*}
			return "$RETURN_JUMP"
		elif [ "$(isnum "$inputchar")" != "0" ]; then
			gtts_speak " $inputchar"
			up_down="$(read_line "$inputchar")"
			jumpto="$up_down"
			if [ "$jumpto" -le "$TOTAL_QUEUE" ]; then
				if [ "$jumpto" -gt "0" ]; then
					LOOP_ARTIST=false
					JUMP="$jumpto"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					return
				fi
			fi
			return
		elif [ "$inputchar" == "s" ]; then
			start_search false
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			else
				BUFFER="$BUFFER_BACKUP"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				return
			fi
		elif [ "$inputchar" == "T" ]; then
			FLAGGED=false
		elif [ "$inputchar" == "d" ]; then
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			gtts_speak_chain "${chained[@]}" &
			FLAGGED=false
		elif [ "$inputchar" == "q" ]; then #|| [ "$inputchar" == "" ]; then
			pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			draw_volume
			draw_equalizer
			if [ "$1" == false ]; then
				gtts_speak "search canceled. main screen"
				redraw_buffer
			else
				gtts_speak "search canceled"
			fi
			draw_pitch
			draw_position
			return
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "SEARCH"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$((total-number_per_page-1))"
				fi
				;;
			'[A')
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				gtts_speak "search canceled. main screen"
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position

				return
				;;
			esac
		fi
	done
}

queue_controls() {
	SEARCHBUFFER="$(ls -1 "$ALETHEIA/playlists/")"
	total="$(echo -e "$SEARCHBUFFER" | wc -l)"
	tmp_buf=()
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		local number_per_page="$((LINES-2))"
	else
		local number_per_page="$((LINES-4))"
	fi
	local original_number_per_page="$number_per_page"
	local FLAGGED=false
	local REDRAWN=false

	if [ "$total" -le "$number_per_page" ]; then
		number_per_page="$total"
		FLAGGED=true
	fi

	local BUFFER_BACKUP="$BUFFER"

	local pos=1
	while [ "$((pos-1))" -le "$total" ]; do
		if [ "$total" == "0" ]; then
			SEARCHBUFFER="\n"
			total="$(echo -e "$SEARCHBUFFER" | wc -l)"
		else
			SEARCHBUFFER="$(ls -1 "$ALETHEIA/playlists/")"
			total="$(echo -e "$SEARCHBUFFER" | wc -l)"
		fi
		BUFFER=""
		tput cup 0
		if [ "$((total-pos))" -lt "$number_per_page" ]; then
			number_per_page=$((total-pos+1))
			FLAGGED=true
		fi
		if [ "$pos" -gt "$total" ]; then
			return
		fi
		for i in $(seq $pos $((pos + (number_per_page-1)))); do
			line="$(echo -e "$SEARCHBUFFER" | sed -n "${i}p")"

			if [ "$i" -lt "10" ]; then
				pad=" "
			else
				pad=""
			fi

			line="$(echo "$line" | cut -b 1-$((COLUMNS-${#i}-3)))"
			if [ "$line" == "" ]; then
				line="(none)"
			fi

			tmp_buf[i]="$i$line"
			BUFFER="$BUFFER$BLUE ${i} $WHITE$line$(tput el)\n"
		done
		if [ "$NO_VERTICAL_PADDING" == true ]; then
			tput cup 1
		else
			tput cup 2
		fi
		echo -ne "$NOCOLOR$BUFFER"

		chained=()
		index=0
		for i in $(seq 0 $((${#tmp_buf[@]}))); do
			chained[index]="${tmp_buf[i]%%*}"
			((index++))
			chained[index]="${tmp_buf[i]##*}"
			((index++))
		done

		gtts_speak_chain "${chained[@]}" &

		if [ "$number_per_page" -lt "$original_number_per_page" ]; then
			empty_pane "$((number_per_page+2))"
		fi
		draw_banner "SELECT LIST"

		read -rsn1 inputchar

		if [ "$inputchar" = "j" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			pos="$((pos+number_per_page))"
			if [ "$pos" -gt "$total" ]; then
				pos="$((total-number_per_page-1))"
			fi
		elif [ "$inputchar" = "k" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$((pos-number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
		elif [ "$(isnum "$inputchar")" == "1" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			jumpto="$(read_line "$inputchar" true)"
			if [ "$?" == "1" ]; then
				gtts_speak "invalid number. select playlist"
				continue
			fi
			if [ "$jumpto" -le "$total" ]; then
				if [ "$jumpto" -gt "0" ]; then
					PICK="$(echo -ne "$SEARCHBUFFER" | sed -n "${jumpto}p")"
					if [ "$PICK" == "" ]; then
						gtts_speak "number not valid"
					else
						unset queue_array

						IFS=$'\n'
						index=0
						while read -r i; do
							queue_array[$index]="$i"
							index=$((index+1))
						done < "$ALETHEIA/playlists/$PICK"
						unset IFS
						TOTAL_QUEUE=$((index-1))
						JUMP="1"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
					continue
				else
					continue
				fi
			else
				gtts_speak "invalid number. select playlist"
				continue
			fi
			return
		elif [ "$inputchar" == "D" ]; then
			draw_banner "DELETE"
			gtts_speak "enter number to delete"
			read -rn1 c
			if [ "$(isnum "$c")" == "1" ]; then
				c="$(read_line "$c" true)"
				if [ "$?" == "1" ]; then
					gtts_speak "invalid number. select playlist"
					continue
				fi
				if [ "$c" -gt "0" ] && [ "$c" -le "$total" ]; then
					draw_banner "DELETE" true

					gtts_speak "delete $c?"
					read -rsn1 z
					if [ "$z" == "y" ] || [ "$z" == "Y" ]; then
						pmt_PICK="$(echo -ne "$SEARCHBUFFER" | sed -n "${c}p")"
						rm "$ALETHEIA/playlists/$pmt_PICK"
						gtts_speak "deleted"
					else
						gtts_speak "delete canceled"
					fi
				fi
			else
				gtts_speak "invalid number. select playlist"
				continue
			fi
		elif [ "$inputchar" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$VOICE_ENABLED" == true ]; then
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			fi
			PICK="$(echo -ne "$SEARCHBUFFER" | head -1)"
			if [ "$PICK" == "" ]; then
				gtts_speak "no queues"
			else
				unset queue_array

				IFS=$'\n'
				index=0
				while read -r i; do
					queue_array[$index]="$i"
					index=$((index+1))
				done < "$ALETHEIA/playlists/$PICK"
				unset IFS
				TOTAL_QUEUE=$((index-1))
				JUMP="1"
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				return $RETURN_JUMP
			fi
		elif [ "$inputchar" == "d" ]; then
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			gtts_speak_chain "${chained[@]}" &
		elif [ "$inputchar" == "Z" ]; then
			if [ "$initial_screen" == true ]; then
				continue
			fi
			gtts_speak "save queue as?"
			draw_banner "SAVE QUEUE"
			tmp="$(read_line)"
			if [ "$tmp" != "" ]; then
				if [ ! -e "$ALETHEIA/playlists/" ]; then
					mkdir "$ALETHEIA/playlists"
				fi
				echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
				gtts_speak "saved"
			else
				gtts_speak "canceled"
			fi
			draw_banner "SELECT LIST"
			draw_position
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == "i" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			if [ "$REDRAWN" == false ]; then
				BUFFER="$BUFFER_BACKUP"
			fi
			number_per_page="$original_number_per_page"
			if [ "$1" == false ] || [ "$1" == "" ]; then
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
			fi
			gtts_speak "closed" true
			return 200 
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page="$((LINES-2))"
			else
				number_per_page="$((LINES-4))"
			fi
			original_number_per_page="$number_per_page"
			REDRAWN=true
			clear
			reset_buffer
			draw_volume
			draw_equalizer
			draw_banner "SELECT LIST"
			draw_position
			FLAGGED=false
			pos=1
			continue
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				pos="$((pos+number_per_page))"
				if [ "$pos" -gt "$total" ]; then
					pos="$((total-number_per_page-1))"
				fi
				;;
			'[A')
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				kill "$ESPEAK_PID" >/dev/null 2>/dev/null
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				number_per_page="$original_number_per_page"
				if [ "$1" == false ] || [ "$1" == "" ]; then
					draw_volume
					draw_equalizer
					draw_pitch
					draw_position
				fi
				return 200
				;;
			esac
		fi
	done
}

set_equalizer() {
	echo -ne "$WHITE_BLACK"
	draw_banner "BASS"
	gtts_speak "bass"
	bass="$(read_number)"
	if [ "$bass" == "" ]; then
		gtts_speak "closed" true
		return
	fi
	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup $((LINES-2))
	else
		tput cup $((LINES-4))
	fi
	draw_banner "MID"
	gtts_speak "mid"
	mid="$(read_number)"
	if [ "$mid" == "" ]; then
		gtts_speak "closed" true
		return
	fi
	draw_banner "TREBLE"
	gtts_speak "treble"
	treble="$(read_number)"
	if [ "$treble" == "" ]; then
		gtts_speak "closed" true
		return
	fi

	if [ "$bass" == "0" ] && [ "$mid" == "0" ] && [ "$treble" == "0" ]; then
		gtts_speak "equalizer off"
	else
		gtts_speak "equalizer on"
	fi

	bass="$bass:$bass:$bass"
	mid="$mid:$mid:$mid:$mid"
	treble="$treble:$treble:$treble"

	EQUALIZER="$bass:$mid:$treble"
	if [ "$1" != true ]; then
		echo -e "af_cmdline equalizer $EQUALIZER" >"$ALETHEIA/pipe$$" &
	fi

	equal="$(echo "$EQUALIZER" | cut -d':' -f1)"
	equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f4)"
	equal="$equal:$(echo "$EQUALIZER" | cut -d':' -f8)"

	draw_volume
	draw_equalizer
	if [ "$1" != true ] && [ "$2" != true ]; then
		draw_pitch
		draw_position
	fi
}

print_queue() {
	pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
	kill "$ESPEAK_PID" >/dev/null 2>/dev/null

	already_said=false
	current=$POSITION
	BUFFER_BACKUP="$BUFFER"

	if [ "$NO_VERTICAL_PADDING" == true ]; then
		number_per_page="$((LINES-2))"
	else
		number_per_page="$((LINES-4))"
	fi

	original_number_per_page="$number_per_page"

	FLAGGED=false
	REDRAWN=false

	if [ "$NO_VERTICAL_PADDING" == true ]; then
		tput cup 1
	else
		tput cup 2
	fi

	CHANGED=false

	stty -echo
	HALF="$((POSITION % number_per_page + (number_per_page/2) + 1))"

	if [ "$POSITION" -lt "$number_per_page" ]; then
		if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
			HALF="1"
		else
			HALF="1"
		fi
	elif [ "$number_per_page" -lt "$original_number_per_page" ]; then
			HALF="$((TOTAL_QUEUE-original_number_per_page+1))"
			number_per_page="$original_number_per_page"
	elif [ "$POSITION" -gt "$((original_number_per_page*2 - 1))" ]; then
		HALF="$((POSITION-(original_number_per_page/2)))"
	fi

	if [ "$((TOTAL_QUEUE-POSITION))" -lt "$number_per_page" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page+3))"
	fi
	if [ "$((HALF+original_number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
		HALF="$((TOTAL_QUEUE-original_number_per_page))"
		number_per_page="$original_number_per_page"
	fi

	half_page="$((number_per_page/2))"
	if [ "$POSITION" -gt "$half_page" ]; then
		result="$((POSITION-half_page))"
		if [ "$((number_per_page % 2))" != "" ]; then
			HALF="$result"
		else
			HALF=$((1+result))
		fi

		if [ "$((HALF+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
			HALF="$((TOTAL_QUEUE-number_per_page+1))"
		fi
	fi

	if [ "$HALF" -gt "$((TOTAL_QUEUE-number_per_page))" ]; then
		HALF="$((TOTAL_QUEUE-number_per_page+1))"
	fi
	if [ "$HALF" -lt "1" ]; then
		HALF=1
	fi

	pos=$HALF
	while [ "$pos" -le "$TOTAL_QUEUE" ]; do
		stty -echo
		echo -ne "$NOCOLOR"
		if [ "$((TOTAL_QUEUE-pos))" -lt $number_per_page ] && [ "$pos" -lt "$number_per_page" ]; then
			number_per_page="$TOTAL_QUEUE"
			FLAGGED=true
		fi
		if [ "$((pos+number_per_page))" -gt "$TOTAL_QUEUE" ] && [ "$number_per_page" != "1" ]; then
			number_per_page="$original_number_per_page"
		fi
		if [ "$pos" -gt "$TOTAL_QUEUE" ]; then
			return 200
		fi
		if [ "$number_per_page" -gt "$TOTAL_QUEUE" ]; then
			number_per_page="$TOTAL_QUEUE"
		fi
		flaggy=false
		if [ "$pos" -le $POSITION ] && [ "$((pos + (number_per_page-1)))" -ge "$POSITION" ] || [ $CHANGED == true ] ; then
			if [ "$pos" == "$TOTAL_QUEUE" ] && [ "$TOTAL_QUEUE" != "1" ]; then
				number_per_page="$original_number_per_page"
				pos="$((pos-number_per_page))"
			fi
			x=0
			end=$((number_per_page-1))
			_last=$((pos+end))
			diff=$((_last-pos+1))
			truepos=$((i-1+pos))
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				tput cup 1
			else
				tput cup 2
			fi
			m=$pos
			new_buf=""
			tmp_buf=()
			for i in $(seq 1 $number_per_page); do
				_REP="$WHITE"
				if [ "$m" == "$POSITION" ] && [ "$PANELS_ENABLED" == true ]; then
					_REP="$WHITE_BLACK"
				fi

				n=${queue_array[$((m-1))]}
				ext=${n##*.}
				piece=${n%.*}
				piece=${piece%.*}
				if [ -e "${piece}.repeat.${ext}" ]; then
					if [ "$m" == "$POSITION" ] && [ "$PANELS_ENABLED" ]; then
						REP="$BLUE_BLACK"
					else
						REP="$BLUE"
					fi
				else
					REP=""
				fi
				if [ -e "$n.locked" ]; then
					if [ -e "$n.repeats" ]; then
						INDICATOR="${_REP}$REP#"
					else
						INDICATOR="${_REP}$"
					fi
				else
					if [ -e "$n.repeats" ]; then
						INDICATOR="${_REP}$REP&"
					else
						INDICATOR="${_REP} "
					fi
				fi
				if [ "$TOTAL_QUEUE" -gt "9" ]; then
					if [ "$m" -lt "10" ]; then
						pad=" "
					else
						pad=""
					fi
					display_pad="$pad"
				fi
				if [ "$POSITION" == "$m" ]; then
					rep=""
				else
					rep="$BLUE"
				fi
				if [ "$current" == "$m" ] || [ "$POSITION" == "$m" ]; then
					value=$((COLUMNS-(${#PADDING}*2)-3-${#m}-${#display_pad}))
					nline="$(get_metadata "$m")"
					newline="${nline:0:$value}"
					padd="$(printf '%*s' $((value-${#newline})) "")"
					new_buf="$new_buf$BLUE_BLACK${PADDING}$INDICATOR$BLUE_BLACK $display_pad$BLUE_BLACK$m $rep$newline$padd$PADDING$NOCOLOR\n"
				else
					nline="$(get_metadata "$m")"
					value=$((COLUMNS-(${#PADDING}*2)-3-${#m}))
					newline="${nline:0:$value}"
					new_buf="$new_buf${PADDING}$BLUE$INDICATOR$BLUE $display_pad$BLUE$m $WHITE$newline$(tput el)\n"
				fi
				tmp_buf[$((i-1))]="$m$nline"
				m=$((m+1))
			done

			echo -ne "$new_buf"

			if [ "$already_said" == false ]; then
				pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
				kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
				chained=()
				index=0
				for i in $(seq 0 $((${#tmp_buf[@]}-1))); do
					chained[index]="${tmp_buf[i]%%*}"
					((index++))
					chained[index]="${tmp_buf[i]##*}"
					chained[index]=${chained[index]//\~/\-}
					((index++))
				done
				gtts_speak_chain "${chained[@]}" &
				already_said=true
			fi

			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				empty_pane "$((number_per_page+2))"
			fi
		else
			pos="$((pos+number_per_page))"
			continue
		fi

		draw_banner "PLAYLIST"
		tput rc
		
		read -rsn1 inputchar
		tput civis
		if [ "$inputchar" = "j" ]; then
			already_said=false
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			CHANGED=true
			if [ "$FLAGGED" == true ]; then
				continue
			fi
			if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
				if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
					pos="$((TOTAL_QUEUE-number_per_page+1))"
				else
					pos="$((pos+number_per_page))"
				fi
			fi
			if [ "$current" -le "$truepos" ]; then
				current=$pos
			fi
		elif [ "$inputchar" = "k" ]; then
			already_said=false
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			CHANGED=true
			if [ "$pos" == "1" ]; then
				continue
			else
				FLAGGED=false
			fi
			if [ "$number_per_page" -lt "$original_number_per_page" ]; then
				number_per_page="$original_number_per_page"
			fi
			pos="$((pos-number_per_page))"
			if [ "$pos" -le "0" ]; then
				pos=1
			fi
			current=$pos
		elif [ "$inputchar" = "h" ]; then
			if [ "$current" == "$TOTAL_QUEUE" ]; then
				continue
			fi
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			line="${queue_array[current]##*/}"
			line="${line%.*}"
			gtts_speak "$line"
			current=$((current+1))
			if [ "$current" -gt "$truepos" ]; then
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$((TOTAL_QUEUE-number_per_page+1))"
					else
						pos="$((pos+number_per_page))"
					fi
				fi
			fi

			skip=true
		elif [ "$inputchar" = "l" ]; then
			if [ "$current" == "1" ]; then
				continue
			fi
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			pkill -f "^play.*voices.*" >/dev/null 2>/dev/null
			current=$((current-1))
			line="${queue_array[$(($((current-1))))]##*/}"
			line="${line%.*}"
			gtts_speak "$line"
			if [ "$current" -lt "$((truepos-number_per_page+1))" ]; then
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
			fi

			skip=true
		elif [ "$(isnum "$inputchar")" != "0" ]; then
			up_down="$(read_line "$inputchar")"
			if [ "$(isnum "$up_down")" != "0" ]; then
				up_down="${up_down#"${up_down%%[!0]*}"}"
				if [ "$up_down" -lt "1" ]; then
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				elif [ "$up_down" -le "$TOTAL_QUEUE" ]; then
					JUMP="$up_down"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					draw_pitch
					draw_position
					redraw_buffer
					return 200
				fi
			fi
		elif [ "$inputchar" == "b" ]; then
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM_BACK
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST_BACK
			elif [ "$ONLY_LOCKED" == true ]; then
				return $RETURN_ONLY_LOCKED_BACK
			else
				return $RETURN_BACK
			fi
		elif [ "$inputchar" == "n" ]; then
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				return $RETURN_NEXT
			fi
		elif [ "$inputchar" == "" ]; then
			if [ "$USE_TAGS" == true ]; then
				draw_banner "FILENAME"
				USE_TAGS=false
			else
				draw_banner "TAGS"
				USE_TAGS=true
			fi
			sleep $BANNER_WAIT_TIME
		elif [ "$inputchar" == "s" ]; then
			start_search
			if [ "$?" == "$RETURN_JUMP" ]; then
				return $RETURN_JUMP
			fi
		elif [ "$inputchar" == "z" ]; then
			draw_wait false
			CHANGED=true
			REDRAWN=true
			pos=1
			clear
			reset_dimensions
			if [ "$NO_VERTICAL_PADDING" == true ]; then
				number_per_page=$((LINES-2))
			else
				number_per_page=$((LINES-4))
			fi
			original_number_per_page=$number_per_page
			draw_volume
			draw_equalizer
			draw_banner "PLAYLIST"
			draw_position
			reset_buffer
			continue
		elif [ "$inputchar" == "?" ]; then
			queue_help_screen
			continue
		elif [ "$inputchar" == "x" ]; then
			if [ "$TOTAL_QUEUE" == "1" ]; then
				continue
			fi
			for (( i=$((current-1)); i < ${#queue_array[@]}; i++ )); do
				queue_array[$i]="${queue_array[$((i+1))]}"
			done
			TOTAL_QUEUE=$((TOTAL_QUEUE-1))
			draw_position
			if [ "$TOTAL_QUEUE" -lt "$number_per_page" ]; then
				number_per_page=$TOTAL_QUEUE
			fi
			if [ "$((pos+number_per_page))" -gt "$TOTAL_QUEUE" ]; then
				if [ "$pos" -gt 1 ]; then
					pos=$((pos-1))
				fi
			fi
			if [ "$((current-1))" == "$TOTAL_QUEUE" ]; then
				current=$((current-1))
			fi
			if [ "$current" == "$POSITION" ]; then
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				POSITION=$((POSITION-1))
			elif [ "$current" -lt "$POSITION" ]; then
				POSITION=$((POSITION-1))
			fi
		elif [ "$inputchar" == "<" ]; then
			if [ "$current" -lt "$TOTAL_QUEUE" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$((POSITION+1))
				elif [ "$((current+1))" == "$POSITION" ]; then
					POSITION=$((POSITION-1))
				fi
				tmp="${queue_array[$current]}"
				queue_array[$current]="${queue_array[$((current-1))]}"
				queue_array[$((current-1))]="$tmp"
				current=$((current+1))
				if [ "$current" -gt "$truepos" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					CHANGED=true
					if [ "$FLAGGED" == true ]; then
						continue
					fi
					if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
						if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
							pos="$((TOTAL_QUEUE-number_per_page+1))"
						else
							pos="$((pos+number_per_page))"
						fi
					fi
				fi
			fi
		elif [ "$inputchar" == ">" ]; then
			if [ "$current" -gt "1" ]; then
				if [ "$current" == "$POSITION" ]; then
					POSITION=$((POSITION-1))
				elif [ "$((current-1))" == "$POSITION" ]; then
					POSITION=$((POSITION+1))
				fi
				tmp="${queue_array[$((current-2))]}"
				queue_array[$((current-2))]="${queue_array[$((current-1))]}"
				queue_array[$((current-1))]="$tmp"
				current=$((current-1))
				if [ "$current" -lt "$((truepos-number_per_page+1))" ]; then
					kill "$ESPEAK_PID" >/dev/null 2>/dev/null
					CHANGED=true
					if [ "$pos" == "1" ]; then
						continue
					else
						FLAGGED=false
					fi
					if [ "$number_per_page" -lt "$original_number_per_page" ]; then
						number_per_page="$original_number_per_page"
					fi
					pos="$((pos-number_per_page))"
					if [ "$pos" -le "0" ]; then
						pos=1
					fi
				fi
			fi
		elif [ "$inputchar" == "p" ]; then
			if [ "$PAUSE" == true ]; then
				draw_position
				gtts_speak "unpaused"
			else
				gtts_speak "paused"
			fi
			toggle_pause true
			continue
		elif [ "$inputchar" == "d" ]; then
			toggle_voice true
			if [ "$VOICE_ENABLED" == true ]; then
				espeak_say " ${tmp_buf[*]}"
				already_said=true
			fi
		elif [ "$inputchar" == $'\e' ]; then
			read -rn2 -t 0.03 key
			case $key in
			'[B')
				CHANGED=true
				if [ "$FLAGGED" == true ]; then
					continue
				fi
				if [ "$((pos+number_per_page))" -le "$TOTAL_QUEUE" ]; then
					if [ "$((pos+(number_per_page*2)))" -gt "$TOTAL_QUEUE" ]; then
						pos="$((TOTAL_QUEUE-number_per_page+1))"
					else
						pos="$((pos+number_per_page))"
					fi
				fi
				;;
			'[A')
				CHANGED=true
				if [ "$pos" == "1" ]; then
					continue
				else
					FLAGGED=false
				fi
				if [ "$number_per_page" -lt "$original_number_per_page" ]; then
					number_per_page="$original_number_per_page"
				fi
				pos="$((pos-number_per_page))"
				if [ "$pos" -le "0" ]; then
					pos=1
				fi
				;;
			*)
				if [ "$REDRAWN" == false ]; then
					BUFFER="$BUFFER_BACKUP"
				fi
				echo -ne "$NOCOLOR"
				reset_buffer
				draw_equalizer
				draw_volume
				draw_pitch
				draw_position
				redraw_buffer
				return 200
				;;
			esac
		elif [ "$inputchar" == "q" ] || [ "$inputchar" == ";" ] || [ "$inputchar" == "" ]; then
			kill "$(cat "$ALETHEIA/espeak.pid")" >/dev/null 2>/dev/null
			BUFFER="$BUFFER_BACKUP"
			echo -ne "$NOCOLOR"
			reset_buffer
			draw_volume
			draw_equalizer
			redraw_buffer
			draw_pitch
			draw_position
			gtts_speak "queue closed. main screen"
			return 200
		elif [ "$inputchar" == "" ]; then
			kill "$ESPEAK_PID" >/dev/null 2>/dev/null
			kill "$MPLAYER_PID" >/dev/null 2>/dev/null
			JUMP="$current"
			draw_position
			return $RETURN_JUMP
		fi
	done
	redraw_screen true
}

_save_setting() {
	if [ "$(echo "$CONFIG" | grep -i "$1")" == "" ]; then
		CONFIG="$CONFIG\n$1=$2"
	else
		CONFIG="$(echo -ne "$CONFIG" | sed -e "/$1/s/.*/$1=$2/g")"
	fi
}

save_settings() {
	draw_banner "SAVE" true
	gtts_speak "save settings?"
	while true; do
		read -rsn1 yesno
		if [ "$yesno" == "z" ]; then
			draw_wait false
			reset_dimensions
			draw_banner "SAVE" true
			redraw_screen false 1 1 0 0
		else
			break
		fi
	done
	if [ "$yesno" == "y" ]; then
		_save_setting "VOICE_PITCH" "$VOICE_PITCH"
		_save_setting "DEFAULT_VOLUME" "$DEFAULT_VOLUME"
		_save_setting "VOICE_VOLUME" "$VOICE_VOLUME"
		_save_setting "PANELS_ENABLED" "$PANELS_ENABLED"
		_save_setting "DARK_BACKGROUND" "$DARK_BACKGROUND"
		_save_setting "ONLY_VOICE_TITLES" "$ONLY_VOICE_TITLES"
		_save_setting "COLORS_ENABLED" "$COLORS_ENABLED"
		_save_setting "DEFAULT_EQUALIZER" "$DEFAULT_EQUALIZER"
		_save_setting "DEFAULT_THEME" "$DEFAULT_THEME"
		if [ "$VOICE_ENABLED" == true ]; then
			_save_setting "VOICE_ENABLED" "true"
		else
			_save_setting "VOICE_ENABLED" "false"
		fi
		echo -e "$CONFIG" >"$ALETHEIA/config"
		gtts_speak "saved" true
	else
		gtts_speak "canceled" true
	fi
	draw_pitch
	draw_position
}

main() {
	PAUSE=false
	MUTE=false
	LOCKED=false
	SCALETEMPO=false
	FLAGS=""
	START_MARKER="0.0"
	END_TIME=""
	space=0
	SAVED_INTERVAL=""
	SAVED_POSITION=()
	CURRENT_POSITION=""
	SAVED_TOTAL=""

	if [ "$VOLUME" == "" ]; then
		VOLUME="$DEFAULT_VOLUME"
	fi
	INTERVAL="$DEFAULT_INTERVAL"
	EDO="$DEFAULT_EDO"
	INTERVAL_LIMIT=$(echo "$EDO * 2.6" | bc)
	INTERVAL_UPPER_LIMIT=$(echo "$EDO * 2.1" | bc)

	if [ -e "$FILENAME.locked" ]; then
		LOCKED=true

		if [ "$LOCKED_OFF" == false ]; then
			read_locked_file "$(cat "$FILENAME.locked")"
		fi

		if [ "$VOLUME" == "" ]; then
			VOLUME="$DEFAULT_VOLUME"
		fi

		FLAGS="-speed $(calc "2^($INTERVAL/$EDO)") -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"

		if [ "$_scaletempo_flag" == "1" ]; then
			FLAGS="$FLAGS,scaletempo=speed=tempo"
			SCALETEMPO=true
		elif [ "$_scaletempo_flag" == "2" ]; then
			FLAGS="$FLAGS,scaletempo=speed=pitch"
			SCALETEMPO=true
			ONLY_PITCH=true
		else
			SCALETEMPO=false
		fi
	else
		FLAGS="-speed $(calc "2^($DEFAULT_INTERVAL/$DEFAULT_EDO)") -volume $VOLUME -af equalizer=$EQUALIZER,volnorm"
	fi

	if [ -e "$FILENAME.repeats" ]; then
		REPEATS="$(cat "$FILENAME.repeats")"
		REPEAT_CURRENT=1
		REPEAT_TOTAL="$(echo "$REPEATS" | wc -l)"
	else
		REPEATS=""
		REPEAT_CURRENT=0
		REPEAT_TOTAL=0
	fi

	LOOP=false
	echo -ne "$NOCOLOR"
	reset_buffer
	redraw_buffer
	draw_equalizer
	draw_volume

	if [[ "$TITLE" == *" - "* ]]; then
		ARTISTSONG="$ARTIST - $SONG"
	else
		ARTISTSONG="$TITLE"
	fi
	if [ "$ONLY_VOICE_TITLES" == true ]; then
		gtts_speak "$ARTISTSONG" false false true &
	else
		gtts_speak "$ARTISTSONG" &
	fi

	LOCKED_EDO="$EDO"

	if [ "$VIDEO" == false ]; then
		FLAGS+=" -novideo"
	fi
	if [ "$FULLSCREEN" == true ]; then
		FLAGS+=" -fs"
	fi
	if [ "$ALWAYS_ON_TOP" == true ]; then
		FLAGS+=" -ontop"
	fi
	if [ "$REPEAT_ONLY" == true ]; then
		FLAGS+=" -volume 0"
	fi

	rm -f "$ALETHEIA/mplayer_output" >/dev/null 2>/dev/null

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
		var1="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev).repeat.$ext"
		if [ ! -e "$var1" ]; then
			var1="$FILENAME"
		fi
	else
		var1="$FILENAME"
	fi
	# shellcheck disable=SC2086
	# In this case, we want word splitting to expand $FLAGS for use by mplayer
	"${MPLAYER_PATH}"mplayer -slave -osdlevel 0 -ao pulse -softvol -softvol-max 100 -hr-mp3-seek -quiet -input file="$ALETHEIA/pipe$$" -noconfig all $FLAGS "$var1" >"$ALETHEIA/mplayer_output" 2>/dev/null &

	MPLAYER_PID="$!"

	if [ "$SELECT_REPEAT_FILE" == true ]; then
		SELECT_REPEAT_FILE=false
	fi
	
	if [ "$REPEAT_ONLY" == true ]; then
		repeat
		repeat_tmp=$?
		gtts_speak "loop editor closed. main screen" true
		if [ "$repeat_tmp" != "200" ]; then
			return $repeat_tmp
		fi
	else
		draw_pitch
		draw_position
	fi

	old_LINES=$LINES
	old_COLUMNS=$COLUMNS

	stty -echo
	while true; do
		if [ "$old_LINES" != "$LINES" ] || [ "$old_COLUMNS" != "$COLUMNS" ]; then
			clear
			draw_wait false
			reset_dimensions
			redraw_screen false
			if [ "$MUTE" == true ]; then
				draw_banner "MUTE"
			elif [ "$PAUSE" == true ]; then
				draw_banner "PAUSE"
			fi
			gtts_speak "screen redrawn"
			old_LINES=$LINES
			old_COLUMNS=$COLUMNS
		fi
		if [ "$WEB_CLIENT" == "0" ]; then
				read -rsn1 -t "$MAIN_REFRESH_TIME" input
		else
			read -rsn1 -t 0.4 input
			if [ "$input" == "" ] && [ "$WEB_CLIENT" == "1" ]; then
				read -rsn1 -t 0.3 input <"$ALETHEIA/web_client_pipe$$"
			fi
		fi

		if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
			if [ "$TRACK_RANDOM" == true ]; then
				return $RETURN_TRACK_RANDOM
			elif [ "$LOOP_ARTIST" == true ]; then
				return $RETURN_LOOP_ARTIST
			else
				return $RETURN_NEXT
			fi
		fi

		case "$input" in
			'j')
				pitch_down
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'k')
				pitch_up
				ret=$?
				if [ "$OUTPUT" != "" ]; then
					input=$OUTPUT
				fi
				if [ "$ret" != "200" ]; then
					return $ret
				fi
				;;
			'o')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				double_precise
				;;
			'm')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				half_precise
				;;
			'i')
				main_menu false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'p')
				toggle_pause
				;;
			'n')
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST
				else
					return $RETURN_NEXT
				fi
				;;
			'b')
				if [ "$POSITION" == "0" ]; then
					POSITION=1
				fi
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				if [ "$TRACK_RANDOM" == true ]; then
					return $RETURN_TRACK_RANDOM_BACK
				elif [ "$LOOP_ARTIST" == true ]; then
					return $RETURN_LOOP_ARTIST_BACK
				elif [ "$ONLY_LOCKED" == true ]; then
					return $RETURN_ONLY_LOCKED_BACK
				else
					return $RETURN_BACK
				fi
				;;
			'8')
				system_volume_change false 3 3
				;;
			'9')
				system_volume_change true 3 3
				;;
			'y')
				set_default_edo
				;;
			'h')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_position
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				echo "seek -5%" >"$ALETHEIA/pipe$$" &
				;;
			'l')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$TRACK_RANDOM" == true ]; then
						return $RETURN_TRACK_RANDOM
					elif [ "$LOOP_ARTIST" == true ]; then
						return $RETURN_LOOP_ARTIST
					else
						return $RETURN_NEXT
					fi
				fi
				echo "seek +5%" >"$ALETHEIA/pipe$$" &
				;;
			';')
				BUFFER_BACKUP="$BUFFER"
				print_queue
				ret="$?"
				if [ "$ret" != 200 ]; then
					return $ret
				fi
				;;
			'?')
				help_screen
				draw_volume
				draw_equalizer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'q')
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$_input" != "" ]; then
					if [ "$_input" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					fi
				fi
				draw_banner "QUIT" true
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "do you want to quit? enter y, or n, or q to cancel"
				fi
				input_char=""
				while true; do
					read -rn1 input_char
					if [ "$input_char" == "y" ]; then
						echo -ne "$NOCOLOR"
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						clear
						stty echo
						return $RETURN_QUIT
					elif [ "$input_char" == "q" ] || [ "$input_char" == "" ]; then
						draw_pitch
						draw_position
						break
					elif [ "$input_char" == "n" ]; then
						draw_pitch
						draw_position
						break
					fi
				done
				gtts_speak "quit canceled. main screen"
				;;
			'P')
				old_percent=0
				percentbreak=false
				ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$?" != "1" ]; then
					echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					percent="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d'=' -f2)"
					if [ "$(isnum "$percent")" == "0" ]; then
						percent=1
					fi
					if [ "$hours" == "00" ]; then
						total_=$((COLUMNS-(${#PADDING}*2)-14))
					else
						total_=$((COLUMNS-(${#PADDING}*2)-17))
					fi
					PAUSE=false
					tput cup $LINES
					echo -ne "$BLUE_BLACK${PADDING}00$WHITE_BLACK:${BLUE_BLACK}00 "
					echo -ne "${BLUE_BLACK}[$WHITE_BLACK"
					percent=$(calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1)
					if [ "$percent" -gt "$total_" ]; then
						percent="$total_"
					fi
					gtts_speak "progress bar"
					printf '%*s' $percent | tr " " "="
					printf '%*s' $((total_ - percent)) ""
					echo -ne "$BLUE_BLACK] "
					if [ "$hours" == "00" ]; then
						echo -ne "$BLUE_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING"
					else
						echo -ne "$BLUE_BLACK$hours$WHITE_BLACK:$BLUE_BLACK$minutes$WHITE_BLACK:$BLUE_BLACK$seconds$PADDING"
					fi
					if [ "$(echo -ne "$minutes" | cut -c 1)" == "0" ]; then
						minutes="$(echo -ne "$minutes" | cut -c 2)"
					fi
					if [ "$(echo -ne "$seconds" | cut -c 1)" == "0" ]; then
						seconds="$(echo -ne "$seconds" | cut -c 2)"
					fi
					total_seconds_tt=$((minutes * 60 + seconds))
					tput cup $LINES 8
					l=0
					input_char=""
					until [ "$input_char" != "" ]; do
						if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
							if [ "$TRACK_RANDOM" == true ]; then
								return $RETURN_TRACK_RANDOM
							elif [ "$LOOP_ARTIST" == true ]; then
								return $RETURN_LOOP_ARTIST
							else
								return $RETURN_NEXT
							fi
						fi
						echo "get_percent_pos" >"$ALETHEIA/pipe$$" &
						sleep $MPLAYER_WAIT_TIME
						percent="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d'=' -f2)"
						echo "get_time_pos" >"$ALETHEIA/pipe$$" &
						sleep $MPLAYER_WAIT_TIME
						tmpq="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d'=' -f2 | cut -d'.' -f1)"
						tput cup $LINES 1
						if [ "$(isnum "$tmpq")" == "1" ]; then
							dateo="$(date -u -d @"$tmpq" +%M:%S)"
							skip2=false
						else
							dateo="00:00"
							percent=$total_
							skip2=true
						fi
						echo -ne "$BLUE$(echo -ne "$dateo" | cut -d':' -f1)$WHITE:$BLUE$(echo -ne "$dateo" | cut -d':' -f2)"
						if [ "$skip2" == false ]; then
							tput cup $LINES $((COLUMNS-6))
							if [ "$INTERVAL" -lt "0" ]; then
								int="$(echo -ne "$INTERVAL" | cut -c 2-)"
								neg=true
								skip=false
							elif [ "$INTERVAL" -gt "0" ]; then
								int="$INTERVAL"
								neg=false
								skip=false
							else
								skip=true
							fi
							if [ "$skip" == false ]; then
								if [ "$neg" == true ]; then
									total_seconds_dateo="$(calc "$total_seconds_tt * (2 * $int / $EDO)" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1)"
								else
									total_seconds_dateo="$(calc "$total_seconds_tt * (($int / $EDO)/2)" | cut -d'	' -f2 | cut -d'~' -f2 | cut -d'.' -f1)"
									total_seconds_dateo=$((total_seconds_tt-total_seconds_dateo))
								fi
								new_minutes=$((total_seconds_dateo / 60))
								new_seconds=$((total_seconds_dateo % 60))
							else
								new_minutes=$minutes
								new_seconds=$seconds
							fi
							tput cup $LINES $((COLUMNS-6))
							new_minutes="$(printf '%02d' "$new_minutes")"
							new_seconds="$(printf '%02d' "$new_seconds")"
							echo -ne "$BLUE$new_minutes$WHITE:$BLUE$new_seconds"
							if [ "$(isnum "$percent")" == "0" ]; then
								percent=$total_
							fi
							percent=$(calc "$percent/100*$total_+1" | sed -e "s/\t//g" | cut -d'.' -f1)
							if [ "$percent" -gt "$total_" ]; then
								percent="$total_"
							fi
							
							tput cup $LINES 8
							echo -ne "$WHITE_BLACK"
							printf '%*s' $percent "" | tr " " "="
							printf '%*s' $((total_ - percent)) ""
						fi
						read -rn1 -t 1 input_char
						if [ "$input_char" == "l" ]; then
							if [ "$old_percent" -gt "$percent" ]; then
								percentbreak=true
								break
							fi
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									return $RETURN_NEXT
								fi
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							input_char=""
						elif [ "$input_char" == "h" ]; then
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_position
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							input_char=""
						elif [ "$input_char" == "j" ]; then
							pitch_down false true
							input_char=""
						elif [ "$input_char" == "k" ]; then
							pitch_up false true
							input_char=""
						fi
						l=0
						old_percent=$percent
					done
					if [ "$percentbreak" == true ]; then
						if [ "$TRACK_RANDOM" == true ]; then
							return $RETURN_TRACK_RANDOM
						elif [ "$LOOP_ARTIST" == true ]; then
							return $RETURN_LOOP_ARTIST
						else
							return $RETURN_NEXT
						fi
					fi
					if [ "$MUTE" == true ]; then
						draw_banner "MUTE"
					else
						draw_pitch
					fi
					draw_position
					gtts_speak "closed" true
				fi
				;;
			'$')
				gtts_speak "position saved"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep 0.05
				draw_banner "POS SAVED"
				sleep $BANNER_WAIT_TIME
				if [ "${#SAVED_POSITION[@]}" == "0" ]; then
					SAVED_TOTAL=1
					SAVED_POSITION[1]="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d '=' -f2)"
					CURRENT_POSITION=1
				else
					SAVED_TOTAL=$((SAVED_TOTAL+1))
					SAVED_POSITION[$SAVED_TOTAL]="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d '=' -f2)"
				fi
					
				draw_pitch
				draw_position
				;;
			'|')
				vanish
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'`')
				draw_banner "COMMAND"
				command="$(read_line)"
				if [ "$command" == "about" ]; then
					about
					read -rsn1 _
				elif [ "$command" != "" ]; then
					echo -e "$command" >"$ALETHEIA/pipe$$" &
					sleep $MPLAYER_WAIT_TIME
					empty_pane
					tput cup $((LINES-3))
					echo -ne "$PADDING$CYAN$(tail -1 "$ALETHEIA/mplayer_output")"
					tput el
					read -rn1 input_char
				fi
				redraw_buffer
				draw_pitch
				draw_position
				;;
			"\\")
				SAVED_POSITION=()
				CURRENT_POSITION=""
				if [ "$VIDEO" == true ] || [ "$VIDEO_FLAGGED" == true ]; then
					JUMP="$POSITION"
					kill "$MPLAYER_PID" 2>/dev/null >/dev/null
					if [ "$VIDEO" == false ]; then
						VIDEO_FLAGGED=false
					fi
					return $RETURN_JUMP
				else
					echo "seek 0 2" >"$ALETHEIA/pipe$$" &
					if [ "$PAUSE" == true ]; then
						PAUSE=false
						draw_pitch
						draw_position
					fi
				fi
				;;
			'5')
				draw_banner "START"
				gtts_speak "start"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				START_MARKER="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d '=' -f2)"
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep "$(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)"
				fi
				draw_pitch
				draw_position
				;;
			'%')
				rm -f "$FILENAME.repeats" >/dev/null 2>/dev/null
				gtts_speak "unlocked"
				if [ "$NO_VERTICAL_PADDING" == true ]; then
					tput cup $((LOCKING_POS+1)) 1
				else
					tput cup $((LOCKING_POS+2)) 1
				fi
				if [ -e "$FILENAME.locked" ]; then
					INDICATOR="${WHITE_BLACK}&"
				else
					INDICATOR="$BLUE_BLACK "
				fi
				echo -ne "$INDICATOR"
				;;
			'7')
				draw_banner "END"
				gtts_speak "end"
				echo "get_time_pos" >"$ALETHEIA/pipe$$" &
				sleep $MPLAYER_WAIT_TIME
				END_TIME="$(tail -1 "$ALETHEIA/mplayer_output" | cut -d '=' -f2)"
				END_MARKER=$END_TIME
				space=0
				if [ "$(echo "$BANNER_WAIT_TIME > $MPLAYER_WAIT_TIME" | bc)" == "1" ]; then
					sleep "$(echo "$BANNER_WAIT_TIME - $MPLAYER_WAIT_TIME" | bc)"
				fi
				draw_pitch
				draw_position
				;;
			'&')
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					SELECT_REPEAT_FILE=true
					JUMP="$POSITION"
					kill "$MPLAYER_PID"
					return $RETURN_JUMP
				else
					gtts_speak "none"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'6')
				repeat
				repeat_tmp="$?"
				gtts_speak "loop editor closed. main screen" true
				if [ "$repeat_tmp" != "200" ] && [ "$repeat_tmp" != "300" ]; then
					return $repeat_tmp
				fi
				;;
			'0')
				get_system_volume
				tmp_volume_left="$(echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1)"
				tmp_volume_right="$(echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1)"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					total="$tmp_volume_left"
				elif [ "$tmp_volume_right" -gt "$tmp_volume_left" ]; then
					total="$tmp_volume_right"
				else
					continue
				fi

				gtts_speak "balancing volume"

				draw_banner "BALANCING"

				flaggy=false
				while [ "$tmp_volume_left" != "$tmp_volume_right" ]; do
					if [ "$tmp_volume_left" -lt "$total" ]; then
						tmp_volume_left=$((tmp_volume_left+1))
					elif [ "$tmp_volume_left" -gt "$total" ]; then
						tmp_volume_left=$((tmp_volume_left-1))
					fi

					if [ "$tmp_volume_right" -lt "$total" ]; then
						tmp_volume_right=$((tmp_volume_right+1))
					elif [ "$tmp_volume_right" -gt "$total" ]; then
						tmp_volume_right=$((tmp_volume_right-1))
					fi

					get_system_volume
					pactl set-sink-volume @DEFAULT_SINK@ ${tmp_volume_left}% ${tmp_volume_right}%
					draw_volume 2 3
					read -rsn1 -t 0.08 c
					ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					if [ "$c" == "" ] || [ "$c" == "q" ] || [ "$c" == "0" ]; then
						flaggy=true
						break
					elif [ "$c" == "z" ]; then
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 0 1
						draw_banner "BALANCING"
					fi
				done
				draw_pitch
				if [ "$flaggy" == true ]; then
					get_system_volume
					continue
				fi
				;;
			')')
				get_system_volume
				tmp_volume_left="$(echo $SYSTEM_VOLUME_LEFT | cut -d'%' -f1)"
				tmp_volume_right="$(echo $SYSTEM_VOLUME_RIGHT | cut -d'%' -f1)"
				if [ "$tmp_volume_left" -gt "$tmp_volume_right" ]; then
					SYSTEM_VOLUME_RIGHT="${tmp_volume_left}%"
				else
					SYSTEM_VOLUME_LEFT="${tmp_volume_right}%"
					tmp_volume_left=$tmp_volume_right
				fi

				pactl set-sink-volume @DEFAULT_SINK@ "$SYSTEM_VOLUME_LEFT" "$SYSTEM_VOLUME_RIGHT"
				draw_volume
				gtts_speak "$tmp_volume_left"
				;;
			'G')
				oscillate
				;;
			'g')
				if [ "$INTERVAL" == "0" ]; then
					continue
				fi
				if [ "$PAUSE" == true ]; then
					echo -e "pause" >"$ALETHEIA/pipe$$" &
					PAUSE=false
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
				fi
				draw_banner "INVERT" false true
				old_int="$INTERVAL"
				INTERVAL="$((-(INTERVAL)))"
				gtts_speak "scaling"
				if [ "$INTERVAL" -lt "0" ]; then
					result="$old_int"
				else
					result="$INTERVAL"
				fi
				result="$((result*2))"
				x=0
				if [ "$old_int" -gt "0" ]; then
					NEGATIVE=false
				else
					NEGATIVE=true
				fi
				while [ "$x" -lt "$result" ]; do
					read -rsn1 -t "$SCALE_SPEED" c
					ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null
					if [ "$?" == "1" ]; then
						RIGHT_BANNER_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
						draw_pitch
						draw_position
						return
					fi
					secondary_scale_func "$c" "INVERT"
					if [ "$c" == "c" ]; then
						x=$((result-x))
						if [ "$NEGATIVE" == true ]; then
							NEGATIVE=false
						else
							NEGATIVE=true
						fi
					#FIXME
					elif [ "$c" == "o" ]; then
						old_int=$((old_int*2))
					elif [ "$c" == "m" ]; then
						old_int=$INTERVAL
					elif [ "$c" == "z" ]; then
						x2=$x
						draw_wait false
						reset_dimensions
						redraw_screen false 1 1 1 0
						draw_banner "INVERT" false true
						x=$x2
					elif [ "$c" == "d" ]; then
						toggle_voice
						draw_pitch
						draw_banner "INVERT" false true
					elif [ "$c" == "q" ] || [ "$c" == "" ] || [ "$c" == "m" ]; then
						break
					elif [ "$c" == "" ]; then
						if [ "$NEGATIVE" == false ]; then
							INTERVAL="$((old_int-1))"
							old_int="$((old_int-1))"
						else
							INTERVAL="$((old_int+1))"
							old_int="$((old_int+1))"
						fi
						echo -e "speed_set $(calc "2^($INTERVAL/$EDO)")" >"$ALETHEIA/pipe$$" &
						draw_pitch
						x="$((x+1))"
					fi

				done
				gtts_speak " $INTERVAL"
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'M')
				invert_int
				;;
			'f')
				tmux_attach
				;;
			'F')
				yt_search
				;;
			'C')
				yt_artist
				;;
			'W')
				add_downloaded
				;;
			'J')
				edo_down
				;;
			'I')
				read_corner
				gtts_speak "main screen"
				draw_pitch
				draw_position
				;;
			'K')
				edo_up
				;;
			'<')
				if [ "$VIDEO" == true ]; then
					gtts_speak "video disabled"
					VIDEO=false
					draw_banner "OFF"
					echo "vo_ontop 0" >"$ALETHEIA/pipe$$" &
				else
					gtts_speak "video enabled"
					VIDEO=true
					VIDEO_FLAGGED=true
					draw_banner "VIDEO ON"
					echo "vo_ontop 1" >"$ALETHEIA/pipe$$" &
				fi
				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				JUMP="$POSITION"
				return "$RETURN_JUMP"
				;;
			'>')
				if [ "$FULLSCREEN" == false ]; then
					echo "pausing_keep vo_fullscreen 1" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=true
					gtts_speak "video fullscreen"
					draw_banner "FULLSCREEN"
				else
					gtts_speak "video normal"
					echo "pausing_keep vo_fullscreen 0" >"$ALETHEIA/pipe$$" &
					FULLSCREEN=false
					draw_banner "OFF"
				fi
				stty -echo
				sleep $BANNER_WAIT_TIME
				stty echo
				RIGHT_BANNER_WIDTH=0
				draw_pitch
				draw_position
				;;
			'U')
				scale_edo
				;;
			'Z')
				gtts_speak "save queue as?"
				draw_banner "SAVE QUEUE"
				tmp="$(read_line)"
				if [ "$tmp" != "" ]; then
					if [ ! -e "$ALETHEIA/playlists/" ]; then
						mkdir "$ALETHEIA/playlists"
					fi
					echo -ne "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/playlists/$tmp"
					gtts_speak "saved"
				else
					gtts_speak "canceled"
				fi
				draw_pitch
				draw_position
				;;
			'c')
				toggle_mute
				;;
			't')
				zero_interval
				if [ "$?" == "$RETURN_QUIT" ]; then
					return $RETURN_QUIT
				fi
				;;
			'H')
				less_precise
				;;
			'L')
				more_precise
				;;
			'Y')
				zero_interval_jump
				;;
			'x')
				ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f1 | rev)"
				filename_without_ext="$(echo -ne "$FILENAME" | rev | cut -d'.' -f2- | rev)"
				if [ -e "$filename_without_ext.repeat.$ext" ]; then
					REP="$BLUE_BLACK"
				else
					REP=""
				fi
				if [ "$NO_VERTICAL_PADDING" == true ]; then
					tput cup $((LOCKING_POS+1)) 1
				else
					tput cup $((LOCKING_POS+2)) 1
				fi
				if [ -e "$FILENAME.locked" ]; then
					rm -f "$FILENAME".locked
					LOCKED=false
					gtts_speak "unlocked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}&"
					else
						echo -ne "$BLUE_BLACK "
					fi
				else
					if [ "$SCALETEMPO" == true ]; then
						if [ "$ONLY_PITCH" == true ]; then
							echo "$INTERVAL/$EDO/2" >"$FILENAME".locked
						else
							echo "$INTERVAL/$EDO/1" >"$FILENAME".locked
						fi
					else
						echo "$INTERVAL/$EDO/0" >"$FILENAME".locked
					fi
					LOCKED=true
					gtts_speak "locked"
					if [ -e "$FILENAME.repeats" ]; then
						echo -ne "${WHITE_BLACK}${REP}#"
					else
						echo -ne "${WHITE_BLACK}${REP}$"
					fi
				fi
				;;
			'a')
				PAUSE=false
				set_equalizer
				draw_pitch
				;;
			'')
				if [ "$CURRENT_POSITION" != "" ]; then
					CURRENT_POSITION=$((CURRENT_POSITION+1))
					if [ "$CURRENT_POSITION" -gt "$SAVED_TOTAL" ]; then
						CURRENT_POSITION=1
					fi
					echo "seek ${SAVED_POSITION[$CURRENT_POSITION]} 2" >"$ALETHEIA/pipe$$" &
				fi
				;;
			'v')
				toggle_scale_tempo
				;;
			'')
				select_color
				;;
			'')
				toggle_dark_mode
				redraw_screen
				;;
			'')
				gtts_speak " $INTERVAL" false false true
				;;
			'')
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					echo "quit 0" >"$ALETHEIA/pipe$$" &
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'')
				if [ "$USE_TAGS" == true ]; then
					draw_banner "FILENAME"
					USE_TAGS=false
				else
					draw_banner "TAGS"
					USE_TAGS=true
				fi
				sleep $BANNER_WAIT_TIME
				reset_buffer
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'')
				add_downloaded true
				if [ "$DOWNLOAD_POSITION" != "" ]; then
					JUMP="$DOWNLOAD_POSITION"
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				else
					gtts_speak "nothing downloaded"
					draw_banner "NONE"
					sleep $BANNER_WAIT_TIME
					draw_pitch
					draw_position
				fi
				;;
			'd')
				toggle_voice
				draw_pitch
				;;
			':')
				if [ "$DIMENSIONS_RESET" == true ]; then
					render_all_help_screens
					DIMENSIONS_RESET=false
				fi
				setup_screen
				;;
			'/')
				set_custom_edo
				;;
			'4')
				PAUSE=false
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_all_tuning
				;;
			'w')
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				reset_to_locked
				;;
			'T')
				if [ "$VOICE_ENABLED" == true ]; then
					gtts_speak "voice feedback disabled" false false true
					draw_banner "OFF"
					VOICE_ENABLED=false
				elif [ "$ONLY_VOICE_TITLES" == true ]; then
					ONLY_VOICE_TITLES=false
					VOICE_ENABLED=true
					gtts_speak "general voice feedback" false false true
					draw_banner "VOICE ON"
				else
					ONLY_VOICE_TITLES=true
					gtts_speak "reading only artist and title" false false true
					VOICE_ENABLED=false
					draw_banner "ONLY TITLE"
				fi
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				;;
			'z')
				tput civis
				draw_wait false
				reset_dimensions
				redraw_screen false
				if [ "$MUTE" == true ]; then
					draw_banner "MUTE"
				elif [ "$PAUSE" == true ]; then
					draw_banner "PAUSE"
				fi
				gtts_speak "screen redrawn"
				;;
			'O')
				gtts_speak "edit playlist"
				echo -e "$(printf '%s\n' "${queue_array[@]}")" >"$ALETHEIA/queue"
				cp "$ALETHEIA/queue" "$ALETHEIA/queue.old"
				vim +"$POSITION" "$ALETHEIA/queue"
				diff "$ALETHEIA"/queue "$ALETHEIA"/queue.old >/dev/null 2>/dev/null
				if [ "$?" == "1" ]; then
					unset queue_array

					IFS=$'\n'
					index=0
					while read -r i; do
						queue_array[$index]="$i"
						index=$((index+1))
					done < "$ALETHEIA/queue"
					unset IFS
					TOTAL_QUEUE=$index
					gtts_speak "saved"
					# FIXME
					new="$(printf '%s\n' "${queue_array[@]}" | grep -n "$FILENAME$" | cut -d':' -f1)"
					if [ "$new" == "" ]; then
						res="${queue_array[$POSITION]}"
						if [ "$res" != "$FILENAME" ]; then
							tput civis
							JUMP="$POSITION"
							kill "$MPLAYER_PID" >/dev/null 2>/dev/null
							return $RETURN_JUMP
						fi
					else
						POSITION="$new"
					fi
					reset_buffer
				else
					gtts_speak "closed" true
				fi
				tput civis
				redraw_buffer
				draw_volume
				draw_equalizer
				draw_pitch
				draw_position
				;;
			',')
				pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
				gtts_speak "$TITLE" true
				;;
			'')
				draw_banner "WAIT"
				if [ "$LOCKED" == true ]; then
					if [ "$REPEAT_CURRENT" -lt "1" ]; then
						say_locked_and_no_loops
					else
						say_locked_and_loops
					fi
				else
					if [ "$REPEAT_CURRENT" -lt "1" ]; then
						say_unlocked_and_no_loops
					else
						say_unlocked_and_loops
					fi
				fi
				draw_pitch
				draw_position
				;;
			'D')
				yesno=""
				if [ "$WEB_CLIENT" == "1" ]; then
					read -rsn1 -t 0.1 _input <"$ALETHEIA/web_client_pipe$$"
				fi
				if [ "$_input" != "" ]; then
					yesno="$_input"
				else
					draw_banner "DELETE" true
					gtts_speak "delete?"
				fi

				if [ "$yesno" == "" ]; then
					read -rsn1 yesno
				fi
				if [ "$yesno" == "y" ] || [ "$yesno" == "Y" ]; then
					if [ ! -d "$ALETHEIA/deleted" ] || [ ! -d "$ALETHEIA/deleted/voices" ]; then
						mkdir "$ALETHEIA/deleted"
						mkdir "$ALETHEIA/deleted/voices"
					fi
					mv "$FILENAME" "$ALETHEIA/deleted"
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "$ALETHEIA/deleted"
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "$ALETHEIA/deleted"
					fi
					path="$(echo -ne "$FILENAME" | rev | cut -d'/' -f2- | rev)"
					if [ "$(ls -1 "$path")" == "" ]; then
						rmdir "$path"
					fi
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						mv "$ALETHEIA/voices/$TITLE.mp3" "$ALETHEIA/deleted/voices/"
					fi
					draw_pitch
				else
					draw_pitch
					draw_position
					gtts_speak "canceled"
					continue
				fi
				tput el
				draw_position
				if [ "$POSITION" = "" ]; then
					return 0
				fi

				for i in $(seq "$POSITION" $((TOTAL_QUEUE-1))); do
					queue_array[$((i-1))]=${queue_array[$i]}
				done

				kill "$MPLAYER_PID" >/dev/null 2>/dev/null
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					JUMP="1"
					POSITION="1"
					draw_position
					TOTAL_QUEUE="$((TOTAL_QUEUE-1))"
					return $RETURN_JUMP
				else
					TOTAL_QUEUE="$((TOTAL_QUEUE-1))"
					return $RETURN_RESTART
				fi
				;;
			"'")
				jump_to_first_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'"')
				jump_to_last_of_artist
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				;;
			'N')
				if [ "$SHUFFLED" == false ]; then
					if [ "$ARTIST" != "" ]; then
						last="$(echo -ne "${queue_array[$((TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev | sed -e "s/ - //" | cut -d'' -f1)"
					else
						last="$(echo -ne "${queue_array[$((TOTAL_QUEUE-1))]}" | rev | cut -d'.' -f2- | cut -d'/' -f1 | rev)"
					fi
					if [ "$ARTIST" != "$last" ]; then
						IFS=$'\n'
						if [ "$ARTIST" != "" ]; then
							tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$ARTIST \- " | tail -1 | cut -d':' -f1)"
						else
							tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$TITLE" | tail -1 | cut -d':' -f1)"
						fi
						unset IFS
						JUMP="$((tmpq+1))"
						unset tmpq
						kill "$MPLAYER_PID" >/dev/null 2>/dev/null
						return $RETURN_JUMP
					fi
				fi
				;;
			'B')
				if [ "$SHUFFLED" == false ]; then
					IFS=$'\n'
					if [ "$ARTIST" != "" ]; then
						tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$ARTIST \- " | head -1 | cut -d':' -f1)"
					else
						tmpq="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$TITLE" | head -1 | cut -d':' -f1)"
					fi
					if [ "$tmpq" -gt "1" ]; then
						last_artist="$(echo -ne "${queue_array[$((tmpq-2))]}" | rev | cut -d'/' -f1 | cut -d'.' -f2- | rev)"
						if [ "$(echo -ne "$last_artist" | grep " - ")" != "" ]; then
							last_artist="$(echo -ne "$last_artist" | sed "s/ - //g" | cut -d'' -f1)"
							JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$last_artist \- " | head -1 | cut -d':' -f1)"
						else
							JUMP="$(printf '%s\n' "${queue_array[@]}" | grep -n "\/$last_artist" | head -1 | cut -d':' -f1)"
						fi
					fi
					unset IFS
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			's')
				start_search false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'S')
				new_playlist false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'')
				new_playlist false true
				redraw_buffer
				draw_pitch
				draw_position
				;;
			'Q')
				queue_controls false
				if [ "$?" == "$RETURN_JUMP" ]; then
					return $RETURN_JUMP
				fi
				redraw_buffer
				;;
			'#')
				save_settings
				;;
			'r')
				draw_banner "RENAME" true
				gtts_speak "rename file?"
				read -rsn1 yesno
				if [ "$yesno" == "y" ]; then
					ext="$(echo "$FILENAME" | rev | cut -d'.' -f1 | rev)"
					path="$(echo "$FILENAME" | rev | cut -d'/' -f2- | rev)"
					if [ "$(echo "$path" | grep '/')" = "" ]; then
						path="."
					fi
					gtts_speak "enter the new title"
					tput rc
					echo -ne "$WHITE_BLACK"
					printf '%*s' $((COLUMNS - 14)) ""
					tput rc
					echo -ne "$WHITE_BLACK"
					newname="$(read_line)"
					if [ "$newname" == "" ]; then
						redraw_buffer
						draw_pitch
						draw_position
						gtts_speak "canceled"
						continue
					fi
					mv "$FILENAME" "${path}/$newname.$ext" >/dev/null 2>/dev/null
					if [ -e "$ALETHEIA/voices/$TITLE.mp3" ]; then
						rm -f "$ALETHEIA/voices/$TITLE.mp3"
					fi
					if [ -e "$FILENAME.locked" ]; then
						mv "$FILENAME.locked" "${path}/$newname.$ext.locked" >/dev/null 2>/dev/null
					fi
					if [ -e "$FILENAME.repeats" ]; then
						mv "$FILENAME.repeats" "${path}/$newname.$ext.repeats" >/dev/null 2>/dev/null
					fi
					gtts_speak "$newname" true
					if [ "$POSITION" = "" ]; then
						POSITION=1
					fi

					export TITLE="$newname"
					export FILENAME="${path}/$newname.$ext" >/dev/null 2>/dev/null
					queue_array[$((POSITION-1))]="$FILENAME"

					reset_buffer
					draw_volume
					draw_equalizer
					redraw_buffer
					draw_pitch
					draw_position
					continue
				else
					gtts_speak "canceled"
				fi
				redraw_screen true
				;;
			'*')
				system_volume_change false 1 1
				;;
			'(')
				system_volume_change true 1 1
				;;
			'!')
				if [ "$PAUSE" == true ]; then
					PAUSE=false
					draw_pitch
				fi
				if [ "$MUTE" == true ]; then
					echo "mute" >"$ALETHEIA/pipe$$" &
					MUTE=false
					draw_pitch
				fi
				if [ "$VOLUME" -ge "1" ]; then
					VOLUME="$((VOLUME-1))"
					echo "volume $VOLUME 1" >"$ALETHEIA/pipe$$" &
					gtts_speak "$VOLUME"
					draw_equalizer
					draw_volume
				fi
				;;
			'1')
				pcm_volume_change "$input"
				if [ "$?" != "200" ]; then
					return $?
				fi
				;;
			'2')
				pcm_volume_change "$input"
				;;
			'@')
				pcm_volume_change "$input"
				;;
			'3')
				fade_volume
				;;
			'V')
				set_loop_artist
				;;
			'e')
				track_toggle
				if [ "$?" == 200 ]; then
					JUMP=1
					kill "$MPLAYER_PID" >/dev/null 2>/dev/null
					pkill -f "^play.*$ALETHEIA/voices" >/dev/null 2>/dev/null
					return $RETURN_JUMP
				fi
				;;
			'')
				toggle_colors
				;;
			'')
				invert_colors
				;;
			'')
				toggle_panels true
				;;
			'')
				if [ "$LOCKED_OFF" == true ]; then
					LOCKED_OFF=false
					gtts_speak "locked on"
					draw_banner "LOCK ON"
				else
					LOCKED_OFF=true
					gtts_speak "locked off"
					draw_banner "LOCK OFF"
				fi
				sleep $BANNER_WAIT_TIME
				draw_pitch
				draw_position
				;;
			'')
				load_loop_file
				;;
			'')
				REPEAT_ONLY=true
				gtts_speak "playlist loop mode" true
				JUMP="$POSITION"
				kill "$MPLAYER_PID"
				return $RETURN_JUMP
				;;
			'E')
				set_loop
				;;
			'~')
				set_sleep
				;;
			'R')
				shuffle_queue
				SHUFFLED=true
				draw_pitch
				draw_position
				;;
			'A')
				sort_queue
				SHUFFLED=false
				draw_position
				;;
			'.')
				set_custom_int
				;;
			'u')
				scale
				;;
			'X')
				set_scale_speed
				;;
			'')
				set_random
				;;
			'-')
				scale_octave "-"
				;;
			'=')
				scale_octave "+"
				;;
			'_')
				scale_octave "-" true
				;;
			'+')
				scale_octave "+" true
				;;
			*)
				if [ "$input" == "" ]; then
					read -rn2 -t 0.03 key >/dev/null 2>/dev/null
					case $key in
						'[B')
							pitch_down
							;;
						'[A')
							pitch_up
							;;
						'[D')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >"$ALETHEIA/pipe$$" &
								MUTE=false
								draw_pitch
							fi
							echo "seek -5%" >"$ALETHEIA/pipe$$" &
							;;
						'[C')
							if [ "$PAUSE" == true ]; then
								PAUSE=false
								draw_pitch
							fi
							if [ "$MUTE" == true ]; then
								echo "mute" >"$ALETHEIA/pipe$$" &
								MUTE=false
								draw_pitch
							fi
							if ! ps -p "$MPLAYER_PID" >/dev/null 2>/dev/null; then
								if [ "$TRACK_RANDOM" == true ]; then
									return $RETURN_TRACK_RANDOM
								elif [ "$LOOP_ARTIST" == true ]; then
									return $RETURN_LOOP_ARTIST
								else
									return $RETURN_NEXT
								fi
							fi
							echo "seek +5%" >"$ALETHEIA/pipe$$" &
							;;
						*)
							continue
							;;
					esac
				else
					process_key "$input"
				fi
				;;
		esac
	done
}

trap cleanup EXIT
trap cleanup_sigint SIGINT

if [ ! -d "$ALETHEIA/voices/" ]; then
	mkdir "$ALETHEIA/voices/"
fi

if [ ! -d "$ALETHEIA/playlists/" ]; then
	mkdir "$ALETHEIA/playlists"
fi

if [ ! -d "$MUSICDIR" ]; then
	mkdir -p "$MUSICDIR"
fi

if [ ! -d "$SOUNDDIR" ]; then
	mkdir -p "$SOUNDDIR"
fi

if [ ! -d "$VIDEODIR" ]; then
	mkdir -p "$VIDEODIR"
fi

rm -f "$ALETHEIA/pipe*" >/dev/null 2>/dev/null

mkfifo "$ALETHEIA/pipe$$"


exec 3<> "$ALETHEIA/pipe$$"

if [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	mkfifo "$ALETHEIA/web_client_pipe$$"
fi

tput sc

if [ "$2" != "" ]; then
	KEYWORDS="$(echo "$@" | cut -d' ' -f2-)"
fi

rendered=false

if [ "$1" == "--music" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$MUSICDIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	SHUFFLED=true
elif [ "$1" == "--sound" ] || [ "$WEB_CLIENT" == "1" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${AUDIO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$SOUNDDIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	SHUFFLED=true
	if [ "$WEB_CLIENT" == "1" ]; then
		node "$HOME/webserver.js" >/dev/null 2>/dev/null &
		NODE_PID="$!"
	fi
elif [ "$1" == "--video" ]; then
	if [ "$2" != "" ]; then
		KEYWORD="${KEYWORDS// /.*}"
		regex=".*${KEYWORD}.*\.\(${VIDEO_FORMATS//,/\\|}\)$"
	else
		regex=".*\.\(${VIDEO_FORMATS//,/\\|}\)$"
	fi
	mapfile -t queue_array < <(find "$VIDEODIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
	VIDEO=false
elif [ "$1" == "--directory" ]; then
	if [ "$2" != "" ]; then
		if [ -d "$2" ]; then
			if [ "$3" != "" ]; then
				KEYWORD="${*:3}"
				KEYWORD="${KEYWORD// /.*}"
				regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
			else
				regex=".*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
			fi
			mapfile -t queue_array < <(find "$2" -type f -iregex "$regex" | shuf)
			TOTAL_QUEUE=${#queue_array[@]}
			nodir=false
		else
			nodir=true
		fi
	else
		nodir=true
	fi
	if [ "$nodir" == true ]; then
		clear
		tput cup $LINES
		echo -e "${RED}Error: ${NOCOLOR}No directory specified.$NOCOLOR"
		exit 1
	fi
elif [ "$1" == "--file" ]; then
	if [ "$2" == "" ]; then
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}No file specified."
		exit 1
	elif [ -e "$2" ]; then
		queue_array[0]="$(realpath "$2")"
		TOTAL_QUEUE=1
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}'$2' does not exist."
		exit 1
	fi
elif [ "$1" == "--playlist" ]; then
	if [ -e "$2" ]; then
		mapfile -t queue_array < "$2"
		TOTAL_QUEUE=${#queue_array[@]}
	else
		clear
		tput cup $LINES
		echo -e "\n${RED}Error: ${NOCOLOR}Playlist file '$2' does not exist."
		exit 1
	fi
elif [ "$1" == "--server" ]; then
	WEB_CLIENT=1
	node "$HOME/webserver.js" >/dev/null 2>/dev/null &
	NODE_PID="$!"

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" == "--mplayer-path" ]; then
	if [ "$2" == "" ]; then
		echo -e "${RED}Error: ${WHITE}--mplayer-path <path>"
		exit 1
	else
		if [ -d "$2" ]; then
			MPLAYER_PATH="$2/"
		else
			if [ -e "$2" ]; then
				echo -e "${RED}Error: ${WHITE}$2 is not a directory.$NOCOLOR"
				exit 1
			else
				echo -e "${RED}Error: ${WHITE}Directory $2 does not exist.$NOCOLOR"
				exit 1
			fi
		fi
	fi
	render_all_help_screens
	empty_pane

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
elif [ "$1" != "" ]; then
	KEYWORD="${*}"
	KEYWORD="${KEYWORD// /.*}"
	regex=".*${KEYWORD}.*\.\(${AUDIO_FORMATS//,/\\|}\|${VIDEO_FORMATS//,/\\|}\)$"
	mapfile -t queue_array < <(find "$MUSICDIR" "$SOUNDDIR" "$VIDEODIR" -type f -iregex "$regex" | shuf)
	TOTAL_QUEUE=${#queue_array[@]}
else
	if [ "$WEB_CLIENT" == "1" ]; then
		node "$HOME/webserver.js" >/dev/null 2>/dev/null &
		NODE_PID="$!"
	fi

	render_all_help_screens
	empty_pane

	main_menu true
	if [ "$?" == "$RETURN_JUMP" ]; then
		start_at_pos=$JUMP
	else
		start_at_pos=1
	fi
fi

if [ "$TOTAL_QUEUE" == "0" ]; then
	tput cup $LINES
	if [ "$2" == "" ]; then
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found."
	else
		echo -e "\n${RED}Error: ${NOCOLOR}Nothing found with keyword '$KEYWORDS'"
	fi
	exit 1
fi

if [ "$rendered" == false ]; then
	render_all_help_screens
	empty_pane
fi

if [ "$start_at_pos" == "" ]; then
	start_at_pos=1
fi

POSITION=$start_at_pos
RUNTHROUGH=false

while (( (POSITION <= TOTAL_QUEUE) && (POSITION >= 1) )); do
	FILENAME="${queue_array[$((POSITION-1))]}"
	TITLE="${FILENAME##*/}"
	TITLE="${TITLE%.*}"
	LOOP_ON=false

	if [[ "$TITLE" == *" - "* ]]; then
		ARTIST="${TITLE%% - *}"
		SONG="${TITLE##* - }"
	else
		ARTIST=""
		SONG=""
	fi

	if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
		RUNTHROUGH=true
	fi

	if [ "$ONLY_LOCKED" == true ]; then
		if [ ! -e "$FILENAME.locked" ]; then
			if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					if [ "$RUNTHROUGH" == false ]; then
						JUMP="1"
						RETURN="$RETURN_JUMP"
						RUNTHROUGH=true
					else
						web_client_func
						main
						RETURN="$?"
					fi
				else
					RETURN="0"
				fi
			fi
		else
			if [ "$REPEAT_ONLY" == true ]; then
				if [ ! -e "$FILENAME.repeats" ]; then
					if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
						RETURN="0"
					fi
				else
					web_client_func
					main
					RETURN="$?"
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		fi
	else
		if [ "$REPEAT_ONLY" == true ]; then
			if [ ! -e "$FILENAME.repeats" ]; then
				if [ "$LOOP_ARTIST" == true ]; then
					RETURN="$RETURN_LOOP_ARTIST"
				else
					if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
						if [ "$RUNTHROUGH" == false ]; then
							JUMP="1"
							RETURN="$RETURN_JUMP"
							RUNTHROUGH=true
						else
							web_client_func
							main
							RETURN="$?"
						fi
					else
						if [ "$RETURN" != "$RETURN_ONLY_LOCKED_BACK" ]; then
							RETURN="0"
						fi
					fi
				fi
			else
				web_client_func
				main
				RETURN="$?"
			fi
		else
			web_client_func
			main
			RETURN="$?"
		fi
	fi

	if [ "$RETURN" == "$RETURN_QUIT" ]; then
		echo -ne "$NOCOLOR"
		exit 0
	elif [ "$RETURN" == "$RETURN_BACK" ]; then
		if [ "$POSITION" == "1" ]; then
			POSITION=$TOTAL_QUEUE
		else
			POSITION=$((POSITION - 1))
		fi
		TRACK_RANDOM=false
	elif [ "$RETURN" == "$RETURN_RESTART" ]; then
		continue
	elif [ "$RETURN" == "$RETURN_JUMP" ]; then
		POSITION="$JUMP"
		POSITION_WIDTH=$((${#POSITION} + ${#TOTAL_QUEUE} + 1 + (${#CORNER_DIVIDER}*2)))
		RIGHT_BANNER_WIDTH=$POSITION_WIDTH
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST" ]; then
		new_POSITION="$(printf '%s\n' "${queue_array[@]}" | sed "1,${POSITION}d" | grep -ni "\/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
		if [ "$new_POSITION" != "" ]; then
			POSITION="$((new_POSITION+POSITION))"
		else
			if [ "$ARTIST" == "" ]; then
				LOOP_ARTIST=false
				if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
					POSITION=1
				else
					POSITION=$((POSITION+1))
				fi
			else
				POSITION="$(printf '%s\n' "${queue_array[@]}" | grep -ni "\/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
			fi
		fi
	elif [ "$RETURN" == "$RETURN_LOOP_ARTIST_BACK" ]; then
		if [ "$ARTIST" == "" ]; then
			LOOP_ARTIST=false
			if [ "$POSITION" != "1" ]; then
				POSITION=$((POSITION-1))
			fi
		else
			new_POSITION="$(printf '%s\n' "${queue_array[@]}" | sed "${POSITION},${TOTAL_QUEUE}d" | tac | grep -ni "\/$LOOP_ARTIST_NAME -" | head -1 | cut -d':' -f1)"
			if [ "$new_POSITION" != "" ]; then
				POSITION="$((POSITION-new_POSITION))"
			else
				POSITION="$(printf '%s\n' "${queue_array[@]}" | grep -ni "\/$LOOP_ARTIST_NAME -" | tail -1 | cut -d':' -f1)"
			fi
		fi
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM" ]; then
		POSITION="$((1 + RANDOM % TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_TRACK_RANDOM_BACK" ]; then
		POSITION="$((1 + RANDOM % TOTAL_QUEUE))"
	elif [ "$RETURN" == "$RETURN_ONLY_LOCKED_BACK" ]; then
		POSITION="$((POSITION-1))"
		if [ "$POSITION" == "0" ]; then
			POSITION="$TOTAL_QUEUE"
		elif [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=0
		fi
	else
		if [ "$POSITION" == "$TOTAL_QUEUE" ]; then
			POSITION=1
		else
			POSITION=$((POSITION+1))
		fi
	fi
done

echo -ne "$NOCOLOR"
exit 0
